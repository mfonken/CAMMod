Disassembly Listing for CamMod
Generated From:
C:/Users/Matthew Fonken/Desktop/camera-module/CamMod/firmware/CamMod.X/dist/default/debug/CamMod.X.debug.elf
Feb 16, 2017 9:33:47 PM

---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/system_tasks.c
1:                   /*******************************************************************************
2:                    System Tasks File
3:                   
4:                     File Name:
5:                       system_tasks.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to maintain system's polled state
9:                       machines.
10:                  
11:                    Description:
12:                      This file contains source code necessary to maintain system's polled state
13:                      machines.  It implements the "SYS_Tasks" function that calls the individual
14:                      "Tasks" functions for all polled MPLAB Harmony modules in the system.
15:                  
16:                    Remarks:
17:                      This file requires access to the systemObjects global data structure that
18:                      contains the object handles to all MPLAB Harmony module objects executing
19:                      polled in the system.  These handles are passed into the individual module
20:                      "Tasks" functions to identify the instance of the module to maintain.
21:                   *******************************************************************************/
22:                  
23:                  // DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                   *******************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Section: Included Files
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  
54:                  #include "system_config.h"
55:                  #include "system_definitions.h"
56:                  
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: System "Tasks" Routine
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  /*******************************************************************************
65:                    Function:
66:                      void SYS_Tasks ( void )
67:                  
68:                    Remarks:
69:                      See prototype in system/common/sys_module.h.
70:                  */
71:                  
72:                  void SYS_Tasks ( void )
73:                  {
9D0037E8  27BDFFE8   ADDIU SP, SP, -24
9D0037EC  AFBF0014   SW RA, 20(SP)
74:                      /* Maintain system services */
75:                      SYS_DEVCON_Tasks(sysObj.sysDevcon);
9D0037F0  3C02A000   LUI V0, -24576
9D0037F4  0F400E4D   JAL SYS_DEVCON_Tasks
9D0037F8  8C44084C   LW A0, 2124(V0)
76:                  
77:                      /* Maintain Device Drivers */
78:                  
79:                      /* Maintain Middleware & Other Libraries */
80:                  
81:                      /* Maintain the application's state machine. */
82:                      APP_Tasks();
9D0037FC  0F4003DE   JAL APP_Tasks
9D003800  00000000   NOP
83:                  }
9D003804  8FBF0014   LW RA, 20(SP)
9D003808  03E00008   JR RA
9D00380C  27BD0018   ADDIU SP, SP, 24
84:                  
85:                  
86:                  /*******************************************************************************
87:                   End of File
88:                   */
89:                  
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/system_interrupt.c
1:                   /*******************************************************************************
2:                    System Interrupts File
3:                   
4:                     File Name:
5:                       system_interrupt.c
6:                   
7:                     Summary:
8:                       Raw ISR definitions.
9:                   
10:                    Description:
11:                      This file contains a definitions of the raw ISRs required to support the
12:                      interrupt sub-system.
13:                  
14:                    Summary:
15:                      This file contains source code for the interrupt vector functions in the
16:                      system.
17:                  
18:                    Description:
19:                      This file contains source code for the interrupt vector functions in the
20:                      system.  It implements the system and part specific vector "stub" functions
21:                      from which the individual "Tasks" functions are called for any modules
22:                      executing interrupt-driven in the MPLAB Harmony system.
23:                  
24:                    Remarks:
25:                      This file requires access to the systemObjects global data structure that
26:                      contains the object handles to all MPLAB Harmony module objects executing
27:                      interrupt-driven in the system.  These handles are passed into the individual
28:                      module "Tasks" functions to identify the instance of the module to maintain.
29:                   *******************************************************************************/
30:                  
31:                  // DOM-IGNORE-BEGIN
32:                  /*******************************************************************************
33:                  Copyright (c) 2011-2014 released Microchip Technology Inc.  All rights reserved.
34:                  
35:                  Microchip licenses to you the right to use, modify, copy and distribute
36:                  Software only when embedded on a Microchip microcontroller or digital signal
37:                  controller that is integrated into your product or third party product
38:                  (pursuant to the sublicense terms in the accompanying license agreement).
39:                  
40:                  You should refer to the license agreement accompanying this Software for
41:                  additional information regarding your rights and obligations.
42:                  
43:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
44:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
45:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
46:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
47:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
48:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
49:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
50:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
51:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
52:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
53:                   *******************************************************************************/
54:                  // DOM-IGNORE-END
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  
62:                  #include <xc.h>
63:                  #include <sys/attribs.h>
64:                  #include "app.h"
65:                  #include "system_definitions.h"
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: System Interrupt Vector Functions
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  void __ISR(_EXTERNAL_3_VECTOR, IPL3AUTO) _IntHandlerExternalInterruptInstance0(void)
73:                  {
9D001CA4  415DE800   RDPGPR SP, SP
9D001CA8  401B7000   MFC0 K1, EPC
9D001CAC  401A6002   MFC0 K0, SRSCtl
9D001CB0  27BDFF90   ADDIU SP, SP, -112
9D001CB4  AFBB006C   SW K1, 108(SP)
9D001CB8  401B6000   MFC0 K1, Status
9D001CBC  AFBA0064   SW K0, 100(SP)
9D001CC0  AFBB0068   SW K1, 104(SP)
9D001CC4  7C1B7844   INS K1, ZERO, 1, 15
9D001CC8  377B0C00   ORI K1, K1, 3072
9D001CCC  409B6000   MTC0 K1, Status
9D001CD0  AFA30018   SW V1, 24(SP)
9D001CD4  AFA20014   SW V0, 20(SP)
9D001CD8  8FA30064   LW V1, 100(SP)
9D001CDC  3063000F   ANDI V1, V1, 15
9D001CE0  14600011   BNE V1, ZERO, 0x9D001D28
9D001CE4  00000000   NOP
9D001CE8  AFBF0054   SW RA, 84(SP)
9D001CEC  AFB90050   SW T9, 80(SP)
9D001CF0  AFB8004C   SW T8, 76(SP)
9D001CF4  AFAF0048   SW T7, 72(SP)
9D001CF8  AFAE0044   SW T6, 68(SP)
9D001CFC  AFAD0040   SW T5, 64(SP)
9D001D00  AFAC003C   SW T4, 60(SP)
9D001D04  AFAB0038   SW T3, 56(SP)
9D001D08  AFAA0034   SW T2, 52(SP)
9D001D0C  AFA90030   SW T1, 48(SP)
9D001D10  AFA8002C   SW T0, 44(SP)
9D001D14  AFA70028   SW A3, 40(SP)
9D001D18  AFA60024   SW A2, 36(SP)
9D001D1C  AFA50020   SW A1, 32(SP)
9D001D20  AFA4001C   SW A0, 28(SP)
9D001D24  AFA10010   SW AT, 16(SP)
9D001D28  00001012   MFLO V0
9D001D2C  AFA2005C   SW V0, 92(SP)
9D001D30  00001810   MFHI V1
9D001D34  AFA30058   SW V1, 88(SP)
74:                      PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_EXTERNAL_3);
75:                      APP_VSYNC_Interrupt_Handler();
9D001D48  0F400A2F   JAL APP_VSYNC_Interrupt_Handler
9D001D4C  00000000   NOP
76:                  }
9D001D50  8FA2005C   LW V0, 92(SP)
9D001D54  00400013   MTLO V0
9D001D58  8FA30058   LW V1, 88(SP)
9D001D5C  00600011   MTHI V1
9D001D60  8FA20064   LW V0, 100(SP)
9D001D64  3042000F   ANDI V0, V0, 15
9D001D68  14400013   BNE V0, ZERO, 0x9D001DB8
9D001D6C  00000000   NOP
9D001D70  8FBF0054   LW RA, 84(SP)
9D001D74  8FB90050   LW T9, 80(SP)
9D001D78  8FB8004C   LW T8, 76(SP)
9D001D7C  8FAF0048   LW T7, 72(SP)
9D001D80  8FAE0044   LW T6, 68(SP)
9D001D84  8FAD0040   LW T5, 64(SP)
9D001D88  8FAC003C   LW T4, 60(SP)
9D001D8C  8FAB0038   LW T3, 56(SP)
9D001D90  8FAA0034   LW T2, 52(SP)
9D001D94  8FA90030   LW T1, 48(SP)
9D001D98  8FA8002C   LW T0, 44(SP)
9D001D9C  8FA70028   LW A3, 40(SP)
9D001DA0  8FA60024   LW A2, 36(SP)
9D001DA4  8FA50020   LW A1, 32(SP)
9D001DA8  8FA4001C   LW A0, 28(SP)
9D001DAC  8FA30018   LW V1, 24(SP)
9D001DB0  8FA20014   LW V0, 20(SP)
9D001DB4  8FA10010   LW AT, 16(SP)
9D001DB8  41606000   DI ZERO
9D001DBC  000000C0   EHB
9D001DC0  8FBA006C   LW K0, 108(SP)
9D001DC4  8FBB0068   LW K1, 104(SP)
9D001DC8  409A7000   MTC0 K0, EPC
9D001DCC  8FBA0064   LW K0, 100(SP)
9D001DD0  27BD0070   ADDIU SP, SP, 112
9D001DD4  409A6002   MTC0 K0, SRSCtl
9D001DD8  41DDE800   WRPGPR SP, SP
9D001DDC  409B6000   MTC0 K1, Status
9D001DE0  42000018   ERET
77:                  void __ISR(_EXTERNAL_1_VECTOR, IPL3AUTO) _IntHandlerExternalInterruptInstance1(void)
78:                  {
9D001DE4  415DE800   RDPGPR SP, SP
9D001DE8  401B7000   MFC0 K1, EPC
9D001DEC  401A6002   MFC0 K0, SRSCtl
9D001DF0  27BDFF90   ADDIU SP, SP, -112
9D001DF4  AFBB006C   SW K1, 108(SP)
9D001DF8  401B6000   MFC0 K1, Status
9D001DFC  AFBA0064   SW K0, 100(SP)
9D001E00  AFBB0068   SW K1, 104(SP)
9D001E04  7C1B7844   INS K1, ZERO, 1, 15
9D001E08  377B0C00   ORI K1, K1, 3072
9D001E0C  409B6000   MTC0 K1, Status
9D001E10  AFA30018   SW V1, 24(SP)
9D001E14  AFA20014   SW V0, 20(SP)
9D001E18  8FA30064   LW V1, 100(SP)
9D001E1C  3063000F   ANDI V1, V1, 15
9D001E20  14600011   BNE V1, ZERO, 0x9D001E68
9D001E24  00000000   NOP
9D001E28  AFBF0054   SW RA, 84(SP)
9D001E2C  AFB90050   SW T9, 80(SP)
9D001E30  AFB8004C   SW T8, 76(SP)
9D001E34  AFAF0048   SW T7, 72(SP)
9D001E38  AFAE0044   SW T6, 68(SP)
9D001E3C  AFAD0040   SW T5, 64(SP)
9D001E40  AFAC003C   SW T4, 60(SP)
9D001E44  AFAB0038   SW T3, 56(SP)
9D001E48  AFAA0034   SW T2, 52(SP)
9D001E4C  AFA90030   SW T1, 48(SP)
9D001E50  AFA8002C   SW T0, 44(SP)
9D001E54  AFA70028   SW A3, 40(SP)
9D001E58  AFA60024   SW A2, 36(SP)
9D001E5C  AFA50020   SW A1, 32(SP)
9D001E60  AFA4001C   SW A0, 28(SP)
9D001E64  AFA10010   SW AT, 16(SP)
9D001E68  00001012   MFLO V0
9D001E6C  AFA2005C   SW V0, 92(SP)
9D001E70  00001810   MFHI V1
9D001E74  AFA30058   SW V1, 88(SP)
79:                      PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_EXTERNAL_1);
80:                      APP_HSYNC_Interrupt_Handler();
9D001E88  0F400AE9   JAL APP_HSYNC_Interrupt_Handler
9D001E8C  00000000   NOP
81:                  }
9D001E90  8FA2005C   LW V0, 92(SP)
9D001E94  00400013   MTLO V0
9D001E98  8FA30058   LW V1, 88(SP)
9D001E9C  00600011   MTHI V1
9D001EA0  8FA20064   LW V0, 100(SP)
9D001EA4  3042000F   ANDI V0, V0, 15
9D001EA8  14400013   BNE V0, ZERO, 0x9D001EF8
9D001EAC  00000000   NOP
9D001EB0  8FBF0054   LW RA, 84(SP)
9D001EB4  8FB90050   LW T9, 80(SP)
9D001EB8  8FB8004C   LW T8, 76(SP)
9D001EBC  8FAF0048   LW T7, 72(SP)
9D001EC0  8FAE0044   LW T6, 68(SP)
9D001EC4  8FAD0040   LW T5, 64(SP)
9D001EC8  8FAC003C   LW T4, 60(SP)
9D001ECC  8FAB0038   LW T3, 56(SP)
9D001ED0  8FAA0034   LW T2, 52(SP)
9D001ED4  8FA90030   LW T1, 48(SP)
9D001ED8  8FA8002C   LW T0, 44(SP)
9D001EDC  8FA70028   LW A3, 40(SP)
9D001EE0  8FA60024   LW A2, 36(SP)
9D001EE4  8FA50020   LW A1, 32(SP)
9D001EE8  8FA4001C   LW A0, 28(SP)
9D001EEC  8FA30018   LW V1, 24(SP)
9D001EF0  8FA20014   LW V0, 20(SP)
9D001EF4  8FA10010   LW AT, 16(SP)
9D001EF8  41606000   DI ZERO
9D001EFC  000000C0   EHB
9D001F00  8FBA006C   LW K0, 108(SP)
9D001F04  8FBB0068   LW K1, 104(SP)
9D001F08  409A7000   MTC0 K0, EPC
9D001F0C  8FBA0064   LW K0, 100(SP)
9D001F10  27BD0070   ADDIU SP, SP, 112
9D001F14  409A6002   MTC0 K0, SRSCtl
9D001F18  41DDE800   WRPGPR SP, SP
9D001F1C  409B6000   MTC0 K1, Status
9D001F20  42000018   ERET
82:                  void __ISR(_EXTERNAL_4_VECTOR, IPL3AUTO) _IntHandlerExternalInterruptInstance2(void)
83:                  {
9D003084  415DE800   RDPGPR SP, SP
9D003088  401B7000   MFC0 K1, EPC
9D00308C  401A6002   MFC0 K0, SRSCtl
9D003090  27BDFFE8   ADDIU SP, SP, -24
9D003094  AFBB0014   SW K1, 20(SP)
9D003098  401B6000   MFC0 K1, Status
9D00309C  AFBA000C   SW K0, 12(SP)
9D0030A0  AFBB0010   SW K1, 16(SP)
9D0030A4  7C1B7844   INS K1, ZERO, 1, 15
9D0030A8  377B0C00   ORI K1, K1, 3072
9D0030AC  409B6000   MTC0 K1, Status
9D0030B0  AFA30004   SW V1, 4(SP)
9D0030B4  AFA20000   SW V0, 0(SP)
84:                      PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_EXTERNAL_4);
85:                      //APP_PCLK_Interrupt_Handler();
86:                  }
9D0030C8  8FA2000C   LW V0, 12(SP)
9D0030CC  3042000F   ANDI V0, V0, 15
9D0030D0  14400003   BNE V0, ZERO, 0x9D0030E0
9D0030D4  00000000   NOP
9D0030D8  8FA30004   LW V1, 4(SP)
9D0030DC  8FA20000   LW V0, 0(SP)
9D0030E0  41606000   DI ZERO
9D0030E4  000000C0   EHB
9D0030E8  8FBA0014   LW K0, 20(SP)
9D0030EC  8FBB0010   LW K1, 16(SP)
9D0030F0  409A7000   MTC0 K0, EPC
9D0030F4  8FBA000C   LW K0, 12(SP)
9D0030F8  27BD0018   ADDIU SP, SP, 24
9D0030FC  409A6002   MTC0 K0, SRSCtl
9D003100  41DDE800   WRPGPR SP, SP
9D003104  409B6000   MTC0 K1, Status
9D003108  42000018   ERET
87:                  
88:                  void __ISR(_CORE_SOFTWARE_1_VECTOR, IPL7AUTO) _IntHandlerCoreSoftwareInterruptInstance0(void)
89:                  {
9D0022BC  415DE800   RDPGPR SP, SP
9D0022C0  401B7000   MFC0 K1, EPC
9D0022C4  401A6002   MFC0 K0, SRSCtl
9D0022C8  27BDFF90   ADDIU SP, SP, -112
9D0022CC  401B6000   MFC0 K1, Status
9D0022D0  AFBA0068   SW K0, 104(SP)
9D0022D4  AFBB006C   SW K1, 108(SP)
9D0022D8  7C1B7844   INS K1, ZERO, 1, 15
9D0022DC  377B1C00   ORI K1, K1, 7168
9D0022E0  409B6000   MTC0 K1, Status
9D0022E4  AFA30018   SW V1, 24(SP)
9D0022E8  AFA20014   SW V0, 20(SP)
9D0022EC  8FA30068   LW V1, 104(SP)
9D0022F0  3063000F   ANDI V1, V1, 15
9D0022F4  14600011   BNE V1, ZERO, 0x9D00233C
9D0022F8  00000000   NOP
9D0022FC  AFBF0054   SW RA, 84(SP)
9D002300  AFB90050   SW T9, 80(SP)
9D002304  AFB8004C   SW T8, 76(SP)
9D002308  AFAF0048   SW T7, 72(SP)
9D00230C  AFAE0044   SW T6, 68(SP)
9D002310  AFAD0040   SW T5, 64(SP)
9D002314  AFAC003C   SW T4, 60(SP)
9D002318  AFAB0038   SW T3, 56(SP)
9D00231C  AFAA0034   SW T2, 52(SP)
9D002320  AFA90030   SW T1, 48(SP)
9D002324  AFA8002C   SW T0, 44(SP)
9D002328  AFA70028   SW A3, 40(SP)
9D00232C  AFA60024   SW A2, 36(SP)
9D002330  AFA50020   SW A1, 32(SP)
9D002334  AFA4001C   SW A0, 28(SP)
9D002338  AFA10010   SW AT, 16(SP)
9D00233C  00001012   MFLO V0
9D002340  AFA2005C   SW V0, 92(SP)
9D002344  00001810   MFHI V1
9D002348  AFA30058   SW V1, 88(SP)
90:                      PLIB_INT_SourceFlagClear(INT_ID_0, INT_SOURCE_SOFTWARE_1);
91:                      APP_Line_Done_Interrupt_Handler();
9D00235C  0F400E39   JAL APP_Line_Done_Interrupt_Handler
9D002360  00000000   NOP
92:                  }
9D002364  8FA2005C   LW V0, 92(SP)
9D002368  00400013   MTLO V0
9D00236C  8FA30058   LW V1, 88(SP)
9D002370  00600011   MTHI V1
9D002374  8FA20068   LW V0, 104(SP)
9D002378  3042000F   ANDI V0, V0, 15
9D00237C  14400013   BNE V0, ZERO, 0x9D0023CC
9D002380  00000000   NOP
9D002384  8FBF0054   LW RA, 84(SP)
9D002388  8FB90050   LW T9, 80(SP)
9D00238C  8FB8004C   LW T8, 76(SP)
9D002390  8FAF0048   LW T7, 72(SP)
9D002394  8FAE0044   LW T6, 68(SP)
9D002398  8FAD0040   LW T5, 64(SP)
9D00239C  8FAC003C   LW T4, 60(SP)
9D0023A0  8FAB0038   LW T3, 56(SP)
9D0023A4  8FAA0034   LW T2, 52(SP)
9D0023A8  8FA90030   LW T1, 48(SP)
9D0023AC  8FA8002C   LW T0, 44(SP)
9D0023B0  8FA70028   LW A3, 40(SP)
9D0023B4  8FA60024   LW A2, 36(SP)
9D0023B8  8FA50020   LW A1, 32(SP)
9D0023BC  8FA4001C   LW A0, 28(SP)
9D0023C0  8FA30018   LW V1, 24(SP)
9D0023C4  8FA20014   LW V0, 20(SP)
9D0023C8  8FA10010   LW AT, 16(SP)
9D0023CC  8FBB006C   LW K1, 108(SP)
9D0023D0  8FBA0068   LW K0, 104(SP)
9D0023D4  27BD0070   ADDIU SP, SP, 112
9D0023D8  409A6002   MTC0 K0, SRSCtl
9D0023DC  41DDE800   WRPGPR SP, SP
9D0023E0  409B6000   MTC0 K1, Status
9D0023E4  42000018   ERET
93:                  
94:                  void __ISR(_UART_1_VECTOR, ipl1AUTO) _IntHandlerDrvUsartInstance0(void)
95:                  {
9D001B54  415DE800   RDPGPR SP, SP
9D001B58  401B7000   MFC0 K1, EPC
9D001B5C  401A6002   MFC0 K0, SRSCtl
9D001B60  27BDFF88   ADDIU SP, SP, -120
9D001B64  AFBB0074   SW K1, 116(SP)
9D001B68  401B6000   MFC0 K1, Status
9D001B6C  AFBA006C   SW K0, 108(SP)
9D001B70  AFBB0070   SW K1, 112(SP)
9D001B74  7C1B7844   INS K1, ZERO, 1, 15
9D001B78  377B0400   ORI K1, K1, 1024
9D001B7C  409B6000   MTC0 K1, Status
9D001B80  AFA3001C   SW V1, 28(SP)
9D001B84  AFA20018   SW V0, 24(SP)
9D001B88  8FA3006C   LW V1, 108(SP)
9D001B8C  3063000F   ANDI V1, V1, 15
9D001B90  14600012   BNE V1, ZERO, 0x9D001BDC
9D001B94  00000000   NOP
9D001B98  AFBF005C   SW RA, 92(SP)
9D001B9C  AFB90058   SW T9, 88(SP)
9D001BA0  AFB80054   SW T8, 84(SP)
9D001BA4  AFB00050   SW S0, 80(SP)
9D001BA8  AFAF004C   SW T7, 76(SP)
9D001BAC  AFAE0048   SW T6, 72(SP)
9D001BB0  AFAD0044   SW T5, 68(SP)
9D001BB4  AFAC0040   SW T4, 64(SP)
9D001BB8  AFAB003C   SW T3, 60(SP)
9D001BBC  AFAA0038   SW T2, 56(SP)
9D001BC0  AFA90034   SW T1, 52(SP)
9D001BC4  AFA80030   SW T0, 48(SP)
9D001BC8  AFA7002C   SW A3, 44(SP)
9D001BCC  AFA60028   SW A2, 40(SP)
9D001BD0  AFA50024   SW A1, 36(SP)
9D001BD4  AFA40020   SW A0, 32(SP)
9D001BD8  AFA10014   SW AT, 20(SP)
9D001BDC  00001012   MFLO V0
9D001BE0  AFA20064   SW V0, 100(SP)
9D001BE4  00001810   MFHI V1
9D001BE8  AFA30060   SW V1, 96(SP)
96:                      DRV_USART_TasksTransmit(sysObj.drvUsart0);
9D001BEC  3C10A000   LUI S0, -24576
9D001BF0  2610084C   ADDIU S0, S0, 2124
9D001BF4  0F400B13   JAL DRV_USART_TasksTransmit
9D001BF8  8E040008   LW A0, 8(S0)
97:                      DRV_USART_TasksReceive(sysObj.drvUsart0);
9D001BFC  0F400B3C   JAL DRV_USART_TasksReceive
9D001C00  8E040008   LW A0, 8(S0)
98:                      DRV_USART_TasksError(sysObj.drvUsart0);
9D001C04  0F400A8E   JAL DRV_USART_TasksError
9D001C08  8E040008   LW A0, 8(S0)
99:                  }
9D001C0C  8FA20064   LW V0, 100(SP)
9D001C10  00400013   MTLO V0
9D001C14  8FA30060   LW V1, 96(SP)
9D001C18  00600011   MTHI V1
9D001C1C  8FA2006C   LW V0, 108(SP)
9D001C20  3042000F   ANDI V0, V0, 15
9D001C24  14400014   BNE V0, ZERO, 0x9D001C78
9D001C28  00000000   NOP
9D001C2C  8FBF005C   LW RA, 92(SP)
9D001C30  8FB90058   LW T9, 88(SP)
9D001C34  8FB80054   LW T8, 84(SP)
9D001C38  8FB00050   LW S0, 80(SP)
9D001C3C  8FAF004C   LW T7, 76(SP)
9D001C40  8FAE0048   LW T6, 72(SP)
9D001C44  8FAD0044   LW T5, 68(SP)
9D001C48  8FAC0040   LW T4, 64(SP)
9D001C4C  8FAB003C   LW T3, 60(SP)
9D001C50  8FAA0038   LW T2, 56(SP)
9D001C54  8FA90034   LW T1, 52(SP)
9D001C58  8FA80030   LW T0, 48(SP)
9D001C5C  8FA7002C   LW A3, 44(SP)
9D001C60  8FA60028   LW A2, 40(SP)
9D001C64  8FA50024   LW A1, 36(SP)
9D001C68  8FA40020   LW A0, 32(SP)
9D001C6C  8FA3001C   LW V1, 28(SP)
9D001C70  8FA20018   LW V0, 24(SP)
9D001C74  8FA10014   LW AT, 20(SP)
9D001C78  41606000   DI ZERO
9D001C7C  000000C0   EHB
9D001C80  8FBA0074   LW K0, 116(SP)
9D001C84  8FBB0070   LW K1, 112(SP)
9D001C88  409A7000   MTC0 K0, EPC
9D001C8C  8FBA006C   LW K0, 108(SP)
9D001C90  27BD0078   ADDIU SP, SP, 120
9D001C94  409A6002   MTC0 K0, SRSCtl
9D001C98  41DDE800   WRPGPR SP, SP
9D001C9C  409B6000   MTC0 K1, Status
9D001CA0  42000018   ERET
100:                 
101:                 void __ISR(_DMA0_VECTOR, ipl5AUTO) _IntHandlerSysDmaCh0(void)
102:                 {          
9D001F24  415DE800   RDPGPR SP, SP
9D001F28  401B7000   MFC0 K1, EPC
9D001F2C  401A6002   MFC0 K0, SRSCtl
9D001F30  27BDFF90   ADDIU SP, SP, -112
9D001F34  AFBB006C   SW K1, 108(SP)
9D001F38  401B6000   MFC0 K1, Status
9D001F3C  AFBA0064   SW K0, 100(SP)
9D001F40  AFBB0068   SW K1, 104(SP)
9D001F44  7C1B7844   INS K1, ZERO, 1, 15
9D001F48  377B1400   ORI K1, K1, 5120
9D001F4C  409B6000   MTC0 K1, Status
9D001F50  AFA30018   SW V1, 24(SP)
9D001F54  AFA20014   SW V0, 20(SP)
9D001F58  8FA30064   LW V1, 100(SP)
9D001F5C  3063000F   ANDI V1, V1, 15
9D001F60  14600011   BNE V1, ZERO, 0x9D001FA8
9D001F64  00000000   NOP
9D001F68  AFBF0054   SW RA, 84(SP)
9D001F6C  AFB90050   SW T9, 80(SP)
9D001F70  AFB8004C   SW T8, 76(SP)
9D001F74  AFAF0048   SW T7, 72(SP)
9D001F78  AFAE0044   SW T6, 68(SP)
9D001F7C  AFAD0040   SW T5, 64(SP)
9D001F80  AFAC003C   SW T4, 60(SP)
9D001F84  AFAB0038   SW T3, 56(SP)
9D001F88  AFAA0034   SW T2, 52(SP)
9D001F8C  AFA90030   SW T1, 48(SP)
9D001F90  AFA8002C   SW T0, 44(SP)
9D001F94  AFA70028   SW A3, 40(SP)
9D001F98  AFA60024   SW A2, 36(SP)
9D001F9C  AFA50020   SW A1, 32(SP)
9D001FA0  AFA4001C   SW A0, 28(SP)
9D001FA4  AFA10010   SW AT, 16(SP)
9D001FA8  00001012   MFLO V0
9D001FAC  AFA2005C   SW V0, 92(SP)
9D001FB0  00001810   MFHI V1
9D001FB4  AFA30058   SW V1, 88(SP)
103:                     SYS_DMA_TasksISR(sysObj.sysDma, DMA_CHANNEL_0);
9D001FB8  3C02A000   LUI V0, -24576
9D001FBC  8C440850   LW A0, 2128(V0)
9D001FC0  0F400987   JAL SYS_DMA_TasksISR
9D001FC4  00002821   ADDU A1, ZERO, ZERO
104:                 }
9D001FC8  8FA2005C   LW V0, 92(SP)
9D001FCC  00400013   MTLO V0
9D001FD0  8FA30058   LW V1, 88(SP)
9D001FD4  00600011   MTHI V1
9D001FD8  8FA20064   LW V0, 100(SP)
9D001FDC  3042000F   ANDI V0, V0, 15
9D001FE0  14400013   BNE V0, ZERO, 0x9D002030
9D001FE4  00000000   NOP
9D001FE8  8FBF0054   LW RA, 84(SP)
9D001FEC  8FB90050   LW T9, 80(SP)
9D001FF0  8FB8004C   LW T8, 76(SP)
9D001FF4  8FAF0048   LW T7, 72(SP)
9D001FF8  8FAE0044   LW T6, 68(SP)
9D001FFC  8FAD0040   LW T5, 64(SP)
9D002000  8FAC003C   LW T4, 60(SP)
9D002004  8FAB0038   LW T3, 56(SP)
9D002008  8FAA0034   LW T2, 52(SP)
9D00200C  8FA90030   LW T1, 48(SP)
9D002010  8FA8002C   LW T0, 44(SP)
9D002014  8FA70028   LW A3, 40(SP)
9D002018  8FA60024   LW A2, 36(SP)
9D00201C  8FA50020   LW A1, 32(SP)
9D002020  8FA4001C   LW A0, 28(SP)
9D002024  8FA30018   LW V1, 24(SP)
9D002028  8FA20014   LW V0, 20(SP)
9D00202C  8FA10010   LW AT, 16(SP)
9D002030  41606000   DI ZERO
9D002034  000000C0   EHB
9D002038  8FBA006C   LW K0, 108(SP)
9D00203C  8FBB0068   LW K1, 104(SP)
9D002040  409A7000   MTC0 K0, EPC
9D002044  8FBA0064   LW K0, 100(SP)
9D002048  27BD0070   ADDIU SP, SP, 112
9D00204C  409A6002   MTC0 K0, SRSCtl
9D002050  41DDE800   WRPGPR SP, SP
9D002054  409B6000   MTC0 K1, Status
9D002058  42000018   ERET
105:                 
106:                 void __ISR(_I2C_2_VECTOR, ipl6AUTO) _IntHandlerDrvI2CInstance0(void)
107:                 {
9D00205C  415DE800   RDPGPR SP, SP
9D002060  401B7000   MFC0 K1, EPC
9D002064  401A6002   MFC0 K0, SRSCtl
9D002068  27BDFF90   ADDIU SP, SP, -112
9D00206C  AFBB006C   SW K1, 108(SP)
9D002070  401B6000   MFC0 K1, Status
9D002074  AFBA0064   SW K0, 100(SP)
9D002078  AFBB0068   SW K1, 104(SP)
9D00207C  7C1B7844   INS K1, ZERO, 1, 15
9D002080  377B1800   ORI K1, K1, 6144
9D002084  409B6000   MTC0 K1, Status
9D002088  AFA30018   SW V1, 24(SP)
9D00208C  AFA20014   SW V0, 20(SP)
9D002090  8FA30064   LW V1, 100(SP)
9D002094  3063000F   ANDI V1, V1, 15
9D002098  14600011   BNE V1, ZERO, 0x9D0020E0
9D00209C  00000000   NOP
9D0020A0  AFBF0054   SW RA, 84(SP)
9D0020A4  AFB90050   SW T9, 80(SP)
9D0020A8  AFB8004C   SW T8, 76(SP)
9D0020AC  AFAF0048   SW T7, 72(SP)
9D0020B0  AFAE0044   SW T6, 68(SP)
9D0020B4  AFAD0040   SW T5, 64(SP)
9D0020B8  AFAC003C   SW T4, 60(SP)
9D0020BC  AFAB0038   SW T3, 56(SP)
9D0020C0  AFAA0034   SW T2, 52(SP)
9D0020C4  AFA90030   SW T1, 48(SP)
9D0020C8  AFA8002C   SW T0, 44(SP)
9D0020CC  AFA70028   SW A3, 40(SP)
9D0020D0  AFA60024   SW A2, 36(SP)
9D0020D4  AFA50020   SW A1, 32(SP)
9D0020D8  AFA4001C   SW A0, 28(SP)
9D0020DC  AFA10010   SW AT, 16(SP)
9D0020E0  00001012   MFLO V0
9D0020E4  AFA2005C   SW V0, 92(SP)
9D0020E8  00001810   MFHI V1
9D0020EC  AFA30058   SW V1, 88(SP)
108:                     DRV_I2C_Tasks(sysObj.drvI2C0);
9D0020F0  3C02A000   LUI V0, -24576
9D0020F4  0F400000   JAL DRV_I2C_Tasks
9D0020F8  8C440858   LW A0, 2136(V0)
109:                  
110:                 }
9D0020FC  8FA2005C   LW V0, 92(SP)
9D002100  00400013   MTLO V0
9D002104  8FA30058   LW V1, 88(SP)
9D002108  00600011   MTHI V1
9D00210C  8FA20064   LW V0, 100(SP)
9D002110  3042000F   ANDI V0, V0, 15
9D002114  14400013   BNE V0, ZERO, 0x9D002164
9D002118  00000000   NOP
9D00211C  8FBF0054   LW RA, 84(SP)
9D002120  8FB90050   LW T9, 80(SP)
9D002124  8FB8004C   LW T8, 76(SP)
9D002128  8FAF0048   LW T7, 72(SP)
9D00212C  8FAE0044   LW T6, 68(SP)
9D002130  8FAD0040   LW T5, 64(SP)
9D002134  8FAC003C   LW T4, 60(SP)
9D002138  8FAB0038   LW T3, 56(SP)
9D00213C  8FAA0034   LW T2, 52(SP)
9D002140  8FA90030   LW T1, 48(SP)
9D002144  8FA8002C   LW T0, 44(SP)
9D002148  8FA70028   LW A3, 40(SP)
9D00214C  8FA60024   LW A2, 36(SP)
9D002150  8FA50020   LW A1, 32(SP)
9D002154  8FA4001C   LW A0, 28(SP)
9D002158  8FA30018   LW V1, 24(SP)
9D00215C  8FA20014   LW V0, 20(SP)
9D002160  8FA10010   LW AT, 16(SP)
9D002164  41606000   DI ZERO
9D002168  000000C0   EHB
9D00216C  8FBA006C   LW K0, 108(SP)
9D002170  8FBB0068   LW K1, 104(SP)
9D002174  409A7000   MTC0 K0, EPC
9D002178  8FBA0064   LW K0, 100(SP)
9D00217C  27BD0070   ADDIU SP, SP, 112
9D002180  409A6002   MTC0 K0, SRSCtl
9D002184  41DDE800   WRPGPR SP, SP
9D002188  409B6000   MTC0 K1, Status
9D00218C  42000018   ERET
111:                          
112:                 /*******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/system_init.c
1:                   /*******************************************************************************
2:                     System Initialization File
3:                   
4:                     File Name:
5:                       system_init.c
6:                   
7:                     Summary:
8:                       This file contains source code necessary to initialize the system.
9:                   
10:                    Description:
11:                      This file contains source code necessary to initialize the system.  It
12:                      implements the "SYS_Initialize" function, defines the configuration bits, 
13:                      and allocates any necessary global system resources, such as the 
14:                      sysObj structure that contains the object handles to all the MPLAB Harmony 
15:                      module objects in the system.
16:                   *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "system_config.h"
50:                  #include "system_definitions.h"
51:                  
52:                  
53:                  // ****************************************************************************
54:                  // ****************************************************************************
55:                  // Section: Configuration Bits
56:                  // ****************************************************************************
57:                  // ****************************************************************************
58:                  // <editor-fold defaultstate="collapsed" desc="Configuration Bits">
59:                  
60:                  /*** DEVCFG0 ***/
61:                  #pragma config DEBUG =      OFF
62:                  #pragma config JTAGEN =     OFF
63:                  #pragma config ICESEL =     ICS_PGx1
64:                  #pragma config PWP =        OFF
65:                  #pragma config BWP =        OFF
66:                  #pragma config CP =         OFF
67:                  
68:                  /*** DEVCFG1 ***/
69:                  #pragma config FNOSC =      FRCPLL
70:                  #pragma config FSOSCEN =    OFF
71:                  #pragma config IESO =       OFF
72:                  #pragma config POSCMOD =    OFF
73:                  #pragma config OSCIOFNC =   OFF
74:                  #pragma config FPBDIV =     DIV_1
75:                  #pragma config FCKSM =      CSDCMD
76:                  #pragma config WDTPS =      PS1048576
77:                  #pragma config FWDTEN =     OFF
78:                  #pragma config WINDIS =     OFF
79:                  #pragma config FWDTWINSZ =  WINSZ_50
80:                  
81:                  /*** DEVCFG2 ***/
82:                  #pragma config FPLLIDIV =   DIV_2
83:                  #pragma config FPLLMUL =    MUL_24
84:                  #pragma config FPLLODIV =   DIV_2
85:                  
86:                  /*** DEVCFG3 ***/
87:                  #pragma config USERID =     0xffff
88:                  #pragma config PMDL1WAY =   ON
89:                  #pragma config IOL1WAY =    ON
90:                  // </editor-fold>
91:                  
92:                  // *****************************************************************************
93:                  // *****************************************************************************
94:                  // Section: Driver Initialization Data
95:                  // *****************************************************************************
96:                  // *****************************************************************************
97:                  // <editor-fold defaultstate="collapsed" desc="DRV_I2C Initialization Data">
98:                  // *****************************************************************************
99:                  /* I2C Driver Initialization Data
100:                 */
101:                 
102:                 const DRV_I2C_INIT drvI2C0InitData =
103:                 {
104:                     .i2cId = DRV_I2C_PERIPHERAL_ID_IDX0,
105:                     .i2cMode = DRV_I2C_OPERATION_MODE_IDX0,
106:                     .baudRate = DRV_I2C_BAUD_RATE_IDX0,
107:                     .busspeed = DRV_I2C_SLEW_RATE_CONTROL_IDX0,
108:                     .buslevel = DRV_I2C_SMBus_SPECIFICATION_IDX0,
109:                     .mstrInterruptSource = DRV_I2C_MASTER_INT_SRC_IDX0,
110:                     .errInterruptSource = DRV_I2C_ERR_MX_INT_SRC_IDX0,
111:                 };
112:                 
113:                 
114:                 
115:                 
116:                 // </editor-fold>
117:                 // <editor-fold defaultstate="collapsed" desc="DRV_USART Initialization Data">
118:                 
119:                 const DRV_USART_INIT drvUsart0InitData =
120:                 {
121:                     .moduleInit.value = DRV_USART_POWER_STATE_IDX0,
122:                     .usartID = DRV_USART_PERIPHERAL_ID_IDX0, 
123:                     .mode = DRV_USART_OPER_MODE_IDX0,
124:                     .flags = DRV_USART_INIT_FLAGS_IDX0,
125:                     .brgClock = DRV_USART_BRG_CLOCK_IDX0,
126:                     .lineControl = DRV_USART_LINE_CNTRL_IDX0,
127:                     .baud = DRV_USART_BAUD_RATE_IDX0,
128:                     .handshake = DRV_USART_HANDSHAKE_MODE_IDX0,
129:                     .interruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,
130:                     .interruptReceive = DRV_USART_RCV_INT_SRC_IDX0,
131:                     .interruptError = DRV_USART_ERR_INT_SRC_IDX0,
132:                     .dmaChannelTransmit = DMA_CHANNEL_NONE,
133:                     .dmaInterruptTransmit = DRV_USART_XMIT_INT_SRC_IDX0,    
134:                     .dmaChannelReceive = DMA_CHANNEL_NONE,
135:                     .dmaInterruptReceive = DRV_USART_RCV_INT_SRC_IDX0,    
136:                 };
137:                 // </editor-fold>
138:                 
139:                 // *****************************************************************************
140:                 // *****************************************************************************
141:                 // Section: System Data
142:                 // *****************************************************************************
143:                 // *****************************************************************************
144:                 
145:                 /* Structure to hold the object handles for the modules in the system. */
146:                 SYSTEM_OBJECTS sysObj;
147:                 
148:                 // *****************************************************************************
149:                 // *****************************************************************************
150:                 // Section: Module Initialization Data
151:                 // *****************************************************************************
152:                 // *****************************************************************************
153:                 //<editor-fold defaultstate="collapsed" desc="SYS_DEVCON Initialization Data">
154:                 /*******************************************************************************
155:                   Device Control System Service Initialization Data
156:                 */
157:                 
158:                 const SYS_DEVCON_INIT sysDevconInit =
159:                 {
160:                     .moduleInit = {0},
161:                 };
162:                 
163:                 // </editor-fold>
164:                 
165:                 //<editor-fold defaultstate="collapsed" desc="SYS_DMA Initialization Data">
166:                 /*** System DMA Initialization Data ***/
167:                 
168:                 const SYS_DMA_INIT sysDmaInit =
169:                 {
170:                 	.sidl = SYS_DMA_SIDL_DISABLE,
171:                 
172:                 };
173:                 // </editor-fold>
174:                 
175:                 // *****************************************************************************
176:                 // *****************************************************************************
177:                 // Section: Library/Stack Initialization Data
178:                 // *****************************************************************************
179:                 // *****************************************************************************
180:                 
181:                 // *****************************************************************************
182:                 // *****************************************************************************
183:                 // Section: Static Initialization Functions
184:                 // *****************************************************************************
185:                 // *****************************************************************************
186:                 
187:                 
188:                 // *****************************************************************************
189:                 // *****************************************************************************
190:                 // Section: System Initialization
191:                 // *****************************************************************************
192:                 // *****************************************************************************
193:                 
194:                 /*******************************************************************************
195:                   Function:
196:                     void SYS_Initialize ( void *data )
197:                 
198:                   Summary:
199:                     Initializes the board, services, drivers, application and other modules.
200:                 
201:                   Remarks:
202:                     See prototype in system/common/sys_module.h.
203:                  */
204:                 
205:                 void SYS_Initialize ( void* data )
206:                 {
9D000D14  27BDFFD8   ADDIU SP, SP, -40
9D000D18  AFBF0024   SW RA, 36(SP)
9D000D1C  AFB30020   SW S3, 32(SP)
9D000D20  AFB2001C   SW S2, 28(SP)
9D000D24  AFB10018   SW S1, 24(SP)
9D000D28  AFB00014   SW S0, 20(SP)
207:                     /* Core Processor Initialization */
208:                     SYS_CLK_Initialize( NULL );
9D000D2C  0F400BDB   JAL SYS_CLK_Initialize
9D000D30  00002021   ADDU A0, ZERO, ZERO
209:                     sysObj.sysDevcon = SYS_DEVCON_Initialize(SYS_DEVCON_INDEX_0, (SYS_MODULE_INIT*)&sysDevconInit);
9D000D34  00002021   ADDU A0, ZERO, ZERO
9D000D38  3C059D00   LUI A1, -25344
9D000D3C  0F400E2F   JAL SYS_DEVCON_Initialize
9D000D40  24A52ED4   ADDIU A1, A1, 11988
9D000D44  3C11A000   LUI S1, -24576
210:                     SYS_DEVCON_PerformanceConfig(SYS_CLK_SystemFrequencyGet());
9D000D48  0F400E43   JAL SYS_CLK_SystemFrequencyGet
9D000D4C  AE22084C   SW V0, 2124(S1)
9D000D50  0F400CB2   JAL SYS_DEVCON_PerformanceConfig
9D000D54  00402021   ADDU A0, V0, ZERO
211:                     SYS_PORTS_Initialize();
9D000D58  0F400944   JAL SYS_PORTS_Initialize
9D000D5C  2631084C   ADDIU S1, S1, 2124
212:                 
213:                     /* Initialize Drivers */
214:                     sysObj.drvI2C0 = DRV_I2C_Initialize(DRV_I2C_INDEX_0, (SYS_MODULE_INIT *)&drvI2C0InitData);
9D000D60  00002021   ADDU A0, ZERO, ZERO
9D000D64  3C059D00   LUI A1, -25344
9D000D68  0F400272   JAL DRV_I2C_Initialize
9D000D6C  24A52F20   ADDIU A1, A1, 12064
9D000D70  AE22000C   SW V0, 12(S1)
215:                     SYS_INT_VectorPrioritySet(INT_VECTOR_I2C2, INT_PRIORITY_LEVEL6);
216:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_I2C2, INT_SUBPRIORITY_LEVEL1);
217:                 
218:                     /* Initialize PMP0 */
219:                     DRV_PMP0_Initialize();
9D000DC4  0F400E1D   JAL DRV_PMP0_Initialize
9D000DC8  00000000   NOP
220:                     DRV_PMP0_ModeConfig();
9D000DCC  0F400D7D   JAL DRV_PMP0_ModeConfig
9D000DD0  00000000   NOP
221:                 
222:                     /* Initialize DMA */
223:                     sysObj.sysDma = SYS_DMA_Initialize((SYS_MODULE_INIT *)&sysDmaInit);
9D000DD4  3C049D00   LUI A0, -25344
9D000DD8  0F400C97   JAL SYS_DMA_Initialize
9D000DDC  24842ED0   ADDIU A0, A0, 11984
9D000DE0  AE220004   SW V0, 4(S1)
224:                     SYS_INT_VectorPrioritySet(INT_VECTOR_DMA0, INT_PRIORITY_LEVEL5);
225:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_DMA0, INT_SUBPRIORITY_LEVEL0);
226:                     SYS_INT_SourceEnable(INT_SOURCE_DMA_0);
227:                 
228:                 
229:                     sysObj.drvUsart0 = DRV_USART_Initialize(DRV_USART_INDEX_0, (SYS_MODULE_INIT *)&drvUsart0InitData);
9D000E28  00002021   ADDU A0, ZERO, ZERO
9D000E2C  3C059D00   LUI A1, -25344
9D000E30  0F4005BB   JAL DRV_USART_Initialize
9D000E34  24A52ED8   ADDIU A1, A1, 11992
9D000E38  AE220008   SW V0, 8(S1)
230:                     SYS_INT_VectorPrioritySet(INT_VECTOR_UART1, INT_PRIORITY_LEVEL1);
231:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_UART1, INT_SUBPRIORITY_LEVEL0);
232:                 
233:                     /****************************************************************************************************************/
234:                     /* Initialize System Services */
235:                     
236:                     /*** Interrupt Service Initialization Code ***/
237:                     SYS_INT_Initialize();
9D000E68  0F400E34   JAL SYS_INT_Initialize
9D000E6C  00000000   NOP
238:                 
239:                     /* VSYNC Interrupt */
240:                     /*Setup the INT_SOURCE_EXTERNAL_3 and Enable it*/
241:                     SYS_INT_VectorPrioritySet(INT_VECTOR_INT3, INT_PRIORITY_LEVEL3);
242:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_INT3, INT_SUBPRIORITY_LEVEL3);
243:                     SYS_INT_ExternalInterruptTriggerSet(INT_EXTERNAL_INT_SOURCE3,INT_EDGE_TRIGGER_RISING);
9D000EB8  24040008   ADDIU A0, ZERO, 8
9D000EBC  0F400DF0   JAL SYS_INT_ExternalInterruptTriggerSet
9D000EC0  24050001   ADDIU A1, ZERO, 1
244:                     //SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_3); // Enabled as needed
245:                 
246:                     /* HREF Interrupt */
247:                     /*Setup the INT_SOURCE_EXTERNAL_1 and Enable it*/
248:                     SYS_INT_VectorPrioritySet(INT_VECTOR_INT1, INT_PRIORITY_LEVEL3);
249:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_INT1, INT_SUBPRIORITY_LEVEL2);
250:                     SYS_INT_ExternalInterruptTriggerSet(INT_EXTERNAL_INT_SOURCE1,INT_EDGE_TRIGGER_FALLING);
9D000EF8  24040002   ADDIU A0, ZERO, 2
9D000EFC  0F400DF0   JAL SYS_INT_ExternalInterruptTriggerSet
9D000F00  00002821   ADDU A1, ZERO, ZERO
251:                     //SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_1); // Enabled as needed
252:                 
253:                     
254:                     /* PCLK Interrupt */
255:                     /*Setup the INT_SOURCE_EXTERNAL_4 and Enable it*/
256:                     SYS_INT_VectorPrioritySet(INT_VECTOR_INT4, INT_PRIORITY_LEVEL3);
257:                     SYS_INT_VectorSubprioritySet(INT_VECTOR_INT4, INT_SUBPRIORITY_LEVEL1);
258:                     SYS_INT_ExternalInterruptTriggerSet(INT_EXTERNAL_INT_SOURCE4,INT_EDGE_TRIGGER_RISING);
9D000F38  24040010   ADDIU A0, ZERO, 16
9D000F3C  0F400DF0   JAL SYS_INT_ExternalInterruptTriggerSet
9D000F40  24050001   ADDIU A1, ZERO, 1
259:                     //SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_4); // Enabled as needed
260:                 
261:                     /****************************************************************************************************************/
262:                     
263:                     /* Initialize Middleware */
264:                 
265:                     /* Enable Global Interrupts */
266:                     SYS_INT_Enable();
267:                 
268:                     /* Initialize the Application */
269:                     APP_Initialize();
9D000F54  0F400E40   JAL APP_Initialize
9D000F58  00000000   NOP
270:                 }
9D000F5C  8FBF0024   LW RA, 36(SP)
9D000F60  8FB30020   LW S3, 32(SP)
9D000F64  8FB2001C   LW S2, 28(SP)
9D000F68  8FB10018   LW S1, 24(SP)
9D000F6C  8FB00014   LW S0, 20(SP)
9D000F70  03E00008   JR RA
9D000F74  27BD0028   ADDIU SP, SP, 40
271:                 
272:                 
273:                 /*******************************************************************************
274:                  End of File
275:                 */
276:                 
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/system_exceptions.c
1:                   /*******************************************************************************
2:                     MPLAB Harmony Exceptions Source File
3:                   
4:                     File Name:
5:                       system_exceptions.c
6:                   
7:                     Summary:
8:                       This file contains a function which overrides the deafult _weak_ exception 
9:                       handler provided by the XC32 compiler.
10:                  
11:                    Description:
12:                      This file redefines the default _weak_  exception handler with a more debug
13:                      friendly one. If an unexpected exception occurs the code will stop in a
14:                      while(1) loop.  The debugger can be halted and two variables _excep_code and
15:                      _except_addr can be examined to determine the cause and address where the
16:                      exception occured.
17:                   *******************************************************************************/
18:                  
19:                  // DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) 2013-2015 released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  // DOM-IGNORE-END
43:                  
44:                  
45:                  #include <xc.h>                 /* Defines special funciton registers, CP0 regs  */
46:                  #include "system_config.h"
47:                  #include "system_definitions.h"
48:                  #include "system/debug/sys_debug.h"
49:                  
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data Definitions
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /*******************************************************************************
58:                    Exception Reason Data
59:                    
60:                    <editor-fold defaultstate="expanded" desc="Exception Reason Data">
61:                    
62:                    Remarks:
63:                      These global static items are used instead of local variables in the 
64:                      _general_exception_handler function because the stack may not be available
65:                      if an exception has occured.
66:                  */
67:                  
68:                  /* Code identifying the cause of the exception (CP0 Cause register). */
69:                  static unsigned int _excep_code;
70:                  
71:                  /* Address of instruction that caused the exception. */
72:                  static unsigned int _excep_addr;
73:                  
74:                  /* Pointer to the string describing the cause of the exception. */
75:                  static char *_cause_str;
76:                  
77:                  /* Array identifying the cause (indexed by _exception_code). */
78:                  static char *cause[] = 
79:                  {
80:                      "Interrupt",
81:                      "Undefined",
82:                      "Undefined",
83:                      "Undefined",
84:                      "Load/fetch address error",
85:                      "Store address error",
86:                      "Instruction bus error",
87:                      "Data bus error",
88:                      "Syscall",
89:                      "Breakpoint",
90:                      "Reserved instruction",
91:                      "Coprocessor unusable",
92:                      "Arithmetic overflow",
93:                      "Trap",
94:                      "Reserved",
95:                      "Reserved",
96:                      "Reserved",
97:                      "Reserved",
98:                      "Reserved"
99:                  };
100:                 
101:                 // </editor-fold>
102:                 
103:                 
104:                 // *****************************************************************************
105:                 // *****************************************************************************
106:                 // Section: Exception Handling
107:                 // *****************************************************************************
108:                 // *****************************************************************************
109:                 
110:                 /*******************************************************************************
111:                   Function:
112:                     void _general_exception_handler ( void )
113:                 
114:                   Summary:
115:                     Overrides the XC32 _weak_ _generic_exception_handler.
116:                     
117:                   Description:
118:                     This function overrides the XC32 default _weak_ _generic_exception_handler.
119:                 
120:                   Remarks:
121:                     Refer to the XC32 User's Guide for additional information.
122:                  */
123:                 
124:                 void _general_exception_handler ( void )
125:                 {
9D003638  27BDFFF8   ADDIU SP, SP, -8
9D00363C  AFBF0004   SW RA, 4(SP)
126:                     /* Mask off Mask of the ExcCode Field from the Cause Register
127:                     Refer to the MIPs Software User's manual */
128:                     _excep_code = (_CP0_GET_CAUSE() & 0x0000007C) >> 2;
9D003640  40026800   MFC0 V0, Cause
9D003644  7C422080   EXT V0, V0, 2, 5
9D003648  AF828038   SW V0, -32712(GP)
129:                     _excep_addr = _CP0_GET_EPC();
9D00364C  40027000   MFC0 V0, EPC
9D003650  AF828034   SW V0, -32716(GP)
130:                     _cause_str  = cause[_excep_code];
9D003654  8F838038   LW V1, -32712(GP)
9D003658  00031880   SLL V1, V1, 2
9D00365C  3C029D00   LUI V0, -25344
9D003660  244224C4   ADDIU V0, V0, 9412
9D003664  00621021   ADDU V0, V1, V0
9D003668  8C420000   LW V0, 0(V0)
9D00366C  AF828030   SW V0, -32720(GP)
131:                 
132:                     SYS_DEBUG_PRINT(SYS_ERROR_ERROR, "\nGeneral Exception %s (cause=%d, addr=%x).\n", 
133:                                     _cause_str, _excep_code, _excep_addr);
134:                 
135:                     while (1)
136:                     {
137:                         SYS_DEBUG_BreakPoint();
9D003670  7000003F   SDBBP 0
9D003674  0B400D9C   J 0x9D003670
9D003678  00000000   NOP
138:                     }
139:                 }
140:                 
141:                 /*******************************************************************************
142:                  End of File
143:                 */
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/framework/system/ports/src/sys_ports_static.c
1:                   /*******************************************************************************
2:                     SYS PORTS Static Functions for PORTS System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_ports_static.c
9:                   
10:                    Summary:
11:                      SYS PORTS static function implementations for the Ports System Service.
12:                  
13:                    Description:
14:                      The Ports System Service provides a simple interface to manage the ports
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Ports System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system ports configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                  
24:                  *******************************************************************************/
25:                  
26:                  //DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                  *******************************************************************************/
49:                  //DOM-IGNORE-END
50:                  
51:                  #include "system_config.h"
52:                  #include "system/ports/sys_ports.h"
53:                  #include "peripheral/devcon/plib_devcon.h"
54:                  #include "peripheral/ports/plib_ports.h"
55:                  #include "peripheral/int/plib_int.h"
56:                  
57:                  /******************************************************************************
58:                    Function:
59:                      SYS_PORTS_Initialize(void)
60:                  
61:                    Summary:
62:                      Initializes Ports System Service
63:                  
64:                    Description:
65:                      This function initializes different port pins/channels to the desired state.
66:                      It also remaps the pins to the desired specific function.
67:                  
68:                    Remarks:
69:                      None.
70:                  */
71:                  void SYS_PORTS_Initialize(void)
72:                  {
73:                      /* PORT A Initialization */
74:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ODC);
75:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_LAT);
76:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_A,  SYS_PORT_A_TRIS ^ 0xFFFF);
77:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_A);
78:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
79:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNEN);
80:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPU);
81:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_A, SYS_PORT_A_CNPD);
82:                      
83:                      /* PORT B Initialization */
84:                      PLIB_PORTS_OpenDrainEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ODC);
85:                      PLIB_PORTS_Write( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_LAT);
86:                      PLIB_PORTS_DirectionOutputSet( PORTS_ID_0, PORT_CHANNEL_B,  SYS_PORT_B_TRIS ^ 0xFFFF);
87:                      PLIB_PORTS_ChangeNoticePerPortTurnOn(PORTS_ID_0, PORT_CHANNEL_B);
88:                      PLIB_PORTS_ChannelModeSelect(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_ANSEL ^ 0xFFFF, PORTS_PIN_MODE_DIGITAL);
89:                      PLIB_PORTS_ChannelChangeNoticeEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNEN);
90:                      PLIB_PORTS_ChannelChangeNoticePullUpEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPU);
91:                      PLIB_PORTS_ChannelChangeNoticePullDownEnable(PORTS_ID_0, PORT_CHANNEL_B, SYS_PORT_B_CNPD);
92:                  
93:                  
94:                      /* PPS Input Remapping */
95:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_U1RX, INPUT_PIN_RPA2 );
96:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_INT4, INPUT_PIN_RPB15 );
97:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_INT1, INPUT_PIN_RPA3 );
98:                      PLIB_PORTS_RemapInput(PORTS_ID_0, INPUT_FUNC_INT3, INPUT_PIN_RPA1 );
99:                  
100:                     /* PPS Output Remapping */
101:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_U1TX, OUTPUT_PIN_RPB4 );
102:                     PLIB_PORTS_RemapOutput(PORTS_ID_0, OUTPUT_FUNC_REFCLKO, OUTPUT_PIN_RPB13 );
103:                 
104:                     
105:                 }
106:                 
107:                 /******************************************************************************
108:                   Function:
109:                     PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
110:                 
111:                   Summary:
112:                     Reads the data from the I/O port.
113:                 
114:                   Description:
115:                     This function reads the data from the I/O port.
116:                 
117:                   Remarks:
118:                     None.
119:                 */
120:                 
121:                 PORTS_DATA_TYPE SYS_PORTS_Read( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
122:                 {
123:                     return PLIB_PORTS_Read( index, channel );
124:                 }
00000020  00000000   NOP
125:                 
126:                 
127:                 /******************************************************************************
128:                   Function:
129:                     void SYS_PORTS_Write( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
130:                                       		PORTS_DATA_TYPE value )
131:                 
132:                   Summary:
133:                     Writes the data from the I/O port.
134:                 
135:                   Description:
136:                     This function writes the data to the I/O port.
137:                 
138:                   Remarks:
139:                     None.
140:                 */
141:                 
142:                 void SYS_PORTS_Write( PORTS_MODULE_ID index,
143:                                       PORTS_CHANNEL channel,
144:                                       PORTS_DATA_TYPE value )
145:                 {
146:                     PLIB_PORTS_Write( index, channel, value );
147:                 }
148:                 
149:                 
150:                 /******************************************************************************
151:                   Function:
152:                     void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
153:                 	                         PORTS_DATA_TYPE value,
154:                                          PORTS_DATA_MASK mask )
155:                 
156:                   Summary:
157:                     Sets the selected digital port/latch based on the mask.
158:                 
159:                   Description:
160:                     This function sets the selected digital port/latch relative to the mask.
161:                 
162:                   Remarks:
163:                     None.
164:                 */
165:                 
166:                 void SYS_PORTS_Set( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
167:                                     PORTS_DATA_TYPE value,
168:                                     PORTS_DATA_MASK mask )
169:                 {
170:                     PLIB_PORTS_Set( index, channel, value, mask );
171:                 }
172:                 
173:                 
174:                 /******************************************************************************
175:                   Function:
176:                     void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
177:                                            PORTS_DATA_MASK clearMask )
178:                 
179:                   Summary:
180:                     Clears the selected digital port.
181:                 
182:                   Description:
183:                     This function clears the selected digital port.
184:                 
185:                   Remarks:
186:                     None.
187:                 */
188:                 
189:                 void SYS_PORTS_Clear ( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
190:                                            PORTS_DATA_MASK clearMask )
191:                 {
192:                     PLIB_PORTS_Clear ( index, channel, clearMask );
193:                 }
194:                 
195:                 
196:                 /******************************************************************************
197:                   Function:
198:                     void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
199:                 								SYS_PORTS_PIN_DIRECTION pinDir,
200:                 								PORTS_CHANNEL channel,
201:                 								PORTS_DATA_MASK mask )
202:                   Summary:
203:                     Enables the direction for the selected port.
204:                 
205:                   Description:
206:                     This function enables the direction for the selected port.
207:                 
208:                   Remarks:
209:                     None.
210:                 */
211:                 
212:                 void SYS_PORTS_DirectionSelect( PORTS_MODULE_ID index,
213:                                              SYS_PORTS_PIN_DIRECTION pinDir,
214:                                              PORTS_CHANNEL channel,
215:                                              PORTS_DATA_MASK mask )
216:                 {
217:                     if (pinDir == SYS_PORTS_DIRECTION_INPUT)
00000000  00000000   NOP
218:                     {
219:                         PLIB_PORTS_DirectionInputSet(index, channel, mask);
220:                     }
221:                     else
222:                     {
223:                         PLIB_PORTS_DirectionOutputSet(index, channel, mask);
224:                     }
225:                 }
226:                 
227:                 
228:                 /******************************************************************************
229:                   Function:
230:                     PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index,
231:                                                             PORTS_CHANNEL channel )
232:                 
233:                   Summary:
234:                     Reads the port direction for the selected port.
235:                 
236:                   Description:
237:                     This function reads the port direction for the selected port.
238:                 
239:                   Remarks:
240:                     None.
241:                 */
242:                 
243:                 PORTS_DATA_MASK SYS_PORTS_DirectionGet( PORTS_MODULE_ID index, PORTS_CHANNEL channel )
244:                 {
245:                     return PLIB_PORTS_DirectionGet( index, channel );
246:                 }
00000020  00000000   NOP
247:                 
248:                 
249:                 /******************************************************************************
250:                   Function:
251:                     void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
252:                                            PORTS_DATA_MASK toggleMask )
253:                 
254:                   Summary:
255:                     Toggles the selected digital port pins.
256:                 
257:                   Description:
258:                     This function toggles the selected digital port pins.
259:                 
260:                   Remarks:
261:                     None.
262:                 */
263:                 
264:                 void SYS_PORTS_Toggle( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
265:                                        PORTS_DATA_MASK toggleMask )
266:                 {
267:                     PLIB_PORTS_Toggle( index, channel, toggleMask );
268:                 }
269:                 
270:                 
271:                 /******************************************************************************
272:                   Function:
273:                     void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
274:                                                      PORTS_DATA_MASK mask )
275:                 
276:                   Summary:
277:                     Enables the open drain functionality for the selected port.
278:                 
279:                   Description:
280:                     This function enables the open drain functionality for the selected port.
281:                 
282:                   Remarks:
283:                     None.
284:                 */
285:                 
286:                 void SYS_PORTS_OpenDrainEnable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
287:                                                 PORTS_DATA_MASK mask )
288:                 {
289:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
290:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
291:                     {
292:                         PLIB_PORTS_OpenDrainEnable( index, channel, mask );
293:                     }
294:                 #endif
295:                 }
296:                 
297:                 
298:                 /******************************************************************************
299:                   Function:
300:                     void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
301:                                                      PORTS_DATA_MASK mask )
302:                 
303:                   Summary:
304:                     Disables the open drain functionality for the selected port.
305:                 
306:                   Description:
307:                     This function disables the open drain functionality for the selected port.
308:                 
309:                   Remarks:
310:                     None.
311:                 */
312:                 
313:                 void SYS_PORTS_OpenDrainDisable( PORTS_MODULE_ID index, PORTS_CHANNEL channel,
314:                                                  PORTS_DATA_MASK mask )
315:                 {
316:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
317:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
318:                     {
319:                         PLIB_PORTS_OpenDrainDisable( index, channel, mask );
320:                     }
321:                 #endif
322:                 }
323:                 
324:                 
325:                 // *****************************************************************************
326:                 // *****************************************************************************
327:                 // Section: SYS Change Notification Pins Routines
328:                 // *****************************************************************************
329:                 // *****************************************************************************
330:                 
331:                 /******************************************************************************
332:                   Function:
333:                     void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
334:                 
335:                   Summary:
336:                     Globally enables the change notification.
337:                 
338:                   Description:
339:                     This function globally enables the change notification.
340:                 
341:                   Remarks:
342:                     None.
343:                 */
344:                 
345:                 void SYS_PORTS_ChangeNotificationGlobalEnable( PORTS_MODULE_ID index )
346:                 {
347:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
348:                     if(PLIB_PORTS_ExistsChangeNotice(index))
349:                     {
350:                         PLIB_PORTS_ChangeNoticeEnable( index );
351:                     }
352:                 #endif
353:                 }
354:                 
355:                 /******************************************************************************
356:                   Function:
357:                     void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
358:                 
359:                   Summary:
360:                     Globally disables the change notification.
361:                 
362:                   Description:
363:                     This function globally disables the change notification.
364:                 
365:                   Remarks:
366:                     None.
367:                 */
368:                 
369:                 void SYS_PORTS_ChangeNotificationGlobalDisable( PORTS_MODULE_ID index )
370:                 {
371:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
372:                     if(PLIB_PORTS_ExistsChangeNotice(index))
373:                     {
374:                         PLIB_PORTS_ChangeNoticeDisable( index );
375:                     }
376:                 #endif
377:                 }
378:                 
379:                 /******************************************************************************
380:                   Function:
381:                     void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
382:                 
383:                   Summary:
384:                     Globally disables the change notification for the selected port.
385:                 
386:                   Description:
387:                     This function globally disables the change notification for the selected port.
388:                 
389:                   Remarks:
390:                     None.
391:                 */
392:                 
393:                 void SYS_PORTS_GlobalChangeNotificationDisable( PORTS_MODULE_ID index )
394:                 {
395:                 #if defined(PLIB_PORTS_ExistsChangeNotice)
396:                     if(PLIB_PORTS_ExistsChangeNotice(index))
397:                     {
398:                         PLIB_PORTS_ChangeNoticeDisable( index );
399:                     }
400:                 #endif
401:                 }
402:                 
403:                 
404:                 /******************************************************************************
405:                   Function:
406:                     void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
407:                                                              PORTS_CHANGE_NOTICE_PIN pinNum,
408:                                                              SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
409:                 
410:                   Summary:
411:                     Enables the change notification for the selected port.
412:                 
413:                   Description:
414:                     This function enables the change notification for the selected port.
415:                 
416:                   Remarks:
417:                     None.
418:                 */
419:                 
420:                 void SYS_PORTS_ChangeNotificationEnable( PORTS_MODULE_ID index,
421:                                                          PORTS_CHANGE_NOTICE_PIN pinNum,
422:                                                          SYS_PORTS_PULLUP_PULLDOWN_STATUS value )
423:                 {
424:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
425:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
426:                     {
427:                         switch(value)
428:                         {
429:                             case SYS_PORTS_PULLUP_DISABLE:
430:                                 PLIB_PORTS_ChangeNoticePullUpDisable(index, pinNum);
431:                                 break;
432:                             case SYS_PORTS_PULLUP_ENABLE:
433:                                 PLIB_PORTS_ChangeNoticePullUpEnable(index, pinNum);
434:                                 break;
435:                         }
436:                     }
437:                 #endif
438:                 
439:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
440:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
441:                     {
442:                         PLIB_PORTS_PinChangeNoticeEnable( index, pinNum );
443:                     }
444:                 #endif
445:                 }
446:                 
447:                 
448:                 /******************************************************************************
449:                   Function:
450:                     void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
451:                                                               PORTS_CHANGE_NOTICE_PIN pinNum )
452:                 
453:                   Summary:
454:                     Disables the change notification for the selected port.
455:                 
456:                   Description:
457:                     This function disables the change notification for the selected port.
458:                 
459:                   Remarks:
460:                     None.
461:                 */
462:                 
463:                 void SYS_PORTS_ChangeNotificationDisable( PORTS_MODULE_ID index,
464:                                                           PORTS_CHANGE_NOTICE_PIN pinNum )
465:                 {
466:                 #if defined(PLIB_PORTS_ExistsPinChangeNotice)
467:                     if(PLIB_PORTS_ExistsPinChangeNotice(index))
468:                     {
469:                         PLIB_PORTS_PinChangeNoticeDisable( index, pinNum );
470:                     }
471:                 #endif
472:                 }
473:                 
474:                 
475:                 /******************************************************************************
476:                   Function:
477:                     void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
478:                 
479:                   Summary:
480:                     Enables the change notification for the selected port in Sleep or Idle mode.
481:                 
482:                   Description:
483:                     This function enables the change notification for the selected port in Sleep
484:                     or Idle mode.
485:                 
486:                   Remarks:
487:                     None.
488:                 */
489:                 
490:                 void SYS_PORTS_ChangeNotificationInIdleModeEnable( PORTS_MODULE_ID index )
491:                 {
492:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
493:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
494:                     {
495:                         PLIB_PORTS_ChangeNoticeInIdleEnable( index );
496:                     }
497:                 #endif
498:                 }
499:                 
500:                 
501:                 // *****************************************************************************
502:                 /* Function:
503:                     void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index)
504:                 
505:                   Summary:
506:                     Disables the change notification for the selected port in Sleep or Idle mode.
507:                 
508:                   Description:
509:                     This function disables the change notification for the selected port in Sleep
510:                     or Idle mode.
511:                 
512:                   Remarks:
513:                     None.
514:                 */
515:                 
516:                 void SYS_PORTS_ChangeNotificationInIdleModeDisable( PORTS_MODULE_ID index )
517:                 {
518:                 #if defined(PLIB_PORTS_ExistsChangeNoticeInIdle)
519:                     if(PLIB_PORTS_ExistsChangeNoticeInIdle(index))
520:                     {
521:                         PLIB_PORTS_ChangeNoticeInIdleDisable( index );
522:                     }
523:                 #endif
524:                 }
525:                 
526:                 
527:                 // *****************************************************************************
528:                 /* Function:
529:                     void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
530:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
531:                 
532:                   Summary:
533:                     Enables weak pull-up on change notification pin.
534:                 
535:                   Description:
536:                     This function enables weak pull-up on change notification pin.
537:                 
538:                   Remarks:
539:                     None.
540:                 */
541:                 
542:                 void SYS_PORTS_ChangeNotificationPullUpEnable ( PORTS_MODULE_ID         index,
543:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
544:                 {
545:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
546:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
547:                     {
548:                         PLIB_PORTS_ChangeNoticePullUpEnable ( index, pinNum );
549:                     }
550:                 #endif
551:                 }
552:                 
553:                 
554:                 // *****************************************************************************
555:                 /* Function:
556:                     void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
557:                                                                     PORTS_CHANGE_NOTICE_PIN pinNum )
558:                 
559:                   Summary:
560:                     Disables pull-up on input change.
561:                 
562:                   Description:
563:                     This function disables pull-up on input change.
564:                 
565:                   Remarks:
566:                     None.
567:                 */
568:                 
569:                 void SYS_PORTS_ChangeNotificationPullUpDisable ( PORTS_MODULE_ID         index,
570:                                                                 PORTS_CHANGE_NOTICE_PIN pinNum )
571:                 {
572:                 #if defined(PLIB_PORTS_ExistsChangeNoticePullUp)
573:                     if(PLIB_PORTS_ExistsChangeNoticePullUp(index))
574:                     {
575:                         PLIB_PORTS_ChangeNoticePullUpDisable ( index, pinNum );
576:                     }
577:                 #endif
578:                 }
579:                 
580:                 
581:                 // *****************************************************************************
582:                 // *****************************************************************************
583:                 // Section: SYS PORT PINS Control Routines
584:                 // *****************************************************************************
585:                 // *****************************************************************************
586:                 
587:                 // *****************************************************************************
588:                 /* Function:
589:                     void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
590:                     								PORTS_PIN_MODE mode)
591:                 
592:                   Summary:
593:                     Enables the selected pin as analog or digital.
594:                 
595:                   Description:
596:                     This function enables the selected pin as analog or digital.
597:                 
598:                  Remarks:
599:                     None.
600:                 */
601:                 
602:                 void SYS_PORTS_PinModeSelect ( PORTS_MODULE_ID index, PORTS_ANALOG_PIN pin,
603:                 								PORTS_PIN_MODE mode)
604:                 {
605:                 #if defined(PLIB_PORTS_ExistsPinMode)
606:                     if(PLIB_PORTS_ExistsPinMode(index))
607:                     {
608:                         PLIB_PORTS_PinModeSelect ( index, pin, mode);
609:                     }
610:                 #endif
611:                 }
612:                 
613:                 
614:                 // *****************************************************************************
615:                 /* Function:
616:                     void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
617:                                               PORTS_CHANNEL channel,
618:                                               PORTS_BIT_POS bitPos
619:                                               bool value )
620:                   Summary:
621:                     Writes the selected digital pin.
622:                 
623:                   Description:
624:                     This function writes the selected digital pin.
625:                 
626:                   Remarks:
627:                     None.
628:                 */
629:                 
630:                 void SYS_PORTS_PinWrite ( PORTS_MODULE_ID index,
631:                                           PORTS_CHANNEL channel,
632:                                           PORTS_BIT_POS bitPos,
633:                                           bool value )
634:                 {
00000000  00000000   NOP
635:                     PLIB_PORTS_PinWrite ( index, channel, bitPos, value );
636:                 }
637:                 
638:                 
639:                 // *****************************************************************************
640:                 /* Function:
641:                     bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
642:                                              PORTS_CHANNEL channel,
643:                                              PORTS_BIT_POS bitPos )
644:                 
645:                   Summary:
646:                     Reads the selected digital pin.
647:                 
648:                   Description:
649:                     This function reads the selected digital pin.
650:                 
651:                   Remarks:
652:                     None.
653:                 */
654:                 
655:                 bool SYS_PORTS_PinRead ( PORTS_MODULE_ID index,
656:                                          PORTS_CHANNEL channel,
657:                                          PORTS_BIT_POS bitPos )
658:                 {
659:                     return PLIB_PORTS_PinGet ( index, channel, bitPos );
660:                 }
00000024  00000000   NOP
661:                 
662:                 
663:                 // *****************************************************************************
664:                 /* Function:
665:                     void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
666:                                                PORTS_CHANNEL channel,
667:                                                PORTS_BIT_POS bitPos )
668:                 
669:                   Summary:
670:                     Toggles the selected digital pin.
671:                 
672:                   Description:
673:                     This function toggles the selected digital pin.
674:                 
675:                   Remarks:
676:                     None.
677:                 */
678:                 
679:                 void SYS_PORTS_PinToggle ( PORTS_MODULE_ID index,
680:                                            PORTS_CHANNEL channel,
681:                                            PORTS_BIT_POS bitPos )
682:                 {
683:                     PLIB_PORTS_PinToggle ( index, channel, bitPos );
684:                 }
685:                 
686:                 
687:                 // *****************************************************************************
688:                 /* Function:
689:                     void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
690:                                            PORTS_CHANNEL channel,
691:                                            PORTS_BIT_POS bitPos )
692:                 
693:                   Summary:
694:                     Sets the selected digital pin/latch.
695:                 
696:                   Description:
697:                     This function sets the selected digital pin/latch.
698:                 
699:                   Remarks:
700:                     None.
701:                 */
702:                 
703:                 void SYS_PORTS_PinSet( PORTS_MODULE_ID index,
704:                                        PORTS_CHANNEL channel,
705:                                        PORTS_BIT_POS bitPos )
706:                 {
707:                     PLIB_PORTS_PinSet( index, channel, bitPos );
708:                 }
709:                 
710:                 
711:                 // *****************************************************************************
712:                 /* Function:
713:                     void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
714:                                               PORTS_CHANNEL channel,
715:                                               PORTS_BIT_POS bitPos )
716:                 
717:                   Summary:
718:                     Clears the selected digital pin.
719:                 
720:                   Description:
721:                     This function clears the selected digital pin.
722:                 
723:                   Remarks:
724:                     None.
725:                 */
726:                 
727:                 void SYS_PORTS_PinClear ( PORTS_MODULE_ID index,
728:                                           PORTS_CHANNEL channel,
729:                                           PORTS_BIT_POS bitPos )
730:                 {
731:                     PLIB_PORTS_PinClear ( index, channel, bitPos );
732:                 }
733:                 
734:                 
735:                 // *****************************************************************************
736:                 /* Function:
737:                     void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
738:                                                      SYS_PORTS_PIN_DIRECTION pinDir,
739:                                                      PORTS_CHANNEL channel,
740:                                                      PORTS_BIT_POS bitPos )
741:                   Summary:
742:                     Enables the direction for the selected pin.
743:                 
744:                   Description:
745:                     This function enables the direction for the selected pin.
746:                 
747:                   Remarks:
748:                     None.
749:                 */
750:                 
751:                 void SYS_PORTS_PinDirectionSelect ( PORTS_MODULE_ID index,
752:                                                  SYS_PORTS_PIN_DIRECTION pinDir,
753:                                                  PORTS_CHANNEL channel,
754:                                                  PORTS_BIT_POS bitPos )
755:                 {
756:                     if (pinDir == SYS_PORTS_DIRECTION_OUTPUT)
00000000  00000000   NOP
757:                     {
758:                         PLIB_PORTS_PinDirectionOutputSet(index, channel, bitPos);
759:                     }
760:                     else
761:                     {
762:                         PLIB_PORTS_PinDirectionInputSet(index, channel, bitPos);
763:                     }
764:                 }
765:                 
766:                 
767:                 // *****************************************************************************
768:                 /* Function:
769:                     void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
770:                                                         PORTS_CHANNEL channel,
771:                                                         PORTS_BIT_POS bitPos )
772:                 
773:                   Summary:
774:                     Enables the open-drain functionality for the selected pin.
775:                 
776:                   Description:
777:                     This function enables the open-drain functionality for the selected pin.
778:                 
779:                   Remarks:
780:                     None.
781:                 */
782:                 
783:                 void SYS_PORTS_PinOpenDrainEnable ( PORTS_MODULE_ID index,
784:                                                     PORTS_CHANNEL channel,
785:                                                     PORTS_BIT_POS bitPos )
786:                 {
787:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
788:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
789:                     {
790:                         PLIB_PORTS_PinOpenDrainEnable ( index, channel, bitPos );
791:                     }
792:                 #endif
793:                 }
794:                 
795:                 
796:                 // *****************************************************************************
797:                 /* Function:
798:                     void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
799:                                                          PORTS_CHANNEL channel,
800:                                                          PORTS_BIT_POS bitPos )
801:                 
802:                   Summary:
803:                     Disables the open-drain functionality for the selected pin.
804:                 
805:                   Description:
806:                     This function disables the open-drain functionality for the selected pin.
807:                 
808:                   Remarks:
809:                     None.
810:                 */
811:                 
812:                 void SYS_PORTS_PinOpenDrainDisable ( PORTS_MODULE_ID index,
813:                                                      PORTS_CHANNEL channel,
814:                                                      PORTS_BIT_POS bitPos )
815:                 {
816:                 #if defined(PLIB_PORTS_ExistsPortsOpenDrain)
817:                     if(PLIB_PORTS_ExistsPortsOpenDrain(index))
818:                     {
819:                         PLIB_PORTS_PinOpenDrainDisable ( index, channel, bitPos );
820:                     }
821:                 #endif
822:                 }
823:                 
824:                 
825:                 // *****************************************************************************
826:                 /* Function:
827:                     void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
828:                 							  PORTS_REMAP_INPUT_FUNCTION function,
829:                 							  PORTS_REMAP_INPUT_PIN      remapPin )
830:                 
831:                   Summary:
832:                     Input/Output (I/O) function remapping.
833:                 
834:                   Description:
835:                     This function controls the I/O function remapping.
836:                 
837:                   Precondition:
838:                     None.
839:                 */	
840:                 void SYS_PORTS_RemapInput( PORTS_MODULE_ID      index,
841:                 						   PORTS_REMAP_INPUT_FUNCTION function,
842:                 						   PORTS_REMAP_INPUT_PIN      remapPin )
843:                 {
844:                 #if defined(PLIB_PORTS_ExistsRemapInput)
845:                     if(PLIB_PORTS_ExistsRemapInput(index))
846:                     {
847:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
848:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
849:                         PLIB_PORTS_RemapInput( index, function, remapPin);
850:                     }
851:                 #endif
852:                 }
853:                 
854:                 // *****************************************************************************
855:                 /* Function:
856:                     void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
857:                                                       PORTS_REMAP_OUTPUT_FUNCTION function,
858:                                                       PORTS_REMAP_OUTPUT_PIN      remapPin )
859:                 
860:                   Summary:
861:                     Input/Output (I/O) function remapping.
862:                 
863:                   Description:
864:                     This function controls the I/O function remapping.
865:                 
866:                   Precondition:
867:                     None.
868:                 */
869:                 void SYS_PORTS_RemapOutput( PORTS_MODULE_ID      index,
870:                 						    PORTS_REMAP_OUTPUT_FUNCTION function,
871:                 						    PORTS_REMAP_OUTPUT_PIN      remapPin )
872:                 {
873:                 #if defined(PLIB_PORTS_ExistsRemapOutput)
874:                     if(PLIB_PORTS_ExistsRemapOutput(index))
875:                     {
876:                         PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
877:                         PLIB_DEVCON_DeviceRegistersUnlock(DEVCON_ID_0, DEVCON_PPS_REGISTERS);
878:                         PLIB_PORTS_RemapOutput( index, function, remapPin);
879:                     }
880:                 #endif
881:                 }
882:                 
883:                 /*******************************************************************************
884:                  End of File
885:                 */
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/framework/system/clk/src/sys_clk_static.c
1:                   /*******************************************************************************
2:                     SYS CLK Static Functions for Clock System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_clk_static.c
9:                   
10:                    Summary:
11:                      SYS CLK static function implementations for the Clock System Service.
12:                  
13:                    Description:
14:                      The Clock System Service provides a simple interface to manage the oscillators
15:                      on Microchip microcontrollers. This file defines the static implementation for the 
16:                      Clock System Service.
17:                      
18:                    Remarks:
19:                      Static functions incorporate all system clock configuration settings as
20:                      determined by the user via the Microchip Harmony Configurator GUI.  It provides 
21:                      static version of the routines, eliminating the need for an object ID or 
22:                      object handle.
23:                      
24:                      Static single-open interfaces also eliminate the need for the open handle.
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2014 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  //DOM-IGNORE-END
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Include Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include "system_config.h"
59:                  #include "system_definitions.h"
60:                  #include "peripheral/osc/plib_osc.h"
61:                  #include "system/devcon/sys_devcon.h"
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: File Scope Functions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  /* Function:
71:                      void SYS_CLK_Static_Initialize ( const SYS_CLK_INIT const * clkInit )
72:                  
73:                    Summary:
74:                      Initializes hardware and internal data structure of the System Clock.
75:                  
76:                    Description:
77:                      This function initializes the hardware and internal data structure of System
78:                      Clock Service.
79:                  
80:                    Remarks:
81:                      This is configuration values for the static version of the Clock System Service 
82:                      module is determined by the user via the Microchip Harmony Configurator GUI.
83:                      This template will build a sys_clk_static.h and sys_clk_static.c file with 
84:                      the configuration per the user's choice.
85:                  
86:                      The objective is to eliminate the user's need to be knowledgeable in the function of
87:                      the 'configuration bits' to configure the system oscillators. 
88:                  */
89:                  
90:                  void SYS_CLK_Initialize( const SYS_CLK_INIT const * clkInit )
91:                  {
9D002F6C  27BDFFE8   ADDIU SP, SP, -24
9D002F70  AFBF0014   SW RA, 20(SP)
92:                      SYS_DEVCON_SystemUnlock ( );
9D002F74  0F400CE0   JAL SYS_DEVCON_SystemUnlock
9D002F78  00000000   NOP
93:                      
94:                      PLIB_OSC_FRCDivisorSelect( OSC_ID_0, OSC_FRC_DIV_2);
95:                  
96:                  
97:                      /* Enable Peripheral Bus 1 */
98:                      PLIB_OSC_PBClockDivisorSet (OSC_ID_0, 0, 1 );
99:                  
100:                 
101:                 
102:                 
103:                 
104:                 
105:                 
106:                   
107:                  
108:                     /* Enable and configure REFCLKO1*/
109:                     
110:                     /* ROSEL System Clock SYSCLK */
111:                     PLIB_OSC_ReferenceOscBaseClockSelect ( OSC_ID_0, OSC_REFERENCE_1, 0 );
112:                     /* RODIV */
113:                     PLIB_OSC_ReferenceOscDivisorValueSet ( OSC_ID_0, OSC_REFERENCE_1, 3 );
114:                     /* ROTRIM */
115:                     PLIB_OSC_ReferenceOscTrimSet ( OSC_ID_0, OSC_REFERENCE_1, 0 );
116:                 
117:                     PLIB_OSC_ReferenceOscEnable ( OSC_ID_0, OSC_REFERENCE_1 );
118:                     /* Disable REFCLK1_OE*/
119:                     PLIB_OSC_ReferenceOutputEnable ( OSC_ID_0, OSC_REFERENCE_1 );
120:                 
121:                 
122:                     SYS_DEVCON_SystemLock ( );
9D002FE8  0F400D47   JAL SYS_DEVCON_SystemLock
9D002FEC  00000000   NOP
123:                 }
9D002FF0  8FBF0014   LW RA, 20(SP)
9D002FF4  03E00008   JR RA
9D002FF8  27BD0018   ADDIU SP, SP, 24
124:                 
125:                 //******************************************************************************
126:                 /* Function:
127:                     inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
128:                 
129:                   Summary:
130:                     Gets the system clock frequency in Hertz.
131:                 
132:                   Description:
133:                     This function gets the System clock frequency in Hertz.
134:                 
135:                   Precondition:
136:                     None.
137:                 
138:                   Parameters:
139:                     None.
140:                 
141:                   Returns:
142:                     System clock frequency in Hertz.
143:                 
144:                   Example:
145:                     <code>
146:                     uint32_t sysClockHz;
147:                 
148:                     sysClockHz = SYS_CLK_SystemFrequencyGet ( );
149:                     </code>
150:                 
151:                   Remarks:
152:                  */
153:                 
154:                 inline uint32_t SYS_CLK_SystemFrequencyGet ( void )
155:                 {
156:                     return SYS_CLK_FREQ;
157:                 }
9D00390C  3C0202DC   LUI V0, 732
9D003910  03E00008   JR RA
9D003914  24426C00   ADDIU V0, V0, 27648
158:                 
159:                 //******************************************************************************
160:                 /* Function:
161:                     inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
162:                 
163:                   Summary:
164:                     Gets the selected clock peripheral bus frequency in Hertz.
165:                 
166:                   Description:
167:                     This function gets the selected peripheral bus clock frequency in Hertz.
168:                 
169:                   Precondition:
170:                     None.
171:                 
172:                   Parameters:
173:                 	peripheralBus - Reference clock bus selection. One of the possible value from
174:                 				CLK_BUSES_PERIPHERAL enum. For devices that do not have multiple
175:                 				clock channels for Reference clock, CLK_BUS_PERIPHERAL_1 should be
176:                 				the selection.
177:                 
178:                   Returns:
179:                     Clock frequency in Hertz.
180:                 
181:                   Example:
182:                     <code>
183:                     unsigned long peripheralClockHz;
184:                 
185:                     peripheralClockHz = SYS_CLK_PeripheralFrequencyGet ( CLK_BUS_PERIPHERAL_5 );
186:                     </code>
187:                 
188:                   Remarks:
189:                 	Most of the devices doesn't have multiple Peripheral clock buses. In that case, 
190:                 	pass CLK_USB_PERIPHERAL_1 as the bus number.
191:                  */
192:                 
193:                 inline uint32_t SYS_CLK_PeripheralFrequencyGet ( CLK_BUSES_PERIPHERAL peripheralBus )
194:                 {
195:                     return SYS_CLK_BUS_PERIPHERAL_1;
196:                 }
9D003918  3C0202DC   LUI V0, 732
197:                 
198:                 
199:                 //******************************************************************************
200:                 /* Function:
201:                     inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
202:                 
203:                   Summary:
204:                     Gets the selected Reference clock bus frequency in Hertz.
205:                 
206:                   Description:
207:                     This function gets frequency of the selected Reference clock bus in Hertz.
208:                 
209:                   Precondition:
210:                     None.
211:                 
212:                   Parameters:
213:                 	peripheralBus - Reference clock bus selection. One of the possible value from
214:                 				CLK_BUSES_REFERENCE enum. For devices that do not have multiple
215:                 				clock channels for Reference clock, CLK_BUS_REFERENCE_1 should be
216:                 				the selection.
217:                 
218:                   Returns:
219:                     Clock frequency in Hz.
220:                 
221:                   Example:
222:                     <code>
223:                     unsigned long sysClockOutputHz;
224:                 
225:                     sysClockOutputHz = SYS_CLK_ReferenceFrequencyGet ( CLK_BUS_REFERENCE_3 );
226:                     </code>
227:                 
228:                   Remarks:
229:                     None.
230:                  */
231:                 
232:                 inline uint32_t SYS_CLK_ReferenceFrequencyGet ( CLK_BUSES_REFERENCE referenceBus )
233:                 {
234:                 	return 0;
235:                 }
00000000  00000000   NOP
236:                 
237:                 /******************************************************************************
238:                   Function:
239:                     void SYS_CLK_SecondaryOscillatorEnable ( void )
240:                 
241:                   Summary:
242:                     Enables the secondary oscillator.
243:                 
244:                   Description:
245:                     This function enables the secondary oscillator.
246:                 
247:                   Remarks:
248:                     For more details refer sys_clk.h.
249:                 */
250:                 
251:                 void SYS_CLK_SecondaryOscillatorEnable ( void )
252:                 {
00000014  00000000   NOP
253:                     /* Check for secondary oscillator status */
254:                     if (!PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
255:                     {    
256:                         /* Unlock and enable secondary oscillator */
257:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
258:                         
259:                         PLIB_OSC_SecondaryEnable(OSC_ID_0);
260:                         
261:                         SYS_DEVCON_SystemLock();
00000030  00000000   NOP
262:                     }
263:                 }
00000038  00000000   NOP
264:                 
265:                 /******************************************************************************
266:                   Function:
267:                     void SYS_CLK_SecondaryOscillatorDisable ( void )
268:                 
269:                   Summary:
270:                     Disables the secondary oscillator.
271:                 
272:                   Description:
273:                     This function disables the secondary oscillator.
274:                 
275:                   Remarks:
276:                     For more details refer sys_clk.h.
277:                 */
278:                 
279:                 void SYS_CLK_SecondaryOscillatorDisable ( void )
280:                 {
00000014  00000000   NOP
281:                     /* Check for secondary oscillator status */
282:                     if (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0))
0000000C  00000000   NOP
283:                     {    
284:                         /* Unlock and disable secondary oscillator*/
285:                         SYS_DEVCON_SystemUnlock();
0000001C  00000000   NOP
286:                         
287:                         PLIB_OSC_SecondaryDisable(OSC_ID_0);
288:                         
289:                         SYS_DEVCON_SystemLock();
00000030  00000000   NOP
290:                     }
291:                 }
00000038  00000000   NOP
292:                 
293:                 /******************************************************************************
294:                   Function:
295:                     bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
296:                 
297:                   Summary:
298:                     Identifies whether secondary oscillator is enabled or disabled.
299:                 
300:                   Description:
301:                     This function identifies whether the secondary oscillator is enabled or 
302:                     disabled.
303:                     
304:                   Remarks:
305:                     For more details refer sys_clk.h.
306:                 */
307:                 
308:                 bool SYS_CLK_SecondaryOscillatorIsEnabled ( void )
309:                 {
310:                     return (PLIB_OSC_SecondaryIsEnabled(OSC_ID_0));
311:                 }
00000008  00000000   NOP
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/system_config/default/framework/driver/pmp/src/drv_pmp_static.c
1:                   /*******************************************************************************
2:                     PMP Driver Functions for Static Single Instance Driver
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_pmp_static.c
9:                   
10:                    Summary:
11:                      PMP driver implementation for the static single instance driver.
12:                  
13:                    Description:
14:                      The PMP device driver provides a simple interface to manage the PMP
15:                      modules on Microchip microcontrollers.
16:                      
17:                    Remarks:
18:                      Static interfaces incorporate the driver instance number within the names
19:                      of the routines, eliminating the need for an object ID or object handle.
20:                      Static single-open interfaces also eliminate the need for the open handle.
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  //DOM-IGNORE-END
47:                  
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  // Header Includes
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  #include "framework/driver/pmp/drv_pmp_static.h"
54:                  
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Instance 0 static driver functions
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  void DRV_PMP0_Initialize(void)
62:                  {	
63:                  
64:                      PLIB_PMP_Disable(PMP_ID_0);
65:                      PLIB_PMP_Enable(PMP_ID_0);   
66:                  
67:                  }
68:                  
69:                  void DRV_PMP0_ModeConfig(void)
70:                  {
71:                  
72:                      /*Configure Main Communication Mode */    
73:                      PLIB_PMP_OperationModeSelect(PMP_ID_0, PMP_MASTER_READ_WRITE_STROBES_INDEPENDENT);
74:                  
75:                      /*Set the data width size*/
76:                      PLIB_PMP_DataSizeSelect(PMP_ID_0, PMP_DATA_SIZE_8_BITS);
77:                  
78:                  
79:                      /* Configure the wait states */
80:                      PLIB_PMP_WaitStatesDataSetUpSelect(PMP_ID_0, PMP_DATA_WAIT_ONE);
81:                      PLIB_PMP_WaitStatesStrobeSelect(PMP_ID_0, PMP_STROBE_WAIT_5);
82:                      PLIB_PMP_WaitStatesDataHoldSelect(PMP_ID_0, PMP_DATA_HOLD_1);
83:                  
84:                  }
85:                  
86:                  void DRV_PMP0_TimingSet(PMP_DATA_WAIT_STATES dataWait,
87:                                     PMP_STROBE_WAIT_STATES strobeWait,
88:                                     PMP_DATA_HOLD_STATES dataHold)
89:                  {
90:                     /* Configure the wait states */
91:                      PLIB_PMP_WaitStatesDataSetUpSelect(PMP_ID_0, dataWait);
92:                      PLIB_PMP_WaitStatesStrobeSelect(PMP_ID_0, strobeWait);
93:                      PLIB_PMP_WaitStatesDataHoldSelect(PMP_ID_0, dataHold);
94:                  }
95:                  
96:                  void DRV_PMP0_Write(uint8_t data)
97:                  {
00000000  00000000   NOP
98:                      PLIB_PMP_MasterSend(PMP_ID_0, data);
99:                      while(PLIB_PMP_PortIsBusy(PMP_ID_0) == true);
00000018  00000000   NOP
100:                 }
00000020  00000000   NOP
101:                 
102:                 uint8_t DRV_PMP0_Read(void)
103:                 {
104:                     uint8_t value;
105:                     value = PLIB_PMP_MasterReceive(PMP_ID_0);
00000008  00000000   NOP
106:                     while(PLIB_PMP_PortIsBusy(PMP_ID_0) == true);
00000018  00000000   NOP
107:                 	
108:                     return (value);
109:                 }
00000020  00000000   NOP
110:                 
111:                 
112:                 /*******************************************************************************
113:                  End of File
114:                 */
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/main.c  --------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Project Main Source File
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       main.c
9:                   
10:                    Summary:
11:                      This file contains the "main" function for an MPLAB Harmony project.
12:                  
13:                    Description:
14:                      This file contains the "main" function for an MPLAB Harmony project.  The
15:                      "main" function calls the "SYS_Initialize" function to initialize the state 
16:                      machines of all MPLAB Harmony modules in the system and it calls the 
17:                      "SYS_Tasks" function from within a system-wide "super" loop to maintain 
18:                      their correct operation. These two functions are implemented in 
19:                      configuration-specific files (usually "system_init.c" and "system_tasks.c")
20:                      in a configuration-specific folder under the "src/system_config" folder 
21:                      within this project's top-level folder.  An MPLAB Harmony project may have
22:                      more than one configuration, each contained within it's own folder under
23:                      the "system_config" folder.
24:                   *******************************************************************************/
25:                  
26:                  // DOM-IGNORE-BEGIN
27:                  /*******************************************************************************
28:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
29:                  
30:                  //Microchip licenses to you the right to use, modify, copy and distribute
31:                  Software only when embedded on a Microchip microcontroller or digital signal
32:                  controller that is integrated into your product or third party product
33:                  (pursuant to the sublicense terms in the accompanying license agreement).
34:                  
35:                  You should refer to the license agreement accompanying this Software for
36:                  additional information regarding your rights and obligations.
37:                  
38:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
39:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
40:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
41:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
42:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
43:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
44:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
45:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
46:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
47:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
48:                   *******************************************************************************/
49:                  // DOM-IGNORE-END
50:                  
51:                  
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  
58:                  #include <stddef.h>                     // Defines NULL
59:                  #include <stdbool.h>                    // Defines true
60:                  #include <stdlib.h>                     // Defines EXIT_FAILURE
61:                  #include "system/common/sys_module.h"   // SYS function prototypes
62:                  
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Main Entry Point
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  
70:                  int main ( void )
71:                  {
9D003834  27BDFFE8   ADDIU SP, SP, -24
9D003838  AFBF0014   SW RA, 20(SP)
72:                      /* Initialize all MPLAB Harmony modules, including application(s). */
73:                      SYS_Initialize ( NULL );
9D00383C  0F400345   JAL SYS_Initialize
9D003840  00002021   ADDU A0, ZERO, ZERO
74:                  
75:                  
76:                      while ( true )
77:                      {
78:                          /* Maintain state machines of all polled MPLAB Harmony modules. */
79:                          SYS_Tasks ( );
9D003844  0F400DFA   JAL SYS_Tasks
9D003848  00000000   NOP
9D00384C  0B400E11   J 0x9D003844
9D003850  00000000   NOP
80:                  
81:                      }
82:                  
83:                      /* Execution should not come here during normal operation */
84:                  
85:                      return ( EXIT_FAILURE );
86:                  }
87:                  
88:                  
89:                  /*******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/density_map.c  -------------------
1:                   #include "density_map.h"
2:                   #define MAX_PEAKS 100
3:                   
4:                   #define MIN_DENSITY 1500
5:                   
6:                   #define xkl 20
7:                   #define ykl 20
8:                   #define xcl (  DENSITY_MAP_WIDTH + xkl - 1 )
9:                   #define ycl ( DENSITY_MAP_HEIGHT + ykl - 1 )
10:                  
11:                  double xk[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
12:                  double yk[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
13:                  double xi[DENSITY_MAP_WIDTH];
14:                  double yi[DENSITY_MAP_HEIGHT];
15:                  double xc[xcl];
16:                  double yc[ycl];
17:                  
18:                  int xpn = 0;
19:                  int ypn = 0;
20:                  
21:                  int xp[MAX_PEAKS], yp[MAX_PEAKS];
22:                  density_peak_t density_peaks[MAX_PEAKS];
23:                  
24:                  void convolve(const double Signal[], size_t SignalLen,
25:                                const double Kernel[], size_t KernelLen,
26:                                double Result[])
27:                  {
00000000  00000000   NOP
28:                      size_t n;
29:                      int i = 0;
30:                      for (n = 0; n < SignalLen + KernelLen - 1; n++)
00000030  00000000   NOP
00000098  00000000   NOP
000000D0  00000000   NOP
31:                      {
32:                          size_t kmin, kmax, k;
33:                          
34:                          Result[n] = 0;
00000060  00000000   NOP
35:                          
36:                          kmin = (n >= KernelLen - 1) ? n - (KernelLen - 1) : 0;
00000048  00000000   NOP
00000054  00000000   NOP
00000068  00000000   NOP
000000F4  00000000   NOP
37:                          kmax = (n < SignalLen - 1) ? n : SignalLen - 1;
00000050  00000000   NOP
00000080  00000000   NOP
000000E4  00000000   NOP
38:                          
39:                          
40:                          for (k = kmin; k <= kmax; k++)
0000008C  00000000   NOP
000000BC  00000000   NOP
41:                          {
42:                              i++;
43:                              Result[n] += Signal[k] * Kernel[n - k];
000000A0  00000000   NOP
44:                          }
45:                      }
46:                  }
00000118  00000000   NOP
47:                  
48:                  void calculatePeaks( void )
49:                  {
00000000  00000000   NOP
50:                      int peak = 1;
00000044  00000000   NOP
51:                      double prev, diff;
52:                      prev = xc[0];
0000002C  00000000   NOP
53:                      uint16_t i, j;
54:                      for (j = 1; j < xcl; j++ )
00000058  00000000   NOP
000000CC  00000000   NOP
55:                      {
56:                          diff = xc[j] - prev;
0000005C  00000000   NOP
57:                          if ( peak )
0000006C  00000000   NOP
58:                          {
59:                              if ( diff < 0 )
00000074  00000000   NOP
60:                              {
61:                                  peak = 0;
0000009C  00000000   NOP
62:                                  xp[xpn++] = j;
0000004C  00000000   NOP
00000088  00000000   NOP
63:                              }
64:                              prev = xc[j];
65:                              if (xpn == MAX_PEAKS) break;
000000A0  00000000   NOP
66:                          }
67:                          else
68:                          {
69:                              if ( diff > 0 ) peak = 1;
00000048  00000000   NOP
000000B4  00000000   NOP
70:                          }
71:                      }
72:                      
73:                      prev = yc[0];
000000D8  00000000   NOP
74:                      for (i = 1; i < ycl; i++ )
00000100  00000000   NOP
00000174  00000000   NOP
75:                      {
76:                          diff = yc[i] - prev;
00000104  00000000   NOP
77:                          if ( peak )
00000114  00000000   NOP
78:                          {
79:                              if ( diff < 0 )
0000011C  00000000   NOP
80:                              {
81:                                  peak = 0;
00000144  00000000   NOP
82:                                  yp[ypn++] = i;
000000F4  00000000   NOP
00000130  00000000   NOP
83:                              }
84:                              prev = yc[i];
85:                              if (ypn == MAX_PEAKS) break;
00000148  00000000   NOP
86:                          }
87:                          else
88:                          {
89:                              if ( diff > 0 ) peak = 1;
000000F0  00000000   NOP
0000015C  00000000   NOP
90:                          }
91:                      }
92:                  }
00000180  00000000   NOP
93:                    
94:                  void processDensityMaps( void )
95:                  {
00000000  00000000   NOP
96:                      convolve(xi,  DENSITY_MAP_WIDTH, xk, xkl, xc);
0000002C  00000000   NOP
97:                      convolve(yi, DENSITY_MAP_HEIGHT, yk, ykl, yc);
00000054  00000000   NOP
98:                      calculatePeaks();
0000007C  00000000   NOP
99:                      int index = 0, i, j;
000000A4  00000000   NOP
100:                     for(i = 0; i < ypn; i++ )
00000084  00000000   NOP
000000A0  00000000   NOP
00000200  00000000   NOP
101:                     {
102:                         int y = (int)((float)yp[i] * (float)DENSITY_MAP_HEIGHT/(float)ycl);
000000F4  00000000   NOP
103:                         for(j = 0; j < xpn; j++ )
00000090  00000000   NOP
00000130  00000000   NOP
00000150  00000000   NOP
000001F0  00000000   NOP
104:                         {
105:                             int x = (int)((float)xp[j] * (float)DENSITY_MAP_WIDTH/(float)xcl);
000000B4  00000000   NOP
00000154  00000000   NOP
106:                 
107:                             if(( xc[x] + yc[y] ) > MIN_DENSITY )
000000A8  00000000   NOP
000000D0  00000000   NOP
00000138  00000000   NOP
00000194  00000000   NOP
108:                             {
109:                                 /* Peak height */
110:                                 density_peaks[index].X = x;
000000E8  00000000   NOP
000001C4  00000000   NOP
111:                                 density_peaks[index].Y = y;
000001D8  00000000   NOP
112:                                 density_peaks[index].X = xc[x] + yc[y];
000001E0  00000000   NOP
113:                                 index++;
000001EC  00000000   NOP
114:                             }
115:                         }
116:                     }
117:                 }
00000228  00000000   NOP
118:                 
119:                 void generateDensityMaps( uint8_t image_line[], uint16_t y )
120:                 {
00000000  00000000   NOP
121:                     uint16_t x = 0;
0000003C  00000000   NOP
122:                     while( x < DENSITY_MAP_WIDTH )                        // Traverse all columns
000000A8  00000000   NOP
123:                     {
124:                         uint8_t a = image_line[x];
00000064  00000000   NOP
125:                         if( a > DENSITY_MAP_THRESH )          // Check if pixel is on
00000034  00000000   NOP
00000068  00000000   NOP
126:                         {
127:                             xi[x] += 1;
00000040  00000000   NOP
00000078  00000000   NOP
128:                             yi[y] += 1;
00000050  00000000   NOP
00000090  00000000   NOP
129:                         }
130:                         x += DENSITY_MAP_INTERVAL;
00000038  00000000   NOP
000000A0  00000000   NOP
131:                     }
132:                 }
000000B4  00000000   NOP
133:                 
134:                 void initDensityMaps( uint16_t width, uint16_t height, uint16_t interval, uint16_t thresh )
135:                 {  
136:                 //    DENSITY_MAP_WIDTH     = width;
137:                 //    DENSITY_MAP_HEIGHT    = height;
138:                     DENSITY_MAP_INTERVAL  = interval;
00000000  00000000   NOP
139:                     DENSITY_MAP_THRESH    = thresh;
00000004  00000000   NOP
140:                 }
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/centroid.c  ----------------------
1:                   #include "centroid.h"
2:                   
3:                   map_t       map[MAP_SIZE];
4:                   segment_t   segments[MAX_SEGMENTS];
5:                   centroid_t  centroids[MAX_CENTROIDS];  /**< Global array of detected object */
6:                   
7:                   uint16_t    map_index = 0;
8:                   uint16_t    segment_index = 0;
9:                   uint16_t    num_centroids = 0;
10:                  
11:                  inline float cma( float new_val, float avg, uint16_t num )
12:                  {
00000000  00000000   NOP
13:                      return avg + ( new_val - avg ) / num; // num is pre-incremented
00000018  00000000   NOP
00000090  00000000   NOP
000000C4  00000000   NOP
00000104  00000000   NOP
14:                  }
00000044  00000000   NOP
15:                  
16:                  uint16_t processCentroids( void )
17:                  {
00000000  00000000   NOP
18:                      uint16_t j = 0, i = 0;
00000048  00000000   NOP
00000194  00000000   NOP
19:                      for( ; j < segment_index; j++ )
0000002C  00000000   NOP
0000014C  00000000   NOP
20:                      {
21:                          for( ; i < map_index; i++ )
00000038  00000000   NOP
00000138  00000000   NOP
00000170  00000000   NOP
22:                          {
23:                              if( segments[j].i == i )
0000006C  00000000   NOP
00000180  00000000   NOP
24:                              {
25:                                  uint16_t p = map[i].p;
00000050  00000000   NOP
00000184  00000000   NOP
26:                                  centroids[p].M += segments[j].w;
0000005C  00000000   NOP
00000074  00000000   NOP
27:                                  centroids[p].n++;
000000B0  00000000   NOP
28:                                  centroids[p].X = cma( segments[j].x, centroids[p].X, centroids[p].n);
000000C0  00000000   NOP
000000F4  00000000   NOP
29:                                  centroids[p].Y = cma( segments[j].l, centroids[p].Y, centroids[p].n);
000000F8  00000000   NOP
00000134  00000000   NOP
30:                              }
31:                          }
32:                      }
33:                      for( i = 0; i < num_centroids; i++)
00000198  00000000   NOP
00000274  00000000   NOP
34:                      {
35:                          if( centroids[i].M == 0)
000001A4  00000000   NOP
36:                          {
37:                              while( j == 0 )
000001F4  00000000   NOP
38:                              {
39:                                  j = centroids[--num_centroids].M;
000001D0  00000000   NOP
0000020C  00000000   NOP
40:                                  if( num_centroids == 0 ) return 0;
000001E4  00000000   NOP
00000228  00000000   NOP
00000294  00000000   NOP
41:                              }
42:                              centroids[i] = centroids[num_centroids];
00000238  00000000   NOP
43:                          }
44:                      }
45:                      return num_centroids;
46:                  }
00000298  00000000   NOP
47:                  
48:                  uint16_t getSegmentId( uint16_t y, float x, uint16_t w )
49:                  {
00000000  00000000   NOP
50:                      uint16_t id = NULL_C, i;
0000004C  00000000   NOP
000001D8  00000000   NOP
51:                      for(i = 0; i < map_index; i++)
00000030  00000000   NOP
00000048  00000000   NOP
000001B8  00000000   NOP
52:                      {
53:                          if( map[i].a ) // Ensure map is still active
00000054  00000000   NOP
0000006C  00000000   NOP
54:                          {
55:                              if( ( y - map[i].y ) > MAX_GAP)
00000080  00000000   NOP
56:                              {
57:                                  map[i].a = false;
0000009C  00000000   NOP
58:                              }
59:                              else
60:                              {
61:                                  /* Get current average and previous row width */
62:                                  float    x_l = map[i].x;
000000AC  00000000   NOP
63:                                  uint16_t w_l = map[i].w;
64:                                  float  w_c_2 =   w / 2;
00000040  00000000   NOP
000000B4  00000000   NOP
65:                                  float  w_l_2 = w_l / 2;  
000000C0  00000000   NOP
66:                                  /* Check overlap of lower bound of centroid and upper (with gap tolerance) of new
67:                                   and of upper bound of centroid and lower (with gap tolerance) of new */
68:                                  if( ( ( x + w_c_2 + MAX_GAP ) >= ( x_l - w_l_2 ) ) &&
0000005C  00000000   NOP
000000D0  00000000   NOP
00000134  00000000   NOP
69:                                      ( ( x - w_c_2 - MAX_GAP ) <= ( x_l + w_l_2 ) ) )
00000068  00000000   NOP
0000010C  00000000   NOP
70:                                  {
71:                                      /* If object is unclaimed, claim it, otherwise combine it */
72:                                      if( id == NULL_C )
00000148  00000000   NOP
73:                                      {
74:                                          id = i;
75:                                      }
76:                                      else
77:                                      {
78:                                          if(map[i].s)
00000158  00000000   NOP
79:                                          {
80:                                              num_centroids--;
00000168  00000000   NOP
81:                                              map[i].s  = false;
00000174  00000000   NOP
82:                                              map[id].s = false;
00000180  00000000   NOP
83:                                              map[i]    = map[id];
00000190  00000000   NOP
84:                                          }
85:                                      }
86:                                  }
87:                              }
88:                          }
89:                      }
90:                      /* Valid if object was claimed, null if not */
91:                      return id;
92:                  }
000001E0  00000000   NOP
93:                  
94:                  void getCentroids( uint8_t image_line[], uint16_t line_number )
95:                  {
00000000  00000000   NOP
96:                      uint16_t gap = NULL_G, temp_id, num_adj = 0, x = 1;                           // Global variables
00000044  00000000   NOP
97:                      float a_x_last = 0;                                 // Global last X and Y averages
00000040  00000000   NOP
98:                      while( x < CENTROIDS_WIDTH )                        // Traverse all columns
0000002C  00000000   NOP
00000198  00000000   NOP
99:                      {
100:                         uint8_t a = image_line[x];
00000068  00000000   NOP
101:                         if( a > CENTROIDS_THRESH )          // Check if pixel is on
0000006C  00000000   NOP
102:                         {
103:                             gap = 0;
104:                             num_adj++; 
00000080  00000000   NOP
105:                             a_x_last = cma( x, a_x_last, num_adj );               // Average adjacent pixels
00000088  00000000   NOP
106:                                                              // Increment adjacent pixels
107:                         }
108:                         else if( gap != MAX_GAP )                                           // Otherwise, if gap counter is counting (i.e. there was a recent pixel
00000050  00000000   NOP
000000CC  00000000   NOP
109:                         {
110:                             gap++;
000000D4  00000000   NOP
111:                             if( gap == MAX_GAP )
000000DC  00000000   NOP
112:                             {
113:                                 temp_id = getSegmentId( line_number, a_x_last, num_adj );
000000E4  00000000   NOP
114:                                 if( temp_id == NULL_C )             // If no blob return
000000F4  00000000   NOP
115:                                 {
116:                                     temp_id = map_index++;
00000100  00000000   NOP
117:                                     map[temp_id].p = temp_id;
0000010C  00000000   NOP
118:                                     map[temp_id].a = true;
00000118  00000000   NOP
119:                                     map[temp_id].s = true;
00000120  00000000   NOP
120:                                     num_centroids++;
00000124  00000000   NOP
121:                                 }
122:                                 map[temp_id].x = a_x_last;
00000054  00000000   NOP
00000130  00000000   NOP
123:                                 map[temp_id].w = num_adj;
0000013C  00000000   NOP
124:                                 map[temp_id].y = line_number;
00000140  00000000   NOP
125:                                 segments[segment_index].i = map[temp_id].p;
0000005C  00000000   NOP
00000144  00000000   NOP
126:                                 segments[segment_index].l = line_number;
00000164  00000000   NOP
127:                                 segments[segment_index].x = a_x_last;
00000168  00000000   NOP
128:                                 segments[segment_index].w = num_adj;
0000016C  00000000   NOP
129:                                 segment_index++;
00000178  00000000   NOP
130:                                 num_adj  = 0;                                            // Reset number of adjacent pixels
00000184  00000000   NOP
131:                                 a_x_last = 0;                                           // Reset adjacent pixel average
00000180  00000000   NOP
132:                                 gap      = NULL_G;
00000188  00000000   NOP
133:                             }
134:                         }
135:                         x += CENTROIDS_INTERVAL;
0000018C  00000000   NOP
136:                     }
137:                 }
000001A8  00000000   NOP
138:                 
139:                 void initCentroids( uint16_t width, uint16_t height, uint16_t interval, uint16_t thresh )
140:                 {  
141:                     CENTROIDS_WIDTH     = width;
9D0038A8  A7848044   SH A0, -32700(GP)
142:                     CENTROIDS_HEIGHT    = height;
9D0038AC  A7858048   SH A1, -32696(GP)
143:                     CENTROIDS_INTERVAL  = interval;
9D0038B0  A7868046   SH A2, -32698(GP)
144:                     CENTROIDS_THRESH    = thresh;
9D0038B4  03E00008   JR RA
9D0038B8  A787804A   SH A3, -32694(GP)
145:                 }
146:                 
147:                 void resetBlobs( void )
148:                 {
149:                     num_centroids = 0;
00000000  00000000   NOP
150:                     segment_index = 0;
00000004  00000000   NOP
151:                     map_index     = 0;
00000008  00000000   NOP
152:                     uint16_t i    = sizeof( centroids );
153:                     uint8_t * p   = ( uint8_t * )&centroids;
0000000C  00000000   NOP
154:                     while (i-- > 0) *p++ = 0;
00000014  00000000   NOP
155:                 }
00000028  00000000   NOP
---  c:/users/matthew fonken/desktop/camera-module/cammod/firmware/src/app.c  ---------------------------
1:                   /*******************************************************************************
2:                     MPLAB Harmony Application Source File
3:                     
4:                     Company:
5:                       Microchip Technology Inc.
6:                     
7:                     File Name:
8:                       app.c
9:                   
10:                    Summary:
11:                      This file contains the source code for the MPLAB Harmony application.
12:                  
13:                    Description:
14:                      This file contains the source code for the MPLAB Harmony application.  It 
15:                      implements the logic of the application's state machine and it may call 
16:                      API routines of other MPLAB Harmony modules in the system, such as drivers,
17:                      system services, and middleware.  However, it does not call any of the
18:                      system interfaces (such as the "Initialize" and "Tasks" functions) of any of
19:                      the modules in the system or make any assumptions about when those functions
20:                      are called.  That is the responsibility of the configuration-specific system
21:                      files.
22:                   *******************************************************************************/
23:                  
24:                  //<editor-fold defaultstate="collapsed" desc="Copyright Details">
25:                  // DOM-IGNORE-BEGIN
26:                  /*******************************************************************************
27:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
28:                  
29:                  Microchip licenses to you the right to use, modify, copy and distribute
30:                  Software only when embedded on a Microchip microcontroller or digital signal
31:                  controller that is integrated into your product or third party product
32:                  (pursuant to the sublicense terms in the accompanying license agreement).
33:                  
34:                  You should refer to the license agreement accompanying this Software for
35:                  additional information regarding your rights and obligations.
36:                  
37:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
38:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
39:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
40:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
41:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
42:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
43:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
44:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
45:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
46:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
47:                   *******************************************************************************/
48:                  // DOM-IGNORE-END
49:                  //</editor-fold>
50:                  
51:                  //<editor-fold defaultstate="collapsed" desc="Include Files">
52:                  // *****************************************************************************
53:                  // *****************************************************************************
54:                  // Section: Included Files 
55:                  // *****************************************************************************
56:                  // *****************************************************************************
57:                  #include "app.h"
58:                  #include "centroid.h"
59:                  #include "ov9712.h"
60:                  //</editor-fold>
61:                  
62:                  //<editor-fold defaultstate="collapsed" desc="Global Data Definitions">
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Global Data Definitions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  // *****************************************************************************
70:                  
71:                  /* Application Data
72:                  
73:                    Summary:
74:                      Holds application data
75:                  
76:                    Description:
77:                      This structure holds the application's data.
78:                  
79:                    Remarks:
80:                      This structure should be initialized by the APP_Initialize function.
81:                      
82:                      Application strings and buffers are be defined outside this structure.
83:                  */
84:                  APP_DATA appData;
85:                  
86:                  uint16_t frame_row_count = 0;
87:                  uint16_t frame_row_div_count = APP_FRAME_ROW_DIV;
88:                  bool wait_for_vsync = true;
89:                  
90:                  //</editor-fold>
91:                  
92:                  //<editor-fold defaultstate="collapsed" desc="System Control Functions">
93:                  // *****************************************************************************
94:                  // *****************************************************************************
95:                  // Section: System Control Functions
96:                  // *****************************************************************************
97:                  // *****************************************************************************
98:                  inline void enableHREFINT( void )
99:                  {
100:                     SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_1);
101:                 }
102:                 inline void disableHREFINT( void )
103:                 {
00000000  00000000   NOP
104:                     SYS_INT_SourceDisable(INT_SOURCE_EXTERNAL_1);
9D00290C  0F400D0B   JAL SYS_INT_SourceDisable
9D002910  24040008   ADDIU A0, ZERO, 8
00000008  00000000   NOP
105:                 }
00000010  00000000   NOP
106:                 
107:                 inline void enablePCLKINT( void )
108:                 {
109:                     SYS_INT_SourceEnable(INT_SOURCE_EXTERNAL_4);
110:                 }
111:                 inline void disablePCLKINT( void )
112:                 {
00000000  00000000   NOP
113:                     SYS_INT_SourceDisable(INT_SOURCE_EXTERNAL_4);
9D002904  0F400D0B   JAL SYS_INT_SourceDisable
9D002908  24040017   ADDIU A0, ZERO, 23
00000008  00000000   NOP
114:                 }
00000010  00000000   NOP
115:                 
116:                 inline void transferAddDMA( void )
117:                 {
00000000  00000000   NOP
118:                     SYS_DMA_ChannelTransferAdd(appData.sysDMAHandle, (uint8_t *)&PMDIN, 1, appData.ramBuff, APP_CAMERA_WIDTH, 1);
9D0010D4  8E04000C   LW A0, 12(S0)
9D0010D8  24020500   ADDIU V0, ZERO, 1280
9D0010DC  AFA20010   SW V0, 16(SP)
9D0010E0  24100001   ADDIU S0, ZERO, 1
9D0010E4  AFB00014   SW S0, 20(SP)
9D0010E8  3C05BF80   LUI A1, -16512
9D0010EC  24A57040   ADDIU A1, A1, 28736
9D0010F0  24060001   ADDIU A2, ZERO, 1
9D0010F4  3C07A000   LUI A3, -24576
9D0010F8  0F40067E   JAL SYS_DMA_ChannelTransferAdd
9D0010FC  24E70260   ADDIU A3, A3, 608
00000008  00000000   NOP
119:                 }
00000038  00000000   NOP
120:                 //</editor-fold>
121:                 
122:                 //<editor-fold defaultstate="collapsed" desc="Application Initialization Functions">
123:                 // *****************************************************************************
124:                 // *****************************************************************************
125:                 // Section: Application Initialization
126:                 // *****************************************************************************
127:                 // *****************************************************************************
128:                  static void App_Frame_Event_Handler(SYS_DMA_TRANSFER_EVENT event,
129:                         SYS_DMA_CHANNEL_HANDLE handle, uintptr_t contextHandle);
130:                  
131:                  static uint8_t bImg[32000];
132:                  static int bIndex;
133:                 /*******************************************************************************
134:                   Function:
135:                     void APP_Initialize ( void )
136:                 
137:                   Remarks:
138:                     See prototype in app.h.
139:                  */
140:                 void APP_Initialize ( void )
141:                 {
142:                     /* Place the App state machine in its initial state. */
143:                     appData.state = APP_STATE_INIT;
9D003900  3C02A000   LUI V0, -24576
9D003904  03E00008   JR RA
9D003908  AC400250   SW ZERO, 592(V0)
144:                 }
145:                 
146:                 /******************************************************************************
147:                   Function:
148:                     void Camera_Initialize( void )
149:                 
150:                   Description:
151:                     Initialize camera registers using OV9712_regs.h
152:                  */
153:                 bool Camera_Initialize( void )
154:                 {
9D002AF4  27BDFFC8   ADDIU SP, SP, -56
9D002AF8  AFBF0034   SW RA, 52(SP)
9D002AFC  AFB40030   SW S4, 48(SP)
9D002B00  AFB3002C   SW S3, 44(SP)
9D002B04  AFB20028   SW S2, 40(SP)
9D002B08  AFB10024   SW S1, 36(SP)
9D002B0C  AFB00020   SW S0, 32(SP)
155:                     int i = 0, j = 0;
156:                     uint8_t buffer[2];
157:                     for( ; ; i++ )
158:                     {
159:                         if( OV9712_regs[i].id == ENDR ) 
9D002B10  93828014   LBU V0, -32748(GP)
9D002B14  240300FF   ADDIU V1, ZERO, 255
9D002B18  10430019   BEQ V0, V1, 0x9D002B80
9D002B1C  27938014   ADDIU S3, GP, -32748
9D002B28  241400FF   ADDIU S4, ZERO, 255
9D002B74  92620000   LBU V0, 0(S3)
9D002B78  5454FFED   BNEL V0, S4, 0x9D002B30
9D002B7C  A3A20018   SB V0, 24(SP)
160:                         {
161:                             return true;
162:                         }
163:                         buffer[0] = OV9712_regs[i].id;
9D002B2C  A3A20018   SB V0, 24(SP)
164:                         buffer[1] = OV9712_regs[i].value;
9D002B30  92620001   LBU V0, 1(S3)
9D002B34  A3A20019   SB V0, 25(SP)
165:                         DRV_I2C_BUFFER_HANDLE handle = DRV_I2C_Transmit( appData.drvI2CHandle, OV9712_ADDR, buffer, (sizeof(buffer)), NULL );
9D002B20  3C10A000   LUI S0, -24576
9D002B38  26020250   ADDIU V0, S0, 592
9D002B3C  8C440004   LW A0, 4(V0)
9D002B40  AFA00010   SW ZERO, 16(SP)
9D002B44  24050060   ADDIU A1, ZERO, 96
9D002B48  27A60018   ADDIU A2, SP, 24
9D002B4C  0F400459   JAL DRV_I2C_Transmit
9D002B50  24070002   ADDIU A3, ZERO, 2
9D002B54  00408821   ADDU S1, V0, ZERO
166:                         while( DRV_I2C_TransferStatusGet( appData.drvI2CHandle, handle ) != DRV_I2C_BUFFER_EVENT_COMPLETE );
9D002B24  24120001   ADDIU S2, ZERO, 1
9D002B58  26030250   ADDIU V1, S0, 592
9D002B5C  8C640004   LW A0, 4(V1)
9D002B60  0F400E4B   JAL DRV_I2C_TransferStatusGet
9D002B64  02202821   ADDU A1, S1, ZERO
9D002B68  1452FFFC   BNE V0, S2, 0x9D002B5C
9D002B6C  26030250   ADDIU V1, S0, 592
9D002B70  26730002   ADDIU S3, S3, 2
167:                     }
168:                 }
9D002B80  24020001   ADDIU V0, ZERO, 1
9D002B84  8FBF0034   LW RA, 52(SP)
9D002B88  8FB40030   LW S4, 48(SP)
9D002B8C  8FB3002C   LW S3, 44(SP)
9D002B90  8FB20028   LW S2, 40(SP)
9D002B94  8FB10024   LW S1, 36(SP)
9D002B98  8FB00020   LW S0, 32(SP)
9D002B9C  03E00008   JR RA
9D002BA0  27BD0038   ADDIU SP, SP, 56
169:                 //</editor-fold>
170:                 
171:                 //<editor-fold defaultstate="expanded" desc="Application Main Tasks">
172:                 // *****************************************************************************
173:                 // *****************************************************************************
174:                 // Section: Application Main Tasks
175:                 // *****************************************************************************
176:                 // *****************************************************************************
177:                 void APP_Tasks ( void )
178:                 {
9D000F78  27BDFFD8   ADDIU SP, SP, -40
9D000F7C  AFBF0024   SW RA, 36(SP)
9D000F80  AFB20020   SW S2, 32(SP)
9D000F84  AFB1001C   SW S1, 28(SP)
9D000F88  AFB00018   SW S0, 24(SP)
179:                 
180:                     /* Check the application's current state. */
181:                     switch ( appData.state )
9D000F8C  3C02A000   LUI V0, -24576
9D000F90  8C420250   LW V0, 592(V0)
9D000F94  10400005   BEQ V0, ZERO, PLIB_INT_VectorPrioritySet
9D000F98  24030001   ADDIU V1, ZERO, 1
9D000F9C  10430062   BEQ V0, V1, 0x9D001128
9D000FA0  3C02A000   LUI V0, -24576
182:                     {
183:                         /* Application's initial state. */
184:                         case APP_STATE_INIT:
185:                         {
186:                             bool appInitialized = true;
187:                        
188:                             if (appInitialized)
189:                             {
190:                                 SYS_INT_VectorPrioritySet(INT_VECTOR_CS0, INT_PRIORITY_LEVEL6);
191:                                 SYS_INT_VectorSubprioritySet(INT_VECTOR_CS0, INT_SUBPRIORITY_LEVEL0);
192:                                 SYS_INT_SourceEnable(INT_SOURCE_SOFTWARE_0);
193:                                 
194:                                 SYS_INT_VectorPrioritySet(INT_VECTOR_CS1, INT_PRIORITY_LEVEL7);
195:                                 SYS_INT_VectorSubprioritySet(INT_VECTOR_CS1, INT_SUBPRIORITY_LEVEL0);
196:                                 SYS_INT_SourceEnable(INT_SOURCE_SOFTWARE_1);
197:                     
198:                                 delay(10000);
9D00103C  0F400E04   JAL delay
9D001040  24042710   ADDIU A0, ZERO, 10000
199:                                 appData.drvI2CHandle = DRV_I2C_Open( DRV_I2C_INDEX_0, DRV_IO_INTENT_WRITE ); 
9D001044  00002021   ADDU A0, ZERO, ZERO
9D001048  0F4009FC   JAL DRV_I2C_Open
9D00104C  24050002   ADDIU A1, ZERO, 2
9D001050  3C12A000   LUI S2, -24576
9D001054  26500250   ADDIU S0, S2, 592
9D001058  AE020004   SW V0, 4(S0)
200:                                 delay(300);
9D00105C  0F400E04   JAL delay
9D001060  2404012C   ADDIU A0, ZERO, 300
201:                                 appData.drvUSARTHandle = DRV_USART_Open( DRV_USART_INDEX_0, DRV_IO_INTENT_WRITE );
9D001064  00002021   ADDU A0, ZERO, ZERO
9D001068  0F400864   JAL DRV_USART_Open
9D00106C  24050002   ADDIU A1, ZERO, 2
9D001070  AE020008   SW V0, 8(S0)
202:                 
203:                                 printChar( '>' );
9D001074  0F400D34   JAL printChar
9D001078  2404003E   ADDIU A0, ZERO, 62
204:                                 printChar( '\r' );
9D00107C  0F400D34   JAL printChar
9D001080  2404000D   ADDIU A0, ZERO, 13
205:                                 printChar( '\n' );
9D001084  0F400D34   JAL printChar
9D001088  2404000A   ADDIU A0, ZERO, 10
206:                                 delay(20000);
9D00108C  0F400E04   JAL delay
9D001090  24044E20   ADDIU A0, ZERO, 20000
207:                                 
208:                                 Camera_Initialize();
9D001094  0F400ABD   JAL Camera_Initialize
9D001098  00000000   NOP
209:                                 delay(20000);
9D00109C  0F400E04   JAL delay
9D0010A0  24044E20   ADDIU A0, ZERO, 20000
210:                 
211:                                 /* Allocate a DMA channel */
212:                                 appData.sysDMAHandle = SYS_DMA_ChannelAllocate(DMA_CHANNEL_0);
9D0010A4  0F400CC9   JAL SYS_DMA_ChannelAllocate
9D0010A8  00002021   ADDU A0, ZERO, ZERO
9D0010AC  AE02000C   SW V0, 12(S0)
213:                                 
214:                                 /* Register an event handler for the channel */
215:                                 SYS_DMA_ChannelTransferEventHandlerSet(appData.sysDMAHandle, App_Frame_Event_Handler, NULL);
9D0010B0  00402021   ADDU A0, V0, ZERO
9D0010B4  3C059D00   LUI A1, -25344
9D0010B8  24A53924   ADDIU A1, A1, 14628
9D0010BC  0F400E15   JAL SYS_DMA_ChannelTransferEventHandlerSet
9D0010C0  00003021   ADDU A2, ZERO, ZERO
216:                 
217:                                 /* Setup the channel */
218:                                 SYS_DMA_ChannelSetup(appData.sysDMAHandle,
9D0010C4  8E04000C   LW A0, 12(S0)
9D0010C8  24050011   ADDIU A1, ZERO, 17
9D0010CC  0F400623   JAL SYS_DMA_ChannelSetup
9D0010D0  24060017   ADDIU A2, ZERO, 23
219:                                                         (SYS_DMA_CHANNEL_OP_MODE_BASIC | SYS_DMA_CHANNEL_OP_MODE_AUTO),
220:                                                         INT_SOURCE_EXTERNAL_4);
221:                 
222:                                 /* Add the memory block transfer request. */  
223:                                 transferAddDMA();
224:                                 //APP_FRAME_WIDTH, APP_FRAME_HEIGHT, APP_FRAME_WIDTH_RGGB
225:                                 initCentroids( APP_FRAME_WIDTH_RGGB, APP_FRAME_HEIGHT, APP_DEFAULT_INTERVAL, APP_DEFAULT_THRESHOLD );
9D001100  24040500   ADDIU A0, ZERO, 1280
9D001104  24050190   ADDIU A1, ZERO, 400
9D001108  24060005   ADDIU A2, ZERO, 5
9D00110C  0F400E2A   JAL initCentroids
9D001110  240700DC   ADDIU A3, ZERO, 220
226:                                 appData.state = APP_STATE_SERVICE_TASKS;
9D001114  AE500250   SW S0, 592(S2)
227:                                 SYS_INT_SourceEnable( INT_SOURCE_EXTERNAL_3 );
228:                             }
229:                             break;
230:                         }
231:                 
232:                         case APP_STATE_SERVICE_TASKS:
233:                         {
234:                              if ( !DRV_USART_ReceiverBufferIsEmpty( appData.drvUSARTHandle ) )
9D001128  0F400DBF   JAL DRV_USART_ReceiverBufferIsEmpty
9D00112C  8C440258   LW A0, 600(V0)
9D001130  14400007   BNE V0, ZERO, 0x9D001150
9D001134  8FBF0024   LW RA, 36(SP)
235:                             {
236:                                 uint8_t c = DRV_USART_ReadByte( appData.drvUSARTHandle );
9D001138  3C02A000   LUI V0, -24576
9D00113C  0F400D20   JAL DRV_USART_ReadByte
9D001140  8C440258   LW A0, 600(V0)
237:                                 printChar( c );   
9D001144  0F400D34   JAL printChar
9D001148  00402021   ADDU A0, V0, ZERO
238:                             }
239:                             break;
240:                         }
241:                 
242:                         /* The default state should never be executed. */
243:                         default:
244:                         {
245:                             break;
246:                         }
247:                     }
248:                 }
9D000FA4  0B400454   J 0x9D001150
9D000FA8  8FBF0024   LW RA, 36(SP)
9D001120  0B400454   J 0x9D001150
9D001124  8FBF0024   LW RA, 36(SP)
9D00114C  8FBF0024   LW RA, 36(SP)
9D001150  8FB20020   LW S2, 32(SP)
9D001154  8FB1001C   LW S1, 28(SP)
9D001158  8FB00018   LW S0, 24(SP)
9D00115C  03E00008   JR RA
9D001160  27BD0028   ADDIU SP, SP, 40
249:                 //</editor-fold>
250:                 
251:                 //<editor-fold defaultstate="collapsed" desc="Application Event Handlers">
252:                 // *****************************************************************************
253:                 // *****************************************************************************
254:                 // Section: Application Event Handlers
255:                 // *****************************************************************************
256:                 // *****************************************************************************
257:                 
258:                  static void App_Frame_Event_Handler(SYS_DMA_TRANSFER_EVENT event,
259:                         SYS_DMA_CHANNEL_HANDLE handle, uintptr_t contextHandle)
260:                 {
9D003924  03E00008   JR RA
261:                     if(SYS_DMA_TRANSFER_EVENT_COMPLETE == event)
262:                     {
263:                         //SYS_INT_SourceStatusSet( DMA_TRIGGER_SOFTWARE_1 );
264:                     }
265:                 }
266:                 
267:                 // *****************************************************************************
268:                 // Section: VSYNC Handlers
269:                 // *****************************************************************************
270:                 void APP_VSYNC_Interrupt_Handler( void )
271:                 {
9D0028BC  27BDFFE0   ADDIU SP, SP, -32
9D0028C0  AFBF001C   SW RA, 28(SP)
9D0028C4  AFB10018   SW S1, 24(SP)
9D0028C8  AFB00014   SW S0, 20(SP)
272:                     if(wait_for_vsync)
9D0028CC  93828010   LBU V0, -32752(GP)
9D0028D0  10400006   BEQ V0, ZERO, 0x9D0028EC
9D0028D4  24030100   ADDIU V1, ZERO, 256
273:                     {
274:                         //enablePCLKINT();
275:                         SYS_INT_SourceEnable( INT_SOURCE_EXTERNAL_1 ); // Enable HSYNC
276:                         wait_for_vsync = false;
277:                     }
278:                     else
279:                     {
280:                 #ifdef PROCESS_CENTROIDS
281:                         sendCentroidData();
282:                 #endif
283:                         printChar( 0xab );  
9D0028EC  0F400D34   JAL printChar
9D0028F0  240400AB   ADDIU A0, ZERO, 171
284:                         printChar( 0x34 );
9D0028F4  0F400D34   JAL printChar
9D0028F8  24040034   ADDIU A0, ZERO, 52
285:                 
286:                         frame_row_div_count = APP_FRAME_ROW_DIV;
9D0028FC  24020001   ADDIU V0, ZERO, 1
9D002900  A7828012   SH V0, -32750(GP)
287:                 #ifdef BOOL_IMG
288:                         disablePCLKINT();
289:                         disableHREFINT();
290:                         int i = 0;
291:                         for(; i < bIndex; i++)
9D002914  8F82801C   LW V0, -32740(GP)
9D002918  1840000B   BLEZ V0, enableHREFINT
9D00291C  00008021   ADDU S0, ZERO, ZERO
9D002920  3C11A000   LUI S1, -24576
9D002924  26310860   ADDIU S1, S1, 2144
9D002928  02301021   ADDU V0, S1, S0
9D002934  26100001   ADDIU S0, S0, 1
9D002938  8F82801C   LW V0, -32740(GP)
9D00293C  0202102A   SLT V0, S0, V0
9D002940  1440FFFA   BNE V0, ZERO, 0x9D00292C
9D002944  02301021   ADDU V0, S1, S0
292:                         {
293:                              printChar( bImg[i] );
9D00292C  0F400D34   JAL printChar
9D002930  90440000   LBU A0, 0(V0)
294:                         }
295:                         enableHREFINT();
296:                         enablePCLKINT();
297:                 #endif
298:                     }
299:                     frame_row_count = 0;
9D002960  A7808020   SH ZERO, -32736(GP)
300:                     
301:                     bIndex = 0;
9D002964  AF80801C   SW ZERO, -32740(GP)
302:                 }
9D002968  8FBF001C   LW RA, 28(SP)
9D00296C  8FB10018   LW S1, 24(SP)
9D002970  8FB00014   LW S0, 20(SP)
9D002974  03E00008   JR RA
9D002978  27BD0020   ADDIU SP, SP, 32
303:                 
304:                 // *****************************************************************************
305:                 // Section: HSYNC Handlers
306:                 // *****************************************************************************
307:                 void APP_HSYNC_Interrupt_Handler( void )
308:                 {
309:                     if( frame_row_div_count-- ==  0)
9D002BA4  97828012   LHU V0, -32750(GP)
9D002BA8  2443FFFF   ADDIU V1, V0, -1
9D002BAC  14400025   BNE V0, ZERO, 0x9D002C44
9D002BB0  A7838012   SH V1, -32750(GP)
9D002BB4  8F82801C   LW V0, -32740(GP)
9D002BB8  3C08A000   LUI T0, -24576
9D002BBC  25080860   ADDIU T0, T0, 2144
9D002BC0  01024021   ADDU T0, T0, V0
9D002BC4  00003821   ADDU A3, ZERO, ZERO
9D002BC8  00001021   ADDU V0, ZERO, ZERO
310:                     {
311:                         //disablePCLKINT();
312:                 #ifdef PROCESS_CENTROIDS
313:                         getCentroids( appData.ramBuff, frame_row_count );
314:                 #endif
315:                         
316:                 #ifdef DEBUG_IMG
317:                         uint8_t i = 0;
318:                         while( i < APP_FRAME_WIDTH_RGGB ) printChar( appData.ramBuff[i++] );
319:                 #endif
320:                 #ifdef BOOL_IMG
321:                         uint8_t i = 0, j = 0;
322:                         
323:                         while( i < APP_FRAME_WIDTH_B_IMG_TOP )
324:                         {
325:                             uint8_t o = 0;
9D002BF0  00001821   ADDU V1, ZERO, ZERO
9D002C34  00001821   ADDU V1, ZERO, ZERO
326:                             for(; j < 8; j++)
9D002BD4  2CE30008   SLTIU V1, A3, 8
9D002BD8  10600016   BEQ V1, ZERO, 0x9D002C34
9D002BDC  24490010   ADDIU T1, V0, 16
9D002BE0  312900FF   ANDI T1, T1, 255
9D002BE4  00072840   SLL A1, A3, 1
9D002BE8  01252823   SUBU A1, T1, A1
9D002BEC  30A500FF   ANDI A1, A1, 255
9D002C14  1445FFF7   BNE V0, A1, 0x9D002BF4
9D002C18  306300FF   ANDI V1, V1, 255
9D002C1C  00071023   SUBU V0, ZERO, A3
9D002C20  00021040   SLL V0, V0, 1
9D002C24  01221021   ADDU V0, T1, V0
9D002C28  304200FF   ANDI V0, V0, 255
9D002C2C  0B400B0E   J 0x9D002C38
9D002C30  24070008   ADDIU A3, ZERO, 8
327:                             {
328:                                 o |= ( appData.ramBuff[i] > APP_DEFAULT_THRESHOLD );
9D002BCC  3C06A000   LUI A2, -24576
9D002BD0  24C60250   ADDIU A2, A2, 592
9D002BF4  00462021   ADDU A0, V0, A2
9D002BF8  90840010   LBU A0, 16(A0)
9D002BFC  2C8400DD   SLTIU A0, A0, 221
9D002C00  38840001   XORI A0, A0, 1
9D002C04  00831825   OR V1, A0, V1
329:                                 o <<= 1;
9D002C08  00031840   SLL V1, V1, 1
330:                                 i+=2;
9D002C0C  24420002   ADDIU V0, V0, 2
9D002C10  304200FF   ANDI V0, V0, 255
331:                             }
332:                             bImg[bIndex++] = o; 
9D002C38  A1030000   SB V1, 0(T0)
333:                         }
9D002C3C  0B400AF5   J 0x9D002BD4
9D002C40  25080001   ADDIU T0, T0, 1
9D002C44  03E00008   JR RA
9D002C48  00000000   NOP
334:                 #endif
335:                         
336:                         frame_row_div_count = APP_FRAME_ROW_DIV;
337:                         frame_row_count++;
338:                         transferAddDMA();
339:                         //enablePCLKINT();
340:                     }   
341:                 }
342:                 
343:                 void APP_PCLK_Interrupt_Handler( void );
344:                 void APP_Line_Done_Interrupt_Handler( void )
345:                 {
346:                     appData.state = APP_STATE_SERVICE_TASKS;
9D0038E4  24030001   ADDIU V1, ZERO, 1
9D0038E8  3C02A000   LUI V0, -24576
9D0038EC  03E00008   JR RA
9D0038F0  AC430250   SW V1, 592(V0)
347:                 }
348:                 
349:                 //</editor-fold> 
350:                 
351:                 //<editor-fold defaultstate="collapsed" desc="System Functions">
352:                 // *****************************************************************************
353:                 // *****************************************************************************
354:                 // Section: System Functions
355:                 // *****************************************************************************
356:                 // *****************************************************************************
357:                 
358:                 void sendCentroidData(void)
359:                 {
00000000  00000000   NOP
360:                     //<editor-fold defaultstate="collapsed" desc="Centroids"> 
361:                     uint8_t numBlobs = processCentroids();
00000014  00000000   NOP
362:                     uint8_t i;
363:                     printChar( CENTROID_HEAD );
00000020  00000000   NOP
364:                     printChar( numBlobs );
00000028  00000000   NOP
365:                     uint16_t x, y, m;
366:                     for( i = 0; i < numBlobs; i++ )
00000030  00000000   NOP
0000008C  00000000   NOP
367:                     {
368:                         m = centroids[i].M;
00000058  00000000   NOP
369:                         x = centroids[i].X;
00000068  00000000   NOP
370:                         y = centroids[i].Y;
0000005C  00000000   NOP
371:                 
372:                         printTwoBytes( x );
00000070  00000000   NOP
373:                         printTwoBytes( y );
00000078  00000000   NOP
374:                         printTwoBytes( m );
00000080  00000000   NOP
375:                     }
376:                     
377:                     resetBlobs();
00000094  00000000   NOP
378:                 //</editor-fold>
379:                 }
0000009C  00000000   NOP
380:                 
381:                 void delay( int count )
382:                 {
383:                     int j = 0;
384:                     while(j++ < count) Nop();
9D003810  18800006   BLEZ A0, 0x9D00382C
9D003814  24840001   ADDIU A0, A0, 1
9D003818  24020001   ADDIU V0, ZERO, 1
9D00381C  00000040   SSNOP
9D003820  24420001   ADDIU V0, V0, 1
9D003824  1444FFFD   BNE V0, A0, 0x9D00381C
9D003828  00000000   NOP
9D00382C  03E00008   JR RA
9D003830  00000000   NOP
385:                 }
386:                 
387:                 void printChar( uint8_t c )
388:                 {
9D0034D0  27BDFFE8   ADDIU SP, SP, -24
9D0034D4  AFBF0014   SW RA, 20(SP)
9D0034D8  AFB00010   SW S0, 16(SP)
9D0034DC  309000FF   ANDI S0, A0, 255
389:                     if( !DRV_USART_TransmitBufferIsFull( appData.drvUSARTHandle ) )
9D0034E0  3C02A000   LUI V0, -24576
9D0034E4  0F400DCD   JAL DRV_USART_TransmitBufferIsFull
9D0034E8  8C440258   LW A0, 600(V0)
9D0034EC  14400008   BNE V0, ZERO, 0x9D003510
9D0034F0  8FBF0014   LW RA, 20(SP)
390:                     {
391:                         DRV_USART_WriteByte( appData.drvUSARTHandle , c );
9D0034F4  3C02A000   LUI V0, -24576
9D0034F8  8C440258   LW A0, 600(V0)
9D0034FC  0F400C7B   JAL DRV_USART_WriteByte
9D003500  02002821   ADDU A1, S0, ZERO
392:                         delay(150);
9D003504  0F400E04   JAL delay
9D003508  24040096   ADDIU A0, ZERO, 150
393:                     }
394:                 }
9D00350C  8FBF0014   LW RA, 20(SP)
9D003510  8FB00010   LW S0, 16(SP)
9D003514  03E00008   JR RA
9D003518  27BD0018   ADDIU SP, SP, 24
395:                 void printTwoBytes( uint16_t d )
396:                 {
00000000  00000000   NOP
397:                     uint8_t top = *( ( uint8_t * )&d + 1 );
398:                     uint8_t btm = *( uint8_t * )&d;
00000010  00000000   NOP
399:                     printChar( top );
00000014  00000000   NOP
400:                     printChar( btm );
0000001C  00000000   NOP
401:                 }
00000024  00000000   NOP
402:                 //</editor-fold>
403:                 
404:                 /*******************************************************************************
405:                  End of File
406:                  */
---  c:/microchip/harmony/v2_01b/framework/system/int/src/sys_int_pic32.c  ------------------------------
1:                   /*******************************************************************************
2:                     Interrupt System Service
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_int_pic32.c
9:                   
10:                    Summary:
11:                      Interrupt System Service APIs.
12:                  
13:                    Description:
14:                      This file contains functions related to the Interrupt System Service for PIC32
15:                      devices.
16:                  *******************************************************************************/
17:                  
18:                  // DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                  *******************************************************************************/
41:                  // DOM-IGNORE-END
42:                  
43:                  #include "system/int/sys_int.h"
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: Function Definitions
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  
52:                  /******************************************************************************
53:                  
54:                    Function:
55:                      void SYS_INT_Initialize ( void )
56:                  
57:                    Summary:
58:                      Configures and initializes the interrupt sub-system.
59:                  
60:                    Description:
61:                      This function appropriately configures and initializes the interrupt sub-system
62:                      for the current system design.
63:                  
64:                    Precondition:
65:                      None.
66:                  
67:                    Parameters:
68:                      None.
69:                  
70:                    Returns:
71:                      None.
72:                  
73:                    Example:
74:                    <code>
75:                    SYS_INT_Initialize();
76:                    </code>
77:                  
78:                    Remarks:
79:                      This function is not implemented in the System Interrupt library.  It is
80:                      implemented by the board support package (using the processor-specific
81:                      interrupt peripheral library) because it requires knowledge of the specific
82:                      interrupt requirements for each system.
83:                  */
84:                  
85:                  void SYS_INT_Initialize ( void )
86:                  
87:                  {
88:                      /* enable the multi vector */
89:                      PLIB_INT_MultiVectorSelect( INT_ID_0 );
90:                  }
91:                  
92:                  //*******************************************************************************
93:                  /*  Function:
94:                       SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
95:                  
96:                    Summary:
97:                      Disables interrupts to the processor and return the previois status.
98:                      
99:                    Description:
100:                     This function disables interrupts to the processor at the top level. This
101:                     function can be called to prevent any source from being able to generate an
102:                     interrupt. It returns the processor status (which includes global interrupt
103:                     status and Interrupt Priority status) before disabling the interrupts.
104:                 
105:                   Remarks:
106:                     See sys_int.h file for more details.
107:                 */
108:                 
109:                 SYS_INT_PROCESSOR_STATUS  SYS_INT_StatusGetAndDisable ( void )
110:                 {
00000000  00000000   NOP
111:                     SYS_INT_PROCESSOR_STATUS processorStatus;
112:                 
113:                     /* Save the processor status and then Disable the global interrupt */
114:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
115:                 
116:                     /* return the processor status */
117:                     return processorStatus;
118:                 }
00000010  00000000   NOP
119:                 
120:                 //*******************************************************************************
121:                 /* Function:
122:                     void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
123:                 
124:                   Summary:
125:                     Restores the processor status.
126:                 
127:                   Description:
128:                     This function sets the processor status based on the 32 bit value passed as 
129:                     a parameter. 0th bit of the status is for Master Interrupt status.
130:                 
131:                   Remarks:
132:                     See sys_int.h file for more details.
133:                 */
134:                 
135:                 void SYS_INT_StatusRestore ( SYS_INT_PROCESSOR_STATUS processorStatus )
136:                 {
00000000  00000000   NOP
137:                     PLIB_INT_SetState(INT_ID_0, processorStatus);
138:                 }
00000010  00000000   NOP
139:                 
140:                 // *****************************************************************************
141:                 /*  Disable the generation of interrupts to the CPU
142:                 
143:                   Summary:
144:                      Disables all interrupts
145:                 
146:                   Description:
147:                      This function disables all interrupts.
148:                 
149:                   Remarks:
150:                     This API will be depricated soon. Use "SYS_INT_StatusGetAndDisable" instead.
151:                  */
152:                 
153:                 bool SYS_INT_Disable( void )
154:                 {
00000000  00000000   NOP
155:                     SYS_INT_PROCESSOR_STATUS processorStatus;
156:                 
157:                     /* Save the processor status and then Disable the global interrupt */
158:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
159:                 
160:                     /* return the interrupt status */
161:                     return (bool)(processorStatus & 0x01);
162:                 }
00000010  00000000   NOP
163:                 
164:                 // *****************************************************************************
165:                 /* Function:
166:                     bool SYS_INT_SourceDisable ( INT_SOURCE source )
167:                 
168:                   Summary:
169:                     Disables the interrupt source.
170:                 
171:                   Description:
172:                     This routine disables the given source from generating interrupts the 
173:                     processor when events occur.It returns the interrupt source enable/disable 
174:                 	status before disabling the interrupt source.
175:                 
176:                   Remarks:
177:                     See sys_int.h file for more details.
178:                  */
179:                 
180:                 
181:                 bool SYS_INT_SourceDisable ( INT_SOURCE source )
182:                 {
9D00342C  27BDFFF8   ADDIU SP, SP, -8
9D003430  AFBF0004   SW RA, 4(SP)
183:                     bool intSrcStatus;
184:                     SYS_INT_PROCESSOR_STATUS processorStatus;
185:                 
186:                     /* Save the processor status and then Disable the global interrupt */
187:                     processorStatus = PLIB_INT_GetStateAndDisable( INT_ID_0 );
188:                     
189:                     /* get the interrupt status of this source before disable is called */
190:                     intSrcStatus = PLIB_INT_SourceIsEnabled (INT_ID_0 , source);
191:                 
192:                     /* disable the interrupts */
193:                     PLIB_INT_SourceDisable (INT_ID_0 , source);
194:                 
195:                     /* restore the state of CP0 Status register before the disable occurred*/
196:                     PLIB_INT_SetState(INT_ID_0 , processorStatus);
197:                 
198:                     /* return the source status */
199:                     return intSrcStatus;
200:                 }
9D003470  30420001   ANDI V0, V0, 1
9D003474  8FBF0004   LW RA, 4(SP)
9D003478  03E00008   JR RA
9D00347C  27BD0008   ADDIU SP, SP, 8
201:                 
202:                 
203:                 // *****************************************************************************
204:                 /* Sets the external interrupt trigger type.
205:                 
206:                   Summary:
207:                     Sets the external interrupt trigger type.
208:                 
209:                   Description:
210:                     This function sets the External interrupt trigger type.
211:                 
212:                   Remarks:
213:                     Refer the datasheet to know the external interrupt sources supported.
214:                  */
215:                 
216:                 void SYS_INT_ExternalInterruptTriggerSet ( 	INT_EXTERNAL_SOURCES source,
217:                 										INT_EXTERNAL_EDGE_TRIGGER edgeTrigger )
218:                 {
219:                 	if ( edgeTrigger == INT_EDGE_TRIGGER_RISING )
9D0037C0  24020001   ADDIU V0, ZERO, 1
9D0037C4  14A20005   BNE A1, V0, SYS_INT_ExternalInterruptTriggerSet::PLIB_INT_ExternalFallingEdgeSelect
9D0037C8  3C02BF88   LUI V0, -16504
9D0037CC  3C02BF88   LUI V0, -16504
9D0037D0  AC441008   SW A0, 4104(V0)
9D0037D4  03E00008   JR RA
9D0037D8  00000000   NOP
9D0037DC  AC441004   SW A0, 4100(V0)
9D0037E0  03E00008   JR RA
9D0037E4  00000000   NOP
220:                 	{
221:                 		PLIB_INT_ExternalRisingEdgeSelect ( INT_ID_0, source );
222:                 	}
223:                 	else
224:                 	{
225:                 		PLIB_INT_ExternalFallingEdgeSelect ( INT_ID_0, source );
226:                 	}
227:                 }
228:                 
---  c:/microchip/harmony/v2_01b/framework/system/dma/src/sys_dma.c  ------------------------------------
1:                   /*******************************************************************************
2:                     DMA System Service Library
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_dma.c
9:                   
10:                    Summary:
11:                      DMA System Service.
12:                  
13:                    Description:
14:                      This file implements the core functionality of the DMA System Service.
15:                      It provides a way to interact with the DMA subsystem to
16:                      manage the data transfer between different peripherals and/or memory
17:                      without intervention from the CPU.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  // *****************************************************************************
46:                  // *****************************************************************************
47:                  // Section: File includes
48:                  // *****************************************************************************
49:                  // *****************************************************************************
50:                  
51:                  #include "system_config.h"
52:                  #include "system/int/sys_int.h"
53:                  #include "system/dma/sys_dma.h"
54:                  #include "system/dma/src/sys_dma_local.h"
55:                  
56:                  
57:                  
58:                  // *****************************************************************************
59:                  /* DMA Channel instance objects.
60:                  
61:                    Summary:
62:                      Defines the DMA channel objects
63:                  
64:                    Description:
65:                      This data type defines the DMA channel objects. It holds the information
66:                      about the usage/availability of a channel for DMA data transfers
67:                  
68:                    Remarks:
69:                      Not all modes are available on all micro-controllers.
70:                   */
71:                  
72:                  SYS_DMA_CHANNEL_OBJECT  gSysDMAChannelObj[SYS_DMA_CHANNEL_COUNT];
73:                  
74:                  
75:                  // *****************************************************************************
76:                  // *****************************************************************************
77:                  // Section: DMA System Service Interface Routines
78:                  // *****************************************************************************
79:                  // *****************************************************************************
80:                  
81:                  
82:                  // *****************************************************************************
83:                  // *****************************************************************************
84:                  // Section: Initialization
85:                  // *****************************************************************************
86:                  // *****************************************************************************
87:                  //******************************************************************************
88:                  /* Function:
89:                      SYS_MODULE_OBJ SYS_DMA_Initialize(const SYS_MODULE_INIT * const init)
90:                  
91:                    Summary:
92:                      Initializes and Enables the DMA Controller.
93:                  
94:                    Description:
95:                      This function Enables the DMA module. Enable/Disable stop in idle mode
96:                      feature based on the passed parameter value.
97:                  
98:                      This routine initializes the DMA module making it ready for clients to
99:                      open and use it. The initialization data is specified by the init parameter.
100:                 
101:                   Remarks:
102:                     This routine must be called before any other DMA systems service routines
103:                     are called.
104:                 
105:                     Not all features are available on all micro-controllers.
106:                 */
107:                 SYS_MODULE_OBJ SYS_DMA_Initialize(const SYS_MODULE_INIT * const init)
108:                 {
109:                     SYS_DMA_INIT *initp;
110:                     uint8_t chanIndex;
111:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
112:                 
113:                 
114:                     /* Validate the init object */
115:                     if ((SYS_MODULE_INIT *)NULL == init)
9D00325C  10800018   BEQ A0, ZERO, 0x9D0032C0
9D003260  3C05BF88   LUI A1, -16504
116:                     {
117:                         SYS_ASSERT(false, "Invalid Init Object");
118:                         return SYS_MODULE_OBJ_INVALID;
119:                     }
120:                 
121:                     initp = (SYS_DMA_INIT *)init;
122:                 
123:                     /* Enable/disable the stop in idle mode feature. */
124:                 #if defined (PLIB_DMA_ExistsStopInIdle)
125:                     if(true == PLIB_DMA_ExistsStopInIdle(DMA_ID_0))
126:                     {
127:                         if(SYS_DMA_SIDL_DISABLE == initp->sidl)
128:                         {
129:                             PLIB_DMA_StopInIdleDisable(DMA_ID_0);
130:                         }
131:                         else if(SYS_DMA_SIDL_ENABLE == initp->sidl)
132:                         {
133:                             PLIB_DMA_StopInIdleEnable(DMA_ID_0);
134:                         }
135:                     }
136:                 #endif
137:                     /* Enable the DMA module */
138:                     PLIB_DMA_Enable(DMA_ID_0);
139:                 
140:                     /* Initialize the available channel objects */
141:                     chanObj             =   (SYS_DMA_CHANNEL_OBJECT *)&gSysDMAChannelObj[0];
9D003274  3C03A000   LUI V1, -24576
9D003278  2463080C   ADDIU V1, V1, 2060
142:                     for(chanIndex = 0; chanIndex < SYS_DMA_CHANNEL_COUNT; chanIndex++)
9D003280  3C08BF88   LUI T0, -16504
9D003284  25083360   ADDIU T0, T0, 13152
9D0032B0  14A8FFF5   BNE A1, T0, 0x9D003288
9D0032B4  30C60003   ANDI A2, A2, 3
143:                     {
144:                         chanObj->inUse          =    false;
9D003288  A0600000   SB ZERO, 0(V1)
145:                         chanObj->pEventCallBack =    NULL;
9D00328C  AC600008   SW ZERO, 8(V1)
146:                         chanObj->hClientArg     =    0;
9D003290  AC60000C   SW ZERO, 12(V1)
147:                         chanObj->errorInfo      =    SYS_DMA_ERROR_NONE;
9D00327C  24090001   ADDIU T1, ZERO, 1
9D003294  AC690004   SW T1, 4(V1)
148:                         chanObj                 =    chanObj + 1;
9D003298  24630010   ADDIU V1, V1, 16
149:                         /* Initializing all channel priorities as 0 */
150:                         PLIB_DMA_ChannelXPrioritySelect(DMA_ID_0, chanIndex, chanIndex);
151:                     }
152:                 
153:                     /* Return the object structure */
154:                     return ((SYS_MODULE_OBJ) initp);
9D0032B8  03E00008   JR RA
9D0032BC  00801021   ADDU V0, A0, ZERO
155:                 }
9D0032C0  03E00008   JR RA
9D0032C4  2402FFFF   ADDIU V0, ZERO, -1
156:                 
157:                 
158:                 // *****************************************************************************
159:                 // *****************************************************************************
160:                 // Section:  Channel Setup and management routines
161:                 // *****************************************************************************
162:                 // *****************************************************************************
163:                 
164:                 //******************************************************************************
165:                 /* Function:
166:                     SYS_DMA_CHANNEL_HANDLE SYS_DMA_ChannelAllocate(DMA_CHANNEL channel)
167:                 
168:                   Summary:
169:                     Allocates the specified DMA channel and returns a handle to it
170:                 
171:                   Description:
172:                     This routine opens the specified DMA channel and provides a
173:                     handle that must be provided to all other client-level operations to
174:                     identify the caller and the DMA channel.
175:                 
176:                   Remarks:
177:                     The handle returned is valid until the SYS_DMA_ChannelRelease routine is called.
178:                     This routine must be called before any other DMA channel Setup and management
179:                     routines are called
180:                 */
181:                 SYS_DMA_CHANNEL_HANDLE SYS_DMA_ChannelAllocate(DMA_CHANNEL channel)
182:                 {
9D003324  00001821   ADDU V1, ZERO, ZERO
183:                     SYS_DMA_CHANNEL_HANDLE              channelHandle;
184:                     SYS_DMA_CHANNEL_OBJECT              *chanObj;
185:                     uint8_t                             chanIndex;
186:                     bool                                chanAlloc;
187:                 
188:                     channelHandle       =   (SYS_DMA_CHANNEL_HANDLE)NULL;
189:                     chanAlloc           =   false;
190:                     chanObj             =   (SYS_DMA_CHANNEL_OBJECT *)&gSysDMAChannelObj[0];
9D003328  3C02A000   LUI V0, -24576
9D00332C  2442080C   ADDIU V0, V0, 2060
191:                 
192:                     for(chanIndex = 0; chanIndex < SYS_DMA_CHANNEL_COUNT; chanIndex++)
9D003334  3C06A000   LUI A2, -24576
9D003338  24C6084C   ADDIU A2, A2, 2124
9D003370  1446FFF2   BNE V0, A2, 0x9D00333C
9D003374  24630001   ADDIU V1, V1, 1
193:                     {
194:                         /* Iterate to find a free channel */
195:                         if(false == chanObj->inUse)
9D00333C  90450000   LBU A1, 0(V0)
9D003340  54A0000B   BNEL A1, ZERO, 0x9D003370
9D003344  24420010   ADDIU V0, V0, 16
196:                         {
197:                             /* If user's choice is any,
198:                              * Allocate the first available free channel */
199:                             if(DMA_CHANNEL_ANY == channel)
9D003330  2407FFFE   ADDIU A3, ZERO, -2
9D003348  14870004   BNE A0, A3, 0x9D00335C
9D00334C  00000000   NOP
200:                             {
201:                                 chanObj->inUse          = true;
9D003350  24030001   ADDIU V1, ZERO, 1
202:                                 chanAlloc               = true;
203:                                 break;
9D003354  03E00008   JR RA
9D003358  A0430000   SB V1, 0(V0)
204:                             }
205:                             /* Check if the requested channel is free */
206:                             else if(chanIndex == channel)
9D00335C  54640004   BNEL V1, A0, 0x9D003370
9D003360  24420010   ADDIU V0, V0, 16
207:                             {
208:                                 chanObj->inUse          = true;
9D003364  24030001   ADDIU V1, ZERO, 1
209:                                 chanAlloc               = true;
210:                                 break;
9D003368  03E00008   JR RA
9D00336C  A0430000   SB V1, 0(V0)
211:                             }
212:                 
213:                         }
214:                         /* Check the next channel object */
215:                         chanObj += 1;
216:                     }
217:                     if(true == chanAlloc )
218:                     {
219:                         /* Return the valid found handle */
220:                         channelHandle  = (SYS_DMA_CHANNEL_HANDLE)chanObj;
221:                     }
222:                     else
223:                     {
224:                         /* Return an Invalid handle */
225:                         channelHandle = SYS_DMA_CHANNEL_HANDLE_INVALID;
226:                     }
227:                     return channelHandle;
228:                 }
9D003378  03E00008   JR RA
9D00337C  2402FFFF   ADDIU V0, ZERO, -1
229:                 
230:                 
231:                 //******************************************************************************
232:                 /* Function:
233:                     void SYS_DMA_ChannelRelease(SYS_DMA_CHANNEL_HANDLE handle)
234:                 
235:                   Summary:
236:                     Deallocates and frees the channel specified by the handle.
237:                 
238:                   Description:
239:                     This routine deallocates an allocated-channel of the DMA module,
240:                     invalidating the handle.
241:                 
242:                   Remarks:
243:                     After calling this routine, the handle passed in "handle" must not be used
244:                     with any of the remaining service's routines.  A new handle must be obtained by
245:                     calling SYS_DMA_ChannelAllocate before the caller may use the service again
246:                 */
247:                  void SYS_DMA_ChannelRelease (SYS_DMA_CHANNEL_HANDLE handle)
248:                  {
00000000  00000000   NOP
249:                     uint8_t index;
250:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
251:                     DMA_CHANNEL channelNumber;
252:                 
253:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
254:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000018  00000000   NOP
255:                     chanObj->inUse = false;
00000014  00000000   NOP
256:                     /* Disable all interrupts on this channel */
257:                     for(index = 0; index < 8 ;index++)
0000014C  00000000   NOP
258:                     {
259:                         PLIB_DMA_ChannelXINTSourceDisable( DMA_ID_0, channelNumber, (1<<index));
00000044  00000000   NOP
00000084  00000000   NOP
260:                     }
261:                     return;
262:                  }
00000154  00000000   NOP
263:                 
264:                 
265:                 //******************************************************************************
266:                 /* Function:
267:                     void SYS_DMA_ChannelSetup
268:                     (
269:                         SYS_DMA_CHANNEL_HANDLE handle,
270:                         SYS_DMA_CHANNEL_OP_MODE modeEnable,
271:                         DMA_TRIGGER_SOURCE eventSrc
272:                     )
273:                 
274:                   Summary:
275:                     Setup the DMA channel parameters.
276:                 
277:                   Description:
278:                     This function sets up the DMA channel parameters.
279:                     It sets the channel priority and enables the mode of operations for the
280:                     current system design.
281:                 
282:                   Remarks:
283:                     If SYS_DMA_CHANNEL_OP_MODE_MATCH_ABORT or
284:                     SYS_DMA_CHANNEL_OP_MODE_CRC mode of operation is enabled, then corresponding
285:                     mode setup API's needs to be called to set the related parameters.
286:                 
287:                     If the parameter 'eventSrc' is specified as DMA_TRIGGER_SOURCE_NONE then
288:                     SYS_DMA_ChannelForceStart must be called to start the DMA channel transfer.
289:                 
290:                     Not all features are available on all micro-controllers.
291:                   */
292:                 
293:                 void SYS_DMA_ChannelSetup
294:                 (
295:                     SYS_DMA_CHANNEL_HANDLE handle,
296:                     SYS_DMA_CHANNEL_OP_MODE modeEnable,
297:                     DMA_TRIGGER_SOURCE eventSrc
298:                 )
299:                 {
300:                 
301:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
302:                     DMA_CHANNEL channelNumber;
303:                 
304:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
305:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D00188C  3C02A000   LUI V0, -24576
9D001890  2442080C   ADDIU V0, V0, 2060
9D001894  00822023   SUBU A0, A0, V0
306:                 
307:                     /* Setup the channel modes */
308:                     /* Basic mode, nothing specifically needs to be set */
309:                     if(SYS_DMA_CHANNEL_OP_MODE_BASIC & modeEnable)
310:                     {
311:                         /* Do nothing */
312:                         ;
313:                     }
314:                 
315:                     /* Pattern match Abort */
316:                     if(SYS_DMA_CHANNEL_OP_MODE_MATCH_ABORT & modeEnable)
9D001898  30A20002   ANDI V0, A1, 2
9D00189C  10400009   BEQ V0, ZERO, 0x9D0018C4
9D0018A0  00042103   SRA A0, A0, 4
317:                     {
318:                         PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber,
319:                                                         DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT);
320:                     }
321:                 
322:                     /* Channel chaining mode */
323:                     if(SYS_DMA_CHANNEL_OP_MODE_CHAIN_HIGH & modeEnable)
9D0018C4  30A20004   ANDI V0, A1, 4
9D0018C8  5040000F   BEQL V0, ZERO, 0x9D001908
9D0018CC  30A20008   ANDI V0, A1, 8
324:                     {
325:                         PLIB_DMA_ChannelXChainEnable( DMA_ID_0, channelNumber);
326:                         PLIB_DMA_ChannelXChainToHigher(DMA_ID_0, channelNumber);
327:                         PLIB_DMA_ChannelXDisabledEnablesEvents(DMA_ID_0, channelNumber);
328:                     }
329:                     else if(SYS_DMA_CHANNEL_OP_MODE_CHAIN_LOW & modeEnable)
9D001908  1040000E   BEQ V0, ZERO, 0x9D001944
9D00190C  30A20010   ANDI V0, A1, 16
330:                     {
331:                         PLIB_DMA_ChannelXChainEnable( DMA_ID_0, channelNumber);
332:                         PLIB_DMA_ChannelXChainToLower(DMA_ID_0, channelNumber);
333:                         PLIB_DMA_ChannelXDisabledEnablesEvents(DMA_ID_0, channelNumber);
334:                     }
335:                     else
336:                     {
337:                         ;
338:                     }
339:                 
340:                     /* Auto Enable mode */
341:                     if(SYS_DMA_CHANNEL_OP_MODE_AUTO & modeEnable)
9D001900  0B400651   J 0x9D001944
9D001904  30A20010   ANDI V0, A1, 16
9D001940  30A20010   ANDI V0, A1, 16
9D001944  5040000A   BEQL V0, ZERO, 0x9D001970
9D001948  30A50020   ANDI A1, A1, 32
342:                     {
343:                         PLIB_DMA_ChannelXAutoEnable( DMA_ID_0, channelNumber);
344:                     }
345:                 
346:                     /* CRC Enable */
347:                     if(SYS_DMA_CHANNEL_OP_MODE_CRC & modeEnable)
9D00196C  30A50020   ANDI A1, A1, 32
9D001970  10A00005   BEQ A1, ZERO, 0x9D001988
9D001974  2402FFFF   ADDIU V0, ZERO, -1
348:                     {
349:                             PLIB_DMA_CRCEnable( DMA_ID_0);
350:                     }
351:                 
352:                 
353:                     /* Setup the DMA Trigger Source and Enable it */
354:                     if(DMA_TRIGGER_SOURCE_NONE == eventSrc)
9D001984  2402FFFF   ADDIU V0, ZERO, -1
9D001988  14C2000C   BNE A2, V0, SYS_DMA_ChannelSetup::PLIB_DMA_ChannelXStartIRQSet
9D00198C  00041180   SLL V0, A0, 6
9D001990  00042200   SLL A0, A0, 8
9D001994  00822023   SUBU A0, A0, V0
9D001998  3C02BF88   LUI V0, -16504
9D00199C  24423060   ADDIU V0, V0, 12384
9D0019A0  00822021   ADDU A0, A0, V0
9D0019A4  3C020008   LUI V0, 8
9D0019A8  AC820028   SW V0, 40(A0)
9D0019AC  3C020001   LUI V0, 1
9D0019B0  AC820028   SW V0, 40(A0)
9D0019B4  03E00008   JR RA
9D0019B8  00000000   NOP
9D0019BC  00042200   SLL A0, A0, 8
9D0019C0  00822023   SUBU A0, A0, V0
9D0019C4  3C02BF88   LUI V0, -16504
9D0019C8  24423060   ADDIU V0, V0, 12384
9D0019CC  00822021   ADDU A0, A0, V0
9D0019D0  30C600FF   ANDI A2, A2, 255
9D0019D4  A0860011   SB A2, 17(A0)
9D0019D8  24020010   ADDIU V0, ZERO, 16
9D0019DC  AC820018   SW V0, 24(A0)
9D0019E0  3C020008   LUI V0, 8
9D0019E4  AC820028   SW V0, 40(A0)
9D0019E8  3C020001   LUI V0, 1
9D0019EC  AC820028   SW V0, 40(A0)
9D0019F0  03E00008   JR RA
9D0019F4  00000000   NOP
355:                     {
356:                         /* This is polling mode of Implementation */
357:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
358:                                                             DMA_INT_BLOCK_TRANSFER_COMPLETE);
359:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
360:                                                             DMA_INT_ADDRESS_ERROR);
361:                     }
362:                     else
363:                     {
364:                         PLIB_DMA_ChannelXStartIRQSet( DMA_ID_0, channelNumber, eventSrc);
365:                         PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber, DMA_CHANNEL_TRIGGER_TRANSFER_START);
366:                 
367:                         /* We need to notify the user on the completion of a transfer request.
368:                          * Setting the DMA block completion transfer interrupt. */
369:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
370:                                                                 DMA_INT_BLOCK_TRANSFER_COMPLETE);
371:                         PLIB_DMA_ChannelXINTSourceEnable(DMA_ID_0, channelNumber,
372:                                                             DMA_INT_ADDRESS_ERROR);
373:                     }
374:                     return;
375:                 }
376:                 
377:                 
378:                 //******************************************************************************
379:                 /* Function:
380:                     void SYS_DMA_ChannelSetupMatchAbortMode
381:                     (
382:                         SYS_DMA_CHANNEL_HANDLE handle,
383:                         uint16_t pattern,
384:                         DMA_PATTERN_LENGTH length,
385:                         SYS_DMA_CHANNEL_IGNORE_MATCH ignore,
386:                         uint8_t ignorePattern
387:                     )
388:                 
389:                   Summary:
390:                     Setup the pattern match abort mode.
391:                 
392:                   Description:
393:                     This  function sets up the termination of DMA operation when the specified
394:                     pattern is matched. Additionally on supported parts the function also
395:                     sets up the ignoring of part of a pattern(8-bit) from match abort
396:                     pattern(16-bit).
397:                 
398:                 
399:                   Remarks:
400:                     The parameter 'pattern' (8-bit or 16-bit) is part specific.
401:                     (Refer the particular datasheet for details)
402:                 
403:                     Not all features are available on all micro-controllers.
404:                     Refer the particular datasheet for details)
405:                 */
406:                 
407:                 void SYS_DMA_ChannelSetupMatchAbortMode
408:                 (
409:                     SYS_DMA_CHANNEL_HANDLE handle,
410:                     uint16_t pattern,
411:                     DMA_PATTERN_LENGTH length,
412:                     SYS_DMA_CHANNEL_IGNORE_MATCH ignore,
413:                     uint8_t ignorePattern
414:                 )
415:                 {
00000000  00000000   NOP
416:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
417:                     DMA_CHANNEL channelNumber;
418:                 
419:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
420:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000004  00000000   NOP
421:                 
422:                 #if defined(PLIB_DMA_ExistsChannelXPatternLength)
423:                     if(true == PLIB_DMA_ExistsChannelXPatternLength(DMA_ID_0))
424:                     {
425:                         PLIB_DMA_ChannelXPatternLengthSet( DMA_ID_0, channelNumber, length );
426:                     }
427:                 #endif
428:                     PLIB_DMA_ChannelXPatternDataSet(DMA_ID_0, channelNumber, pattern);
429:                 
430:                 if(SYS_DMA_CHANNEL_IGNORE_MATCH_ENABLE == ignore)
431:                 {    
432:                     #if defined(PLIB_DMA_ExistsChannelXPatternIgnoreByte)    
433:                         if(true == PLIB_DMA_ExistsChannelXPatternIgnoreByte(DMA_ID_0))
434:                         {
435:                             PLIB_DMA_ChannelXPatternIgnoreByteEnable(DMA_ID_0, channelNumber);
436:                         }
437:                     #endif    
438:                 
439:                     #if defined(PLIB_DMA_ExistsChannelXPatternIgnore)    
440:                         if(true == PLIB_DMA_ExistsChannelXPatternIgnore(DMA_ID_0))
441:                         {
442:                             PLIB_DMA_ChannelXPatternIgnoreSet( DMA_ID_0, channelNumber, ignorePattern );
443:                         }
444:                     #endif
445:                 }
446:                     
447:                     return;
448:                 }
449:                 
450:                 
451:                 //******************************************************************************
452:                 /* Function:
453:                     void SYS_DMA_ChannelCRCSet
454:                     (
455:                         SYS_DMA_CHANNEL_HANDLE handle,
456:                         SYS_DMA_CHANNEL_OPERATION_MODE_CRC crc
457:                     )
458:                 
459:                   Summary:
460:                     Sets up the CRC operation mode
461:                 
462:                   Description:
463:                     This function sets up the CRC computation features.
464:                 
465:                   Remarks:
466:                     Not all features are available on all micro-controllers.
467:                 */
468:                 
469:                 void SYS_DMA_ChannelCRCSet
470:                 (
471:                     SYS_DMA_CHANNEL_HANDLE handle,
472:                     SYS_DMA_CHANNEL_OPERATION_MODE_CRC crc
473:                 )
474:                 {
00000000  00000000   NOP
475:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
476:                     DMA_CHANNEL channelNumber;
477:                 
478:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
479:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000010  00000000   NOP
480:                 
481:                 #if defined (PLIB_DMA_ExistsCRCChannel)
482:                     if(true == PLIB_DMA_ExistsCRCChannel(DMA_ID_0))
483:                     {
484:                         PLIB_DMA_CRCChannelSelect(DMA_ID_0, channelNumber);
485:                     }
486:                 #endif
487:                 
488:                 #if defined (PLIB_DMA_ExistsCRCType)
489:                     if(true == PLIB_DMA_ExistsCRCType(DMA_ID_0))
490:                     {
491:                         PLIB_DMA_CRCTypeSet(DMA_ID_0, crc.type);
492:                     }
493:                 #endif
494:                 
495:                     PLIB_DMA_CRCPolynomialLengthSet(DMA_ID_0, (crc.polyLength-1));
00000040  00000000   NOP
496:                     
497:                 #if defined (PLIB_DMA_ExistsCRCBitOrder)
498:                     if(true == PLIB_DMA_ExistsCRCBitOrder(DMA_ID_0))
499:                     {
500:                         PLIB_DMA_CRCBitOrderSelect(DMA_ID_0, crc.bitOrder);
501:                     }
502:                 #endif
503:                     
504:                 #if defined (PLIB_DMA_ExistsCRCByteOrder)
505:                     if(true == PLIB_DMA_ExistsCRCByteOrder(DMA_ID_0))
506:                     {
507:                         PLIB_DMA_CRCByteOrderSelect(DMA_ID_0, crc.byteOrder);
508:                     }
509:                 #endif
510:                 
511:                 #if defined (PLIB_DMA_ExistsCRCWriteByteOrder)
512:                     if(true == PLIB_DMA_ExistsCRCWriteByteOrder(DMA_ID_0))
513:                     {
514:                         if(SYS_DMA_CRC_WRITE_ORDER_MAINTAIN == crc.writeOrder)
00000074  00000000   NOP
515:                         {
516:                             PLIB_DMA_CRCWriteByteOrderMaintain(DMA_ID_0);
517:                         }
518:                         else if(SYS_DMA_CRC_WRITE_ORDER_CHANGE == crc.writeOrder)
00000090  00000000   NOP
519:                         {
520:                             PLIB_DMA_CRCWriteByteOrderAlter(DMA_ID_0);
521:                         }
522:                         else
523:                         {
524:                         }
525:                     }
526:                 #endif
527:                 
528:                 #if defined (PLIB_DMA_ExistsCRCData)
529:                     if(true == PLIB_DMA_ExistsCRCData(DMA_ID_0))
530:                     {
531:                         PLIB_DMA_CRCDataWrite(DMA_ID_0, crc.data);
532:                     }
533:                 #endif
534:                 
535:                 #if defined (PLIB_DMA_ExistsCRCXOREnable)
536:                     if(true == PLIB_DMA_ExistsCRCXOREnable(DMA_ID_0))
537:                     {
538:                         PLIB_DMA_CRCXOREnableSet(DMA_ID_0, crc.xorBitMask);
000000AC  00000000   NOP
539:                     }
540:                 #endif
541:                 
542:                     if(SYS_DMA_CHANNEL_CRC_MODE_APPEND == crc.mode)
000000B4  00000000   NOP
543:                     {
544:                         PLIB_DMA_CRCAppendModeEnable(DMA_ID_0);
545:                     }
546:                         return;
547:                 }
548:                 
549:                 
550:                 //******************************************************************************
551:                 /* Function:
552:                     uint32_t SYS_DMA_ChannelCRCGet(void)
553:                 
554:                   Summary:
555:                     Returns the computed CRC
556:                 
557:                   Description:
558:                     This  function returns the computed CRC
559:                 
560:                   Remarks:
561:                     To get the computed CRC value this function must be called after the block
562:                     transfer completion event. ie After getting and processing the callback
563:                     registered with SYS_DMA_ChannelTransferEventHandlerSet.
564:                 
565:                     Not all features are available on all micro-controllers.
566:                 */
567:                 
568:                 uint32_t SYS_DMA_ChannelCRCGet(void)
569:                 {
570:                     uint32_t crcData = 0;
571:                 
572:                 #if defined (PLIB_DMA_ExistsCRCData)
573:                     if(true == PLIB_DMA_ExistsCRCData(DMA_ID_0))
574:                     {
575:                         crcData = PLIB_DMA_CRCDataRead(DMA_ID_0);
576:                     }
577:                 #endif
578:                     return crcData;
579:                 }
0000000C  00000000   NOP
580:                 
581:                 
582:                 //******************************************************************************
583:                 /* Function:
584:                     void SYS_DMA_ChannelEnable(SYS_DMA_CHANNEL_HANDLE handle)
585:                 
586:                   Summary:
587:                     Enables a channel.
588:                 
589:                   Description:
590:                     This function enables a channel.
591:                 
592:                   Remarks:
593:                         This function may not required to be called when starting DMA setup
594:                         (by SYS_DMA_ChannelSetup) and transfer Add (by SYS_DMA_ChannelTransferAdd).
595:                         But may be needed to be called in the registered callback to enable the
596:                         channel and continue the data transfer with the existing transfer parameters
597:                         previously set with 'SYS_DMA_ChannelTransferAdd'.
598:                         The DMA channel is by default disabled on the completion of block
599:                         transfer(callback generated)
600:                 */
601:                 
602:                 void SYS_DMA_ChannelEnable(SYS_DMA_CHANNEL_HANDLE handle)
603:                 {
604:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
605:                     DMA_CHANNEL channelNumber;
606:                 
607:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
608:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
609:                 
610:                     PLIB_DMA_ChannelXEnable(DMA_ID_0, channelNumber);
611:                 
612:                     return;
613:                 }
614:                 
615:                 
616:                 //******************************************************************************
617:                 /* Function:
618:                     void SYS_DMA_ChannelDisable(SYS_DMA_CHANNEL_HANDLE handle)
619:                 
620:                   Summary:
621:                     Disables a channel.
622:                 
623:                   Description:
624:                     This function disables a channel.
625:                 
626:                   Remarks:
627:                     None.
628:                 */
629:                 
630:                 void SYS_DMA_ChannelDisable(SYS_DMA_CHANNEL_HANDLE handle)
631:                 {
632:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
633:                     DMA_CHANNEL channelNumber;
634:                 
635:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
636:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000000  00000000   NOP
637:                 
638:                     PLIB_DMA_ChannelXDisable(DMA_ID_0, channelNumber);
639:                 
640:                     return;
641:                 }
642:                 
643:                 
644:                 //******************************************************************************
645:                 /* Function:
646:                     void SYS_DMA_ChannelTransferAdd
647:                     (
648:                         SYS_DMA_CHANNEL_HANDLE handle,
649:                         const void *srcAddr, size_t srcSize
650:                         const void *destAddr, size_t destSize,
651:                         size_t cellSize
652:                     )
653:                 
654:                   Summary:
655:                     Adds a data transfer to a DMA channel and Enables the channel to start
656:                     data transfer.
657:                 
658:                   Description:
659:                     This function adds a data transfer characteristics for a DMA channel. The
660:                     The source and the destination addresses, source and destination lengths,
661:                     The number of bytes transferred per cell event are set. It also enables
662:                     the channel to start data transfer.
663:                 
664:                     If the requesting client registered an event callback with the service,
665:                     the service will issue a SYS_DMA_TRANSFER_EVENT_COMPLETE or
666:                     SYS_DMA_TRANSFER_EVENT_ABORT  event if the transfered was processed
667:                     successfully of SYS_DMA_TRANSFER_EVENT_ERROR event if the transfer was not
668:                     processed successfully.
669:                 
670:                   Remarks:
671:                     None.
672:                 */
673:                 void SYS_DMA_ChannelTransferAdd
674:                 (
675:                     SYS_DMA_CHANNEL_HANDLE handle,
676:                     const void *srcAddr, size_t srcSize,
677:                     const void *destAddr, size_t destSize,
678:                     size_t cellSize
679:                 )
680:                 {
681:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
682:                     DMA_CHANNEL channelNumber;
683:                 
684:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
685:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
9D0019F8  3C02A000   LUI V0, -24576
9D0019FC  2442080C   ADDIU V0, V0, 2060
9D001A00  00822023   SUBU A0, A0, V0
9D001A04  00042103   SRA A0, A0, 4
9D001A08  00044180   SLL T0, A0, 6
9D001A0C  00041200   SLL V0, A0, 8
9D001A10  00481023   SUBU V0, V0, T0
9D001A14  3C08BF88   LUI T0, -16504
9D001A18  25083060   ADDIU T0, T0, 12384
9D001A1C  00481021   ADDU V0, V0, T0
9D001A20  00052742   SRL A0, A1, 29
9D001A24  24080006   ADDIU T0, ZERO, 6
9D001A28  1488000E   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A2C  00A01821   ADDU V1, A1, ZERO
9D001A30  00052702   SRL A0, A1, 28
9D001A34  2408000C   ADDIU T0, ZERO, 12
9D001A38  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A3C  2408000D   ADDIU T0, ZERO, 13
9D001A40  7CA5D800   EXT A1, A1, 0, 28
9D001A44  3C032000   LUI V1, 8192
9D001A48  0B4006A8   J 0x9D001AA0
9D001A4C  00A31825   OR V1, A1, V1
9D001A50  14880013   BNE A0, T0, 0x9D001AA0
9D001A54  7CA5D800   EXT A1, A1, 0, 28
9D001A58  3C033000   LUI V1, 12288
9D001A5C  0B4006A8   J 0x9D001AA0
9D001A60  00A31825   OR V1, A1, V1
9D001A64  24080007   ADDIU T0, ZERO, 7
9D001A68  5488000D   BNEL A0, T0, 0x9D001AA0
9D001A6C  7CA3E000   EXT V1, A1, 0, 29
9D001A70  00052702   SRL A0, A1, 28
9D001A74  2408000E   ADDIU T0, ZERO, 14
9D001A78  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A7C  2408000F   ADDIU T0, ZERO, 15
9D001A80  7CA5D800   EXT A1, A1, 0, 28
9D001A84  3C032000   LUI V1, 8192
9D001A88  0B4006A8   J 0x9D001AA0
9D001A8C  00A31825   OR V1, A1, V1
9D001A90  14880003   BNE A0, T0, 0x9D001AA0
9D001A94  7CA5D800   EXT A1, A1, 0, 28
9D001A98  3C033000   LUI V1, 12288
9D001A9C  00A31825   OR V1, A1, V1
9D001AA0  AC430030   SW V1, 48(V0)
9D001AA4  30C6FFFF   ANDI A2, A2, -1
9D001AA8  AC460050   SW A2, 80(V0)
9D001AAC  00072742   SRL A0, A3, 29
9D001AB0  24050006   ADDIU A1, ZERO, 6
9D001AB4  1485000E   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001AB8  00E01821   ADDU V1, A3, ZERO
9D001ABC  00072702   SRL A0, A3, 28
9D001AC0  2405000C   ADDIU A1, ZERO, 12
9D001AC4  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001AC8  2405000D   ADDIU A1, ZERO, 13
9D001ACC  7CE7D800   EXT A3, A3, 0, 28
9D001AD0  3C032000   LUI V1, 8192
9D001AD4  0B4006CC   J 0x9D001B30
9D001AD8  00E31825   OR V1, A3, V1
9D001ADC  14850014   BNE A0, A1, 0x9D001B30
9D001AE0  7CE7D800   EXT A3, A3, 0, 28
9D001AE4  3C033000   LUI V1, 12288
9D001AE8  0B4006CC   J 0x9D001B30
9D001AEC  00E31825   OR V1, A3, V1
9D001AF0  24050007   ADDIU A1, ZERO, 7
9D001AF4  5485000E   BNEL A0, A1, 0x9D001B30
9D001AF8  7CE3E000   EXT V1, A3, 0, 29
9D001AFC  00072702   SRL A0, A3, 28
9D001B00  2405000E   ADDIU A1, ZERO, 14
9D001B04  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001B08  2405000F   ADDIU A1, ZERO, 15
9D001B0C  7CE7D800   EXT A3, A3, 0, 28
9D001B10  3C032000   LUI V1, 8192
9D001B14  0B4006CC   J 0x9D001B30
9D001B18  00E31825   OR V1, A3, V1
9D001B1C  14850004   BNE A0, A1, 0x9D001B30
9D001B20  00000000   NOP
9D001B24  7CE7D800   EXT A3, A3, 0, 28
9D001B28  3C033000   LUI V1, 12288
9D001B2C  00E31825   OR V1, A3, V1
9D001B30  AC430040   SW V1, 64(V0)
9D001B34  97A30010   LHU V1, 16(SP)
9D001B38  AC430060   SW V1, 96(V0)
9D001B3C  97A30014   LHU V1, 20(SP)
9D001B40  AC430090   SW V1, 144(V0)
9D001B44  24030080   ADDIU V1, ZERO, 128
9D001B48  AC430008   SW V1, 8(V0)
9D001B4C  03E00008   JR RA
9D001B50  00000000   NOP
686:                 
687:                     /* Set the transfer paramteters */
688:                     PLIB_DMA_ChannelXSourceStartAddressSet(DMA_ID_0, channelNumber, (uint32_t) srcAddr);
689:                     PLIB_DMA_ChannelXSourceSizeSet(DMA_ID_0, channelNumber, (uint16_t) srcSize);
690:                     PLIB_DMA_ChannelXDestinationStartAddressSet(DMA_ID_0, channelNumber,(uint32_t) destAddr);
691:                     PLIB_DMA_ChannelXDestinationSizeSet(DMA_ID_0, channelNumber, (uint16_t) destSize);
692:                     PLIB_DMA_ChannelXCellSizeSet(DMA_ID_0, channelNumber,(uint16_t) cellSize);
693:                 
694:                     /* Enable the channel */
695:                     PLIB_DMA_ChannelXEnable(DMA_ID_0, channelNumber);
696:                     return;
697:                 }
698:                 
699:                 //******************************************************************************
700:                 /* Function:
701:                     void SYS_DMA_ChannelTransferSet
702:                     (
703:                         SYS_DMA_CHANNEL_HANDLE handle,
704:                         const void *srcAddr, size_t srcSize
705:                         const void *destAddr, size_t destSize,
706:                         size_t cellSize
707:                     )
708:                 
709:                   Summary:
710:                     Sets up a data transfer to a DMA channel.
711:                 
712:                   Description:
713:                     This function sets up data transfer characteristics for a DMA channel. The
714:                     The source and the destination addresses, source and destination lengths,
715:                     The number of bytes transferred per cell event are set.
716:                     This function does not enables the DMA channel. The channel has to be explicitly
717:                     enabled to start the data transfer.
718:                     The above functions could be used in situations where in the user intends to
719:                     setup transfer parameters but do not intend to enable the channel immediately.
720:                     For example to chain to DMA channels in a cyclic order where the channels remains
721:                     disabled. The channel is enabled automatically by the DMA when the transfer trigger
722:                     condition occurs.
723:                 
724:                   Remarks:
725:                     None.
726:                 */
727:                 void SYS_DMA_ChannelTransferSet
728:                 (
729:                     SYS_DMA_CHANNEL_HANDLE handle,
730:                     const void *srcAddr, size_t srcSize,
731:                     const void *destAddr, size_t destSize,
732:                     size_t cellSize
733:                 )
734:                 {
735:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
736:                     DMA_CHANNEL channelNumber;
737:                 
738:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
739:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
740:                 
741:                     /* Set the transfer parameters */
742:                     PLIB_DMA_ChannelXSourceStartAddressSet(DMA_ID_0, channelNumber, (uint32_t) srcAddr);
743:                     PLIB_DMA_ChannelXSourceSizeSet(DMA_ID_0, channelNumber, (uint16_t) srcSize);
744:                     PLIB_DMA_ChannelXDestinationStartAddressSet(DMA_ID_0, channelNumber,(uint32_t) destAddr);
745:                     PLIB_DMA_ChannelXDestinationSizeSet(DMA_ID_0, channelNumber, (uint16_t) destSize);
746:                     PLIB_DMA_ChannelXCellSizeSet(DMA_ID_0, channelNumber,(uint16_t) cellSize);
747:                 
748:                     return;
749:                 }
750:                 
751:                 //******************************************************************************
752:                 /* Function:
753:                     size_t SYS_DMA_ChannelSourceTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
754:                 
755:                   Summary:
756:                     Returns the number of bytes transferred from source.
757:                 
758:                   Description:
759:                     When a data transfer request is submitted. At any time while the transmission
760:                     is in progress the size of the amount of data transferred from source
761:                     can be known by calling this function.
762:                 
763:                   Remarks:
764:                     None.
765:                 */
766:                 size_t SYS_DMA_ChannelSourceTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
767:                 {
768:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
769:                     DMA_CHANNEL channelNumber;
770:                 
771:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
772:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000000  00000000   NOP
773:                     return (size_t) PLIB_DMA_ChannelXSourcePointerGet(DMA_ID_0,channelNumber);
774:                 }
0000002C  00000000   NOP
775:                 
776:                 //******************************************************************************
777:                 /* Function:
778:                     size_t SYS_DMA_ChannelDestinationTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
779:                 
780:                   Summary:
781:                     Returns the number of bytes transferred to destination.
782:                 
783:                   Description:
784:                     When a data transfer request is submitted. At any time while the transmission
785:                     is in progress the size of the amount of data transferred to destination
786:                     can be known by calling this function.
787:                 
788:                   Remarks:
789:                     None.
790:                 */
791:                 size_t SYS_DMA_ChannelDestinationTransferredSizeGet(SYS_DMA_CHANNEL_HANDLE handle)
792:                 {
793:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
794:                     DMA_CHANNEL channelNumber;
795:                 
796:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
797:                     channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000000  00000000   NOP
798:                     return (size_t) PLIB_DMA_ChannelXDestinationPointerGet(DMA_ID_0,channelNumber);
799:                 }
0000002C  00000000   NOP
800:                 
801:                 /******************************************************************************
802:                   Function:
803:                     void SYS_DMA_ChannelTransferEventHandlerSet
804:                     (
805:                         SYS_DMA_CHANNEL_HANDLE handle,
806:                         const SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER eventHandler,
807:                         const uintptr_t contextHandle
808:                     )
809:                 
810:                   Summary:
811:                     This function allows a DMA system service client to set an event handler.
812:                 
813:                   Description:
814:                     This function allows a client to set an event handler. The client may want
815:                     to receive transfer related events in cases when it uses non-blocking read and
816:                     write functions. The event handler should be set before the client
817:                     intends to perform operations that could generate events.
818:                 
819:                     This function accepts a contextHandle parameter. This parameter could be
820:                     set by the client to contain (or point to) any client specific data object
821:                     that should be associated with this DMA channel.
822:                 
823:                   Remarks:
824:                     None.
825:                  */
826:                 void SYS_DMA_ChannelTransferEventHandlerSet
827:                 (
828:                     SYS_DMA_CHANNEL_HANDLE handle,
829:                     const SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER eventHandler,
830:                     const uintptr_t contextHandle
831:                 )
832:                 {
833:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
834:                     chanObj = (SYS_DMA_CHANNEL_OBJECT *)handle;
835:                 
836:                     if (chanObj == (SYS_DMA_CHANNEL_OBJECT *) NULL ||
9D003854  10800005   BEQ A0, ZERO, 0x9D00386C
9D003858  00000000   NOP
9D00385C  10A00003   BEQ A1, ZERO, 0x9D00386C
9D003860  00000000   NOP
837:                         eventHandler == (SYS_DMA_CHANNEL_TRANSFER_EVENT_HANDLER) NULL)
838:                     {
839:                         SYS_ASSERT(false, "Invalid handle");
840:                         return;
841:                     }
842:                     else
843:                     {
844:                         /* Set the Event Handler and context */
845:                         chanObj->pEventCallBack = eventHandler;
9D003864  AC850008   SW A1, 8(A0)
846:                         chanObj->hClientArg = contextHandle;
9D003868  AC86000C   SW A2, 12(A0)
9D00386C  03E00008   JR RA
9D003870  00000000   NOP
847:                     }
848:                     return;
849:                 }
850:                 
851:                 
852:                 /*******************************************************************************
853:                   Function:
854:                     void SYS_DMA_Tasks(SYS_MODULE_OBJ object );
855:                 
856:                   Summary:
857:                     Maintains the system service's state machine.
858:                 
859:                   Description:
860:                     This routine is used to maintain the DMA system service's internal state machine.
861:                     This function is specifically designed for non DMA interrupt trigger
862:                     implementations(polling mode), and should be used only in polling mode.
863:                     this function should be called from the SYS_Tasks() function.
864:                 
865:                   Remarks:
866:                     This routine is normally not called directly by an application.  It is
867:                     called by the system's Tasks routine (SYS_Tasks).
868:                  
869:                     This function is deprecated. Any calls made to this functions will have no effect.
870:                  */
871:                 
872:                 void SYS_DMA_Tasks(SYS_MODULE_OBJ object)
873:                 {
00000000  00000000   NOP
874:                     return;
875:                 }
876:                 
877:                 
878:                 /*******************************************************************************
879:                   Function:
880:                     void SYS_DMA_TasksISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
881:                 
882:                   Summary:
883:                     Maintains the system service's state machine and implements its ISR
884:                 
885:                   Description:
886:                     This routine is used to maintain the DMA system service's internal state machine
887:                     and implement its ISR for DMA interrupt trigger implementations(interrupt mode).
888:                     This function is specifically designed for DMA interrupt trigger
889:                     implementations (interrupt mode).
890:                     In interrupt mode, this function should be called in the interrupt
891:                     service routine of the DMA channel that is associated with this transfer.
892:                 
893:                   Remarks:
894:                     It is called by appropriate raw ISR.
895:                 
896:                     This routine may execute in an ISR context and will never block or access any
897:                     resources that may cause it to block.
898:                  */
899:                 void SYS_DMA_TasksISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
900:                 {
9D00261C  27BDFFE8   ADDIU SP, SP, -24
9D002620  AFBF0014   SW RA, 20(SP)
901:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
902:                     DMA_CHANNEL_INT_SOURCE chanIntSrc;
903:                 
904:                     /* Find out the interrupt source number for the active DMA channel */
905:                      chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, activeChannel);
906:                 
907:                     /* Check whether the active DMA channel interrupt has occurred */
908:                    // if(true == SYS_INT_SourceStatusGet(chanIntSrc))
909:                    // {
910:                         if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
9D002648  10800017   BEQ A0, ZERO, SYS_DMA_TasksISR::PLIB_DMA_ChannelXINTSourceFlagGet
9D00264C  24040008   ADDIU A0, ZERO, 8
911:                                         DMA_INT_BLOCK_TRANSFER_COMPLETE))
912:                         {
913:                             /* Channel is by default disabled on completion of a block transfer */
914:                 
915:                             /* Clear the Block transfer complete flag */
916:                             PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
917:                                      DMA_INT_BLOCK_TRANSFER_COMPLETE);
918:                 
919:                             SYS_INT_SourceStatusClear(chanIntSrc);
920:                 
921:                             /* Find out the channel object and give a callback */
922:                             chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
9D002674  00052900   SLL A1, A1, 4
9D002678  3C02A000   LUI V0, -24576
9D00267C  2442080C   ADDIU V0, V0, 2060
9D002680  00451021   ADDU V0, V0, A1
923:                             chanObj->errorInfo = SYS_DMA_ERROR_NONE;
9D002684  AC440004   SW A0, 4(V0)
924:                 			if(NULL != chanObj->pEventCallBack)
9D002688  8C430008   LW V1, 8(V0)
9D00268C  1060001E   BEQ V1, ZERO, 0x9D002708
9D002690  00002021   ADDU A0, ZERO, ZERO
925:                 			{
926:                 	            chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_COMPLETE,
9D002694  00402821   ADDU A1, V0, ZERO
9D002698  0060F809   JALR V1
9D00269C  8C46000C   LW A2, 12(V0)
927:                                          (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
928:                 			}
929:                 
930:                         }
931:                         else if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
9D0026B0  10800015   BEQ A0, ZERO, 0x9D002708
9D0026B4  24040002   ADDIU A0, ZERO, 2
932:                                         DMA_INT_TRANSFER_ABORT))
933:                         {
934:                             /* Channel is by default disabled on Transfer Abortion */
935:                 
936:                             /* Clear the Abort transfer complete flag */
937:                             PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
938:                                         DMA_INT_TRANSFER_ABORT);
939:                 
940:                             SYS_INT_SourceStatusClear(chanIntSrc);
941:                 
942:                             /* Find out the channel object and give a callback */
943:                             chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
9D0026DC  00052900   SLL A1, A1, 4
9D0026E0  3C02A000   LUI V0, -24576
9D0026E4  2442080C   ADDIU V0, V0, 2060
9D0026E8  00451021   ADDU V0, V0, A1
944:                             chanObj->errorInfo = SYS_DMA_ERROR_NONE;
9D0026EC  AC440004   SW A0, 4(V0)
945:                 			if(NULL != chanObj->pEventCallBack)
9D0026F0  8C430008   LW V1, 8(V0)
9D0026F4  10600004   BEQ V1, ZERO, 0x9D002708
9D0026F8  24040002   ADDIU A0, ZERO, 2
946:                 			{
947:                 	            chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ABORT,
9D0026FC  00402821   ADDU A1, V0, ZERO
9D002700  0060F809   JALR V1
9D002704  8C46000C   LW A2, 12(V0)
948:                                         (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
949:                 			}
950:                         }
951:                         else
952:                         {
953:                             ;
954:                         }
955:                   //  }
956:                     return;
957:                 }
9D0026A0  0B4009C3   J 0x9D00270C
9D0026A4  8FBF0014   LW RA, 20(SP)
9D002708  8FBF0014   LW RA, 20(SP)
9D00270C  03E00008   JR RA
9D002710  27BD0018   ADDIU SP, SP, 24
958:                 
959:                 /*****************************************************************************
960:                   Function:
961:                     void SYS_DMA_TasksError(SYS_MODULE_OBJ object );
962:                 
963:                   Summary:
964:                     Maintains the system service's error state machine.
965:                 
966:                   Description:
967:                     This routine is used to maintain the DMA system service's error state machine.
968:                 	This function is specifically designed for non DMA interrupt trigger
969:                     implementations(polling mode), and should be used only in polling mode.
970:                     this function should be called from the SYS_Tasks() function.
971:                 
972:                   Remarks:
973:                     This routine is normally not called directly by an application.  It is
974:                     called by the system's Tasks routine (SYS_Tasks).
975:                 
976:                  */
977:                 
978:                 void SYS_DMA_TasksError(SYS_MODULE_OBJ object)
979:                 {
00000000  00000000   NOP
0000002C  00000000   NOP
980:                     SYS_DMA_CHANNEL_OBJECT *chanObj;
981:                     DMA_CHANNEL channels;
982:                     DMA_CHANNEL_INT_SOURCE chanIntSrc;
983:                 
984:                     /* Go through each DMA channel and service it */
985:                     for (channels = DMA_CHANNEL_0; channels < DMA_NUMBER_OF_CHANNELS; channels++)
00000048  00000000   NOP
000000B0  00000000   NOP
986:                     {
987:                 		/* Find out the interrupt source number for the last active DMA channel */
988:                 		chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, channels);
989:                 
990:                 		/* Check whether the active DMA channel interrupt has occured */
991:                 		if(true == SYS_INT_SourceStatusGet(chanIntSrc))
00000068  00000000   NOP
992:                 		{
993:                 			if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,channels,
00000078  00000000   NOP
994:                 						DMA_INT_ADDRESS_ERROR))
995:                 			{
996:                 				/* Channel is by default disabled on completion of a block transfer */
997:                 
998:                 				/* Clear the Block transfer complete flag */
999:                 				PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,channels,
1000:                						DMA_INT_ADDRESS_ERROR);
1001:                
1002:                				SYS_INT_SourceStatusClear(chanIntSrc);
1003:                
1004:                				/* Find out the channel object and give a callback */
1005:                				chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[channels];
1006:                				chanObj->errorInfo = SYS_DMA_ERROR_ADDRESS_ERROR;
00000044  00000000   NOP
0000008C  00000000   NOP
1007:                                if(NULL != chanObj->pEventCallBack)
00000090  00000000   NOP
1008:                                {                
1009:                                    chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ERROR,
0000009C  00000000   NOP
1010:                						(SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
1011:                                }
1012:                			}
1013:                		}
1014:                	}
1015:                    return;
1016:                }
000000B8  00000000   NOP
1017:                
1018:                
1019:                /*******************************************************************************
1020:                  Function:
1021:                    void SYS_DMA_TasksErrorISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
1022:                
1023:                  Summary:
1024:                    Maintains the system service's state machine and implements its ISR
1025:                
1026:                  Description:
1027:                    This routine is used to maintain the DMA system service's internal error state machine
1028:                    and implement its ISR for DMA interrupt trigger implementations(interrupt mode).
1029:                    This function is specifically designed for DMA interrupt trigger
1030:                    implementations (interrupt mode).
1031:                    In interrupt mode, this function should be called in the interrupt
1032:                    service routine of the DMA channel that is associated with this transfer.
1033:                
1034:                  Remarks:
1035:                    It is called by appropriate raw ISR.
1036:                
1037:                    This routine may execute in an ISR context and will never block or access any
1038:                    resources that may cause it to block.
1039:                 */
1040:                void SYS_DMA_TasksErrorISR(SYS_MODULE_OBJ object, DMA_CHANNEL activeChannel)
1041:                {
00000088  00000000   NOP
1042:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1043:                    DMA_CHANNEL_INT_SOURCE chanIntSrc;
1044:                
1045:                    /* Find out the interrupt source number for the last active DMA channel */
1046:                    chanIntSrc = PLIB_DMA_ChannelXTriggerSourceNumberGet(DMA_ID_0, activeChannel);
1047:                
1048:                    /* Check whether the active DMA channel interrupt has occured */
1049:                    if(true == SYS_INT_SourceStatusGet(chanIntSrc))
00000028  00000000   NOP
1050:                    {
1051:                        if(true == PLIB_DMA_ChannelXINTSourceFlagGet(DMA_ID_0,activeChannel,
0000004C  00000000   NOP
1052:                                    DMA_INT_ADDRESS_ERROR))
1053:                        {
1054:                            /* Channel is by default disabled on completion of a block transfer */
1055:                
1056:                            /* Clear the Block transfer complete flag */
1057:                            PLIB_DMA_ChannelXINTSourceFlagClear(DMA_ID_0,activeChannel,
1058:                                    DMA_INT_ADDRESS_ERROR);
1059:                
1060:                            SYS_INT_SourceStatusClear(chanIntSrc);
1061:                
1062:                            /* Find out the channel object and give a callback */
1063:                            chanObj = (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[activeChannel];
00000064  00000000   NOP
1064:                            chanObj->errorInfo = SYS_DMA_ERROR_ADDRESS_ERROR;
00000074  00000000   NOP
1065:                			if(NULL != chanObj->pEventCallBack)
0000007C  00000000   NOP
1066:                			{            
1067:                                chanObj->pEventCallBack(SYS_DMA_TRANSFER_EVENT_ERROR,
00000090  00000000   NOP
1068:                                        (SYS_DMA_CHANNEL_HANDLE)chanObj,chanObj->hClientArg);
1069:                            }
1070:                        }
1071:                    }
1072:                    return;
1073:                }
0000009C  00000000   NOP
1074:                
1075:                // *****************************************************************************
1076:                /* Function:
1077:                    SYS_DMA_ERROR SYS_DMA_ChannelErrorGet(SYS_DMA_CHANNEL_HANDLE handle)
1078:                
1079:                  Summary:
1080:                    This function returns the error(if any) associated with the last client
1081:                    request.
1082:                
1083:                  Description:
1084:                    This function returns the error(if any) associated with the last client
1085:                    request. If the service send a SYS_DMA_TRANSFER_EVENT_ERROR to the client,
1086:                    the client can call this function to know the error cause.
1087:                    The error status will be updated on every operation and should be read
1088:                    frequently (ideally immediately after the service operation has completed)
1089:                    to know the relevant error status.
1090:                
1091:                  Remarks:
1092:                    It is the client's reponsibility to make sure that the error status is
1093:                    obtained frequently. The service will update the error status
1094:                    irrespective of whether this has been examined by the client.
1095:                */
1096:                
1097:                SYS_DMA_ERROR SYS_DMA_ChannelErrorGet(SYS_DMA_CHANNEL_HANDLE handle)
1098:                {
1099:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1100:                
1101:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1102:                    return chanObj->errorInfo;
1103:                }
1104:                
1105:                
1106:                //******************************************************************************
1107:                /* Function:
1108:                    void SYS_DMA_ChannelForceStart(SYS_DMA_CHANNEL_HANDLE handle)
1109:                
1110:                  Summary:
1111:                    Force start of transfer on the selected channel
1112:                
1113:                  Description:
1114:                    The function force start a DMA transfer to occur for the selected channel.
1115:                
1116:                  Remarks:
1117:                   This function must be used to start the DMA transfer when the channel has been
1118:                   setup(by calling SYS_DMA_ChannelSetup) with the eventSrc as DMA_TRIGGER_SOURCE_NONE.
1119:                */
1120:                
1121:                void SYS_DMA_ChannelForceStart(SYS_DMA_CHANNEL_HANDLE handle)
1122:                {
1123:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1124:                    DMA_CHANNEL channelNumber;
1125:                
1126:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1127:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
1128:                
1129:                    PLIB_DMA_StartTransferSet(DMA_ID_0, channelNumber);
1130:                
1131:                    return;
1132:                }
1133:                
1134:                //******************************************************************************
1135:                /* Function:
1136:                    void SYS_DMA_ChannelForceAbort(SYS_DMA_CHANNEL_HANDLE handle)
1137:                
1138:                  Summary:
1139:                    Force abort of transfer on the selected channel
1140:                
1141:                  Description:
1142:                    The function abort a DMA transfer to occur for the selected channel.
1143:                
1144:                  Remarks:
1145:                   This function must be used to abort the DMA transfer when the channel has been
1146:                   setup(by calling SYS_DMA_ChannelSetup) with the eventSrc as DMA_TRIGGER_SOURCE_NONE.
1147:                   and SYS_DMA_ChannelAbortEventSet has not been called.
1148:                */
1149:                
1150:                void SYS_DMA_ChannelForceAbort(SYS_DMA_CHANNEL_HANDLE handle)
1151:                {
1152:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1153:                    DMA_CHANNEL channelNumber;
1154:                
1155:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1156:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
1157:                
1158:                    PLIB_DMA_AbortTransferSet(DMA_ID_0, channelNumber);
1159:                
1160:                    return;
1161:                }
1162:                
1163:                
1164:                //******************************************************************************
1165:                /* Function:
1166:                    void SYS_DMA_ChannelAbortEventSet(SYS_DMA_CHANNEL_HANDLE handle,
1167:                                                        DMA_TRIGGER_SOURCE eventSrc)
1168:                
1169:                  Summary:
1170:                    Sets an event source and enables cell transfer abort event for the same
1171:                    for the selected channel.
1172:                
1173:                  Description:
1174:                    This functions enables a cell transfer abort event for the selected source
1175:                    event.
1176:                
1177:                  Remarks:
1178:                    If the parameter 'eventSrc' is specified as DMA_TRIGGER_SOURCE_NONE the
1179:                    current DMA transfer will be aborted. The behavior is a same as calling
1180:                    SYS_DMA_ChannelForceAbort.
1181:                
1182:                */
1183:                
1184:                void SYS_DMA_ChannelAbortEventSet(SYS_DMA_CHANNEL_HANDLE handle,
1185:                                                    DMA_TRIGGER_SOURCE eventSrc)
1186:                {
1187:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1188:                    DMA_CHANNEL channelNumber;
1189:                
1190:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1191:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000000  00000000   NOP
1192:                
1193:                    /* Setup the DMA Trigger Abort Source and Enable it */
1194:                    if(DMA_TRIGGER_SOURCE_NONE == eventSrc)
0000000C  00000000   NOP
1195:                    {
1196:                        PLIB_DMA_AbortTransferSet(DMA_ID_0, channelNumber);
1197:                    }
1198:                    else
1199:                    {
1200:                        PLIB_DMA_ChannelXAbortIRQSet( DMA_ID_0, channelNumber, eventSrc);
1201:                        PLIB_DMA_ChannelXTriggerEnable( DMA_ID_0, channelNumber, DMA_CHANNEL_TRIGGER_TRANSFER_ABORT);
1202:                    }
1203:                    return;
1204:                }
1205:                
1206:                
1207:                //******************************************************************************
1208:                /* Function:
1209:                    bool SYS_DMA_ChannelIsBusy(SYS_DMA_CHANNEL_HANDLE handle)
1210:                
1211:                  Summary:
1212:                    Returns the busy status of the specified DMA channel
1213:                
1214:                  Description:
1215:                    This function returns the busy status of the selected DMA channel
1216:                
1217:                  Remarks:
1218:                    Not all features are available on all micro-controllers.
1219:                */
1220:                
1221:                bool SYS_DMA_ChannelIsBusy(SYS_DMA_CHANNEL_HANDLE handle)
1222:                {
1223:                    bool isBusy;
1224:                    SYS_DMA_CHANNEL_OBJECT *chanObj;
1225:                    DMA_CHANNEL channelNumber;
1226:                
1227:                    chanObj = (SYS_DMA_CHANNEL_OBJECT *) handle;
1228:                    channelNumber = (chanObj  - (SYS_DMA_CHANNEL_OBJECT *) &gSysDMAChannelObj[0]);
00000000  00000000   NOP
1229:                    isBusy = false;
1230:                
1231:                #if defined(PLIB_DMA_ExistsChannelXBusy)
1232:                    if(true == PLIB_DMA_ExistsChannelXBusy(DMA_ID_0))
1233:                    {
1234:                        if(true == PLIB_DMA_ChannelXBusyIsBusy( DMA_ID_0, channelNumber))
1235:                        {
1236:                            isBusy = true;
1237:                        }
1238:                    }
1239:                #endif
1240:                    return isBusy;
1241:                }
0000002C  00000000   NOP
1242:                
1243:                
1244:                // *****************************************************************************
1245:                // *****************************************************************************
1246:                // Section: Global DMA Management Routines
1247:                // *****************************************************************************
1248:                // *****************************************************************************
1249:                //******************************************************************************
1250:                //******************************************************************************
1251:                /* Function:
1252:                    void SYS_DMA_Suspend(void)
1253:                
1254:                  Summary:
1255:                    Suspend DMA transfers.
1256:                
1257:                  Description:
1258:                    This function suspends DMA transfers to allow CPU uninterrupted access
1259:                    to data bus
1260:                
1261:                  Remarks:
1262:                    None
1263:                */
1264:                
1265:                void SYS_DMA_Suspend(void)
1266:                {
1267:                    PLIB_DMA_SuspendEnable(DMA_ID_0);
1268:                    return;
1269:                }
1270:                
1271:                //******************************************************************************
1272:                /* Function:
1273:                    void SYS_DMA_Resume(void)
1274:                
1275:                  Summary:
1276:                    Resume DMA operations
1277:                
1278:                  Description:
1279:                    This function disables DMA suspend. It resumes the DMA operation suspended
1280:                    by calling SYS_DMA_Suspend. The DMA operates normally.
1281:                
1282:                  Remarks:
1283:                    None
1284:                */
1285:                void SYS_DMA_Resume(void)
1286:                {
1287:                    PLIB_DMA_SuspendDisable(DMA_ID_0);
1288:                    return;
1289:                }
1290:                
1291:                
1292:                //******************************************************************************
1293:                /* Function:
1294:                    bool SYS_DMA_IsBusy(void)
1295:                
1296:                  Summary:
1297:                    Returns the busy status of the DMA module
1298:                
1299:                  Description:
1300:                    This function returns the busy status of the DMA module
1301:                
1302:                  Remarks:
1303:                    Not all features are available on all micro-controllers.
1304:                */
1305:                bool SYS_DMA_IsBusy(void)
1306:                {
1307:                #if defined(PLIB_DMA_ExistsBusy)
1308:                    if(true == PLIB_DMA_ExistsBusy(DMA_ID_0))
1309:                    {
1310:                        return PLIB_DMA_IsBusy(DMA_ID_0);
1311:                    }
1312:                #endif
1313:                    return false;  // added this line to avoid compiler warning
1314:                }
00000008  00000000   NOP
1315:                
1316:                /*******************************************************************************
1317:                 End of File
1318:                */
1319:                
1320:                
1321:                
---  c:/microchip/harmony/v2_01b/framework/system/devcon/src/sys_devcon_pic32mx.c  ----------------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/osc/plib_osc.h"
55:                  #include "peripheral/pcache/plib_pcache.h"
56:                  #include "peripheral/bmx/plib_bmx.h"
57:                  
58:                  // *****************************************************************************
59:                  // *****************************************************************************
60:                  // Section: File Scope or Global Constants
61:                  // *****************************************************************************
62:                  // *****************************************************************************
63:                  
64:                  // *****************************************************************************
65:                  // *****************************************************************************
66:                  // Section: Variable Definitions
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  //
70:                  #ifndef PLIB_PCACHE_PREFETCH_ENABLE_ALL
71:                  #define PLIB_PCACHE_PREFETCH_ENABLE_ALL 3
72:                  #endif
73:                  
74:                  // *****************************************************************************
75:                  /* Function:
76:                      void SYS_DEVCON_PerformanceConfig( void )
77:                  
78:                    Summary:
79:                      Configures the PFM wait states and prefetch (cache) module for maximum 
80:                      performance.
81:                  
82:                    Description:
83:                      This function configures the PFM wait states and prefetch (cache) module 
84:                      for maximum performance.
85:                  
86:                    Remarks:
87:                      None.
88:                  */
89:                  
90:                  void __attribute__((nomips16)) SYS_DEVCON_PerformanceConfig( unsigned int sysclk )
91:                  {
9D0032C8  27BDFFF8   ADDIU SP, SP, -8
9D0032CC  AFBF0004   SW RA, 4(SP)
92:                      bool int_flag = false;
93:                      register unsigned long tmp = 0;
94:                  
95:                      /* Set kseg0 coherency algorithm to "cacheable, non-coherent, write-back, 
96:                       * write-allocate. This is needed for the prefetch buffer */
97:                      asm("mfc0 %0,$16,0" :  "=r"(tmp));
9D0032D0  40038000   MFC0 V1, Config
98:                      tmp = (tmp & ~7) | 3;
9D0032D4  2402FFF8   ADDIU V0, ZERO, -8
9D0032D8  00621024   AND V0, V1, V0
9D0032DC  34420003   ORI V0, V0, 3
99:                      asm("mtc0 %0,$16,0" :: "r" (tmp));
9D0032E0  40828000   MTC0 V0, Config
100:                 
101:                     /* Set the PFM wait states based on the system clock */
102:                     #if defined(PLIB_PCACHE_ExistsWaitState)
103:                     if (PLIB_PCACHE_ExistsWaitState(PCACHE_ID_0))
104:                     {
105:                         int ws; /* number of wait states */
106:                         if (sysclk <= 30000000)
107:                             ws = 0;
108:                         else if (sysclk <= 60000000)
109:                             ws = 1;
110:                         else
111:                             ws = 2;
112:                 
113:                         /* Interrupts must be disabled when changing wait states */
114:                         int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
115:                 
116:                         PLIB_PCACHE_WaitStateSet(PCACHE_ID_0, ws);
117:                 
118:                         if (int_flag)
119:                         {
120:                             PLIB_INT_Enable(INT_ID_0);
121:                             int_flag = false;
122:                         }
123:                     }
124:                     #endif // defined(PLIB_PCACHE_ExistsWaitState)
125:                 
126:                     /* Interrupts must be disabled when enabling the Prefetch Cache Module */
127:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0032FC  30820001   ANDI V0, A0, 1
128:                 
129:                     /* Enable Prefetch Cache Module */
130:                     #if defined(PLIB_PCACHE_ExistsPrefetchEnable)
131:                     if (PLIB_PCACHE_ExistsPrefetchEnable(PCACHE_ID_0))
132:                     {
133:                         PLIB_PCACHE_PrefetchEnableSet(PCACHE_ID_0, PLIB_PCACHE_PREFETCH_ENABLE_ALL);
134:                     }
135:                     #endif
136:                 
137:                     /* Set the SRAM wait states to zero */
138:                     #if defined (PLIB_BMX_ExistsDataRamWaitState)
139:                     if (PLIB_BMX_ExistsDataRamWaitState(BMX_ID_0))
140:                     {
141:                         PLIB_BMX_DataRamWaitStateSet(BMX_ID_0, PLIB_BMX_DATA_RAM_WAIT_ZERO);
142:                     }            
143:                     #endif
144:                     if (int_flag)
9D003300  10400006   BEQ V0, ZERO, 0x9D00331C
9D003304  8FBF0004   LW RA, 4(SP)
145:                     {
146:                         PLIB_INT_Enable(INT_ID_0);
147:                     }
148:                 }
9D003318  8FBF0004   LW RA, 4(SP)
9D00331C  03E00008   JR RA
9D003320  27BD0008   ADDIU SP, SP, 8
149:                 
150:                 /*******************************************************************************
151:                  End of File
152:                 */
153:                 
---  c:/microchip/harmony/v2_01b/framework/system/devcon/src/sys_devcon.c  ------------------------------
1:                   /*******************************************************************************
2:                     Device Control System Service Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       sys_devcon.c
9:                   
10:                    Summary:
11:                      Device Control System Service implementation.
12:                  
13:                    Description:
14:                      The DEVCON system service provides a simple interface to manage the Device 
15:                      Control module on Microchip microcontrollers. This file Implements the core
16:                      interface routines for the Device Control system service. While building 
17:                      the system service from source, ALWAYS include this file in the build.
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  // Section: Included Files
49:                  // *****************************************************************************
50:                  // *****************************************************************************
51:                  
52:                  #include "system/devcon/src/sys_devcon_local.h"
53:                  #include "peripheral/int/plib_int.h"
54:                  #include "peripheral/devcon/plib_devcon.h"
55:                  #include "peripheral/osc/plib_osc.h"
56:                  
57:                  // *****************************************************************************
58:                  // *****************************************************************************
59:                  // Section: File Scope or Global Constants
60:                  // *****************************************************************************
61:                  // *****************************************************************************
62:                  
63:                  // *****************************************************************************
64:                  // *****************************************************************************
65:                  // Section: Variable Definitions
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  
69:                  /* System Device Control Instance */
70:                  SYS_DEVCON_OBJECT sysDevconObj;
71:                  
72:                  
73:                  // *****************************************************************************
74:                  // *****************************************************************************
75:                  // Section: SYS DEVCON Module Initialization Routines
76:                  // *****************************************************************************
77:                  // *****************************************************************************
78:                  
79:                  // *****************************************************************************
80:                  /* Function:
81:                      SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX           index,
82:                                                         const SYS_MODULE_INIT * const    init )
83:                  
84:                    Summary:
85:                      Initializes data for the instance of the Device Control module and opens
86:                      the specific module instance.
87:                  
88:                    Description:
89:                      This function initializes the instance of the Device Control module,
90:                      using the specified initialization data. It also initializes any
91:                      internal data structures.
92:                  
93:                    Remarks:
94:                      This routine should only be called once during system initialization
95:                      unless SYS_DEVCON_Deinitialize is first called to deinitialize the device
96:                      instance before reinitializing it. If the system was already initialized
97:                      it safely returns without causing any disturbance.
98:                  */
99:                  
100:                 SYS_MODULE_OBJ SYS_DEVCON_Initialize( const SYS_MODULE_INDEX index,
101:                                                    const SYS_MODULE_INIT * const init )
102:                 {
103:                     sysDevconObj.status = SYS_STATUS_READY;
9D0038BC  24020002   ADDIU V0, ZERO, 2
9D0038C0  AF828058   SW V0, -32680(GP)
104:                 
105:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
9D0038C4  AF808054   SW ZERO, -32684(GP)
106:                 
107:                     return (SYS_MODULE_OBJ)SYS_DEVCON_INDEX_0;
108:                 }
9D0038C8  03E00008   JR RA
9D0038CC  00001021   ADDU V0, ZERO, ZERO
109:                 
110:                 
111:                 // *****************************************************************************
112:                 /* Function:
113:                     void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ                  object,
114:                                                const SYS_MODULE_INIT * const   init )
115:                 
116:                    Summary:
117:                     Reinitializes and refreshes the hardware for the instance of the Device 
118:                     Control module.
119:                 
120:                    Description:
121:                     This function reinitializes the instance of the Device Control module using 
122:                     the supplied data. It modifies the internal data structure.
123:                 
124:                    Remarks:
125:                     This operation uses the same initialization data structure as the
126:                     SYS_DEVCON_Initialize operation. This operation can be used to change the
127:                     power state of a DEVCON module. This function can be called multiple times
128:                     to reinitialize the module. This operation uses the same initialization
129:                     data structure as the Initialize operation. This operation can also be
130:                     used to refresh the hardware registers as defined by the initialization
131:                     data.
132:                 */
133:                 
134:                 void SYS_DEVCON_Reinitialize( SYS_MODULE_OBJ object,
135:                                            const SYS_MODULE_INIT * const init )
136:                 {
137:                     sysDevconObj.status = SYS_STATUS_READY;
00000000  00000000   NOP
138:                 
139:                     sysDevconObj.state = SYS_DEVCON_STATE_READY;
00000008  00000000   NOP
140:                 }
141:                 
142:                 
143:                 // *****************************************************************************
144:                 /* Function:
145:                     void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
146:                 
147:                   Summary:
148:                     Deinitializes the specific module instance of the DEVCON module
149:                 
150:                   Description:
151:                     This function deinitializes the specific module instance disabling its operation 
152:                     (and any hardware for driver modules). Resets all of the internal data
153:                     structures and fields for the specified instance to the default settings.
154:                 
155:                   Remarks:
156:                     Once the Initialize operation has been called, the Deinitialize
157:                     operation must be called before the Initialize operation can be called
158:                     again.
159:                 */
160:                 
161:                 void SYS_DEVCON_Deinitialize( SYS_MODULE_OBJ object )
162:                 {
163:                     sysDevconObj.status = SYS_STATUS_UNINITIALIZED;
164:                 }
165:                 
166:                 
167:                 // *****************************************************************************
168:                 /* Function:
169:                     SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
170:                 
171:                   Summary:
172:                     Returns status of the specific instance of the Device Control module.
173:                 
174:                   Description:
175:                     This function returns the status of the specific module instance.
176:                 
177:                   Remarks:
178:                     None.
179:                 */
180:                 
181:                 SYS_STATUS SYS_DEVCON_Status( SYS_MODULE_OBJ object )
182:                 {
183:                     return sysDevconObj.status; 
184:                 }
00000000  00000000   NOP
185:                 
186:                 
187:                 // *****************************************************************************
188:                 /* Function:
189:                     void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
190:                 
191:                   Summary:
192:                     Maintains the system Device Control state machine.
193:                 
194:                   Description:
195:                     This function is used to maintain the system Device Control internal state machine.
196:                 
197:                   Remarks:
198:                     This function is normally not called directly by an application.  It is
199:                     called by the system's Tasks routine (SYS_Tasks) or by the appropriate raw
200:                     ISR.
201:                 */
202:                 
203:                 void SYS_DEVCON_Tasks( SYS_MODULE_OBJ object )
204:                 {
9D003934  03E00008   JR RA
9D003938  00000000   NOP
205:                     switch (sysDevconObj.state)
206:                     {
207:                         case SYS_DEVCON_STATE_INIT:
208:                         case SYS_DEVCON_STATE_BUSY:
209:                         case SYS_DEVCON_STATE_READY:
210:                         default:
211:                         break;
212:                     }
213:                 }
214:                 
215:                     
216:                 // *****************************************************************************
217:                 // *****************************************************************************
218:                 // Section: SYS DEVCON Client Setup Routines
219:                 // *****************************************************************************
220:                 // *****************************************************************************
221:                 
222:                 // *****************************************************************************
223:                 /* Function:
224:                     void SYS_DEVCON_SystemUnlock( void )
225:                 
226:                   Summary:
227:                     Performs a system unlock sequence by writing to the SYSKEY register.
228:                 
229:                   Description:
230:                     Performs a system unlock sequence by writing to the SYSKEY register. A 
231:                     system unlock sequence is required before performing certain actions such
232:                     as changing a clock frequency or IO unlocking.
233:                 
234:                   Remarks:
235:                     None.
236:                 */
237:                 
238:                 void SYS_DEVCON_SystemUnlock( void )
239:                 {
9D003380  27BDFFF8   ADDIU SP, SP, -8
9D003384  AFBF0004   SW RA, 4(SP)
240:                     bool int_flag = false;
241:                 
242:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D0033B0  30620001   ANDI V0, V1, 1
243:                 
244:                     PLIB_DEVCON_SystemUnlock(DEVCON_ID_0);
245:                 
246:                     if (int_flag)
9D0033B4  10400006   BEQ V0, ZERO, 0x9D0033D0
9D0033B8  8FBF0004   LW RA, 4(SP)
247:                     {
248:                         PLIB_INT_Enable(INT_ID_0);
249:                     }
250:                 }
9D0033CC  8FBF0004   LW RA, 4(SP)
9D0033D0  03E00008   JR RA
9D0033D4  27BD0008   ADDIU SP, SP, 8
251:                 
252:                 
253:                 // *****************************************************************************
254:                 /* Function:
255:                     void SYS_DEVCON_SystemLock( void )
256:                 
257:                   Summary:
258:                     Performs a system lock sequence by writing to the SYSKEY register.
259:                 
260:                   Description:
261:                     Performs a system lock sequence by writing to the SYSKEY register. A 
262:                     system lock sequence is required after performing the action that required
263:                     a system lock sequence.
264:                 
265:                   Remarks:
266:                     None.
267:                 */
268:                 
269:                 void SYS_DEVCON_SystemLock( void )
270:                 {
9D00351C  27BDFFF8   ADDIU SP, SP, -8
9D003520  AFBF0004   SW RA, 4(SP)
271:                     bool int_flag = false;
272:                    
273:                     int_flag = (bool)(PLIB_INT_GetStateAndDisable( INT_ID_0 ) & 0x01);
9D00353C  30420001   ANDI V0, V0, 1
274:                 
275:                     PLIB_DEVCON_SystemLock(DEVCON_ID_0);
276:                 
277:                     if (int_flag)
9D003540  10400006   BEQ V0, ZERO, 0x9D00355C
9D003544  8FBF0004   LW RA, 4(SP)
278:                     {
279:                         PLIB_INT_Enable(INT_ID_0);
280:                     }
281:                 }
9D003558  8FBF0004   LW RA, 4(SP)
9D00355C  03E00008   JR RA
9D003560  27BD0008   ADDIU SP, SP, 8
282:                 
283:                 
284:                 // *****************************************************************************
285:                 /* Function:
286:                     void SYS_DEVCON_JTAGEnable( void )
287:                 
288:                   Summary:
289:                     Enables the JTAG port on the device.
290:                 
291:                   Description:
292:                     Enables the JTAG port on the device.
293:                 
294:                   Remarks:
295:                     None.
296:                 */
297:                 
298:                 void SYS_DEVCON_JTAGEnable( void )
299:                 {
300:                     PLIB_DEVCON_JTAGPortEnable(DEVCON_ID_0);
301:                 }
302:                 
303:                 
304:                 // *****************************************************************************
305:                 /* Function:
306:                     void SYS_DEVCON_JTAGDisable( void )
307:                 
308:                   Summary:
309:                     Disables the JTAG port on the device.
310:                 
311:                   Description:
312:                     Disables the JTAG port on the device.
313:                 
314:                   Remarks:
315:                     None.
316:                 */
317:                 
318:                 void SYS_DEVCON_JTAGDisable( void )
319:                 {
320:                     PLIB_DEVCON_JTAGPortDisable(DEVCON_ID_0);
321:                 }
322:                 
323:                 
324:                 // *****************************************************************************
325:                 /* Function:
326:                     void SYS_DEVCON_TraceEnable( void )
327:                 
328:                   Summary:
329:                     Enables the Trace output port on the device.
330:                 
331:                   Description:
332:                     Enables the Trace output port on the device.
333:                 
334:                   Remarks:
335:                     None.
336:                 */
337:                 
338:                 void SYS_DEVCON_TraceEnable( void )
339:                 {
340:                     #if defined PLIB_DEVCON_ExistsTraceOutput
341:                         if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
342:                         {
343:                             PLIB_DEVCON_TraceOutputEnable(DEVCON_ID_0);
344:                         }
345:                     #endif
346:                 }
347:                 
348:                 
349:                 // *****************************************************************************
350:                 /* Function:
351:                     void SYS_DEVCON_TraceDisable( void )
352:                 
353:                   Summary:
354:                     Disables the Trace output port on the device.
355:                 
356:                   Description:
357:                     Disables the Trace output port on the device.
358:                 
359:                   Remarks:
360:                     None.
361:                 */
362:                 
363:                 void SYS_DEVCON_TraceDisable( void )
364:                 {
365:                     #if defined PLIB_DEVCON_ExistsTraceOutput
366:                     if(PLIB_DEVCON_ExistsTraceOutput(DEVCON_ID_0))
367:                     {
368:                         PLIB_DEVCON_TraceOutputDisable(DEVCON_ID_0);
369:                     }
370:                     #endif
371:                 }
372:                 
373:                 
374:                 // *****************************************************************************
375:                 /* Function:
376:                     void SYS_DEVCON_PowerModeEnter(SYS_POWER_MODE pwrMode)
377:                 
378:                   Summary:
379:                     Puts the device in a low-power state.
380:                 
381:                   Description:
382:                     This function puts the device in a low-power state.
383:                 
384:                   Remarks:
385:                     None.
386:                 */
387:                 
388:                 void __attribute__((nomips16)) SYS_DEVCON_PowerModeEnter( SYS_POWER_MODE pwrMode )
389:                 {
00000000  00000000   NOP
390:                     OSC_OPERATION_ON_WAIT op = SYS_POWER_MODE_IDLE;
0000000C  00000000   NOP
391:                 
392:                     switch (pwrMode)
393:                     {
394:                         case SYS_POWER_MODE_IDLE:
395:                             op = OSC_ON_WAIT_IDLE;
396:                             break;
397:                         case SYS_POWER_MODE_SLEEP:
398:                             op = OSC_ON_WAIT_SLEEP;
399:                             break;
400:                         default:
401:                             break;
402:                     }
403:                 
404:                     
405:                     #if defined PLIB_OSC_ExistsOnWaitAction
406:                     if(PLIB_OSC_ExistsOnWaitAction(OSC_ID_0))
407:                     {
408:                         SYS_DEVCON_SystemUnlock();
00000010  00000000   NOP
409:                         PLIB_OSC_OnWaitActionSet (OSC_ID_0, op);
410:                         SYS_DEVCON_SystemLock();
00000028  00000000   NOP
411:                     }
412:                     #endif
413:                     asm volatile ( "wait" );
00000030  00000000   NOP
414:                 }
00000034  00000000   NOP
415:                 
416:                 
417:                 /*******************************************************************************
418:                  End of File
419:                 */
420:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_wakeonstart_default.h  ------
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_WakeOnStart_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : WakeOnStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsWakeOnStart
16:                          PLIB_USART_WakeOnStartEnable
17:                          PLIB_USART_WakeOnStartDisable
18:                          PLIB_USART_WakeOnStartIsEnabled
19:                          PLIB_USART_InitializeModeGeneral
20:                          PLIB_USART_ErrorsGet
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _USART_WAKEONSTART_DEFAULT_H
51:                  #define _USART_WAKEONSTART_DEFAULT_H
52:                  
53:                  #include "usart_registers.h"
54:                  
55:                  //******************************************************************************
56:                  /* Function :  USART_ExistsWakeOnStart_Default
57:                  
58:                    Summary:
59:                      Implements Default variant of PLIB_USART_ExistsWakeOnStart
60:                  
61:                    Description:
62:                      This template implements the Default variant of the PLIB_USART_ExistsWakeOnStart function.
63:                  */
64:                  
65:                  #define PLIB_USART_ExistsWakeOnStart PLIB_USART_ExistsWakeOnStart
66:                  PLIB_TEMPLATE bool USART_ExistsWakeOnStart_Default( USART_MODULE_ID index )
67:                  {
68:                      return true;
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  USART_WakeOnStartEnable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_USART_WakeOnStartEnable
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_USART_WakeOnStartEnable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void USART_WakeOnStartEnable_Default( USART_MODULE_ID index )
83:                  {
84:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
85:                      usart->UxMODESET = UxMODE_WAKE_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_WakeOnStartDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_USART_WakeOnStartDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_USART_WakeOnStartDisable function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void USART_WakeOnStartDisable_Default( USART_MODULE_ID index )
100:                 {
101:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
102:                     usart->UxMODECLR = UxMODE_WAKE_MASK;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  USART_WakeOnStartIsEnabled_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_USART_WakeOnStartIsEnabled
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_USART_WakeOnStartIsEnabled function.
114:                 */
115:                 
116:                 PLIB_TEMPLATE bool USART_WakeOnStartIsEnabled_Default( USART_MODULE_ID index )
117:                 {
118:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
119:                     return (bool)usart->UxMODE.WAKE;
120:                 }
121:                 
122:                 
123:                 //******************************************************************************
124:                 /* Function :  USART_InitializeModeGeneral_Default
125:                 
126:                   Summary:
127:                     Implements Default variant of PLIB_USART_InitializeModeGeneral
128:                 
129:                   Description:
130:                     This template implements the Default variant of the PLIB_USART_InitializeModeGeneral function.
131:                 */
132:                 
133:                 PLIB_TEMPLATE void USART_InitializeModeGeneral_Default( USART_MODULE_ID index, bool autobaud, bool loopBackMode, bool wakeFromSleep, bool irdaMode, bool stopInIdle )
134:                 {
135:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
136:                     usart->UxMODE.ABAUD = autobaud;
9D0015D8  94860000   LHU A2, 0(A0)
9D0015DC  7D462944   INS A2, T2, 5, 1
9D0015E0  A4860000   SH A2, 0(A0)
137:                     usart->UxMODE.LPBACK = loopBackMode;
9D0015E4  94860000   LHU A2, 0(A0)
9D0015E8  7C463184   INS A2, V0, 6, 1
9D0015EC  A4860000   SH A2, 0(A0)
138:                     usart->UxMODE.WAKE = wakeFromSleep;
9D0015F0  94820000   LHU V0, 0(A0)
9D0015F4  7C6239C4   INS V0, V1, 7, 1
9D0015F8  A4820000   SH V0, 0(A0)
139:                     usart->UxMODE.SIDL = stopInIdle;
9D0015FC  94820000   LHU V0, 0(A0)
9D001600  7D226B44   INS V0, T1, 13, 1
9D001604  A4820000   SH V0, 0(A0)
140:                     usart->UxMODE.IREN = irdaMode;
9D001608  94820000   LHU V0, 0(A0)
9D00160C  7D026304   INS V0, T0, 12, 1
9D001610  A4820000   SH V0, 0(A0)
141:                 }
142:                 
143:                 //******************************************************************************
144:                 /* Function :  USART_ErrorsGet_Default
145:                 
146:                   Summary:
147:                     Implements Default variant of PLIB_USART_ErrorsGet
148:                 
149:                   Description:
150:                     This template implements the Default variant of the PLIB_USART_ErrorsGet function.
151:                 */
152:                 
153:                 PLIB_TEMPLATE USART_ERROR USART_ErrorsGet_Default( USART_MODULE_ID index)
154:                 {
155:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
156:                     return (USART_ERROR)((usart->UxSTA.w & 0xE) >> 1u);
157:                 }
158:                 
159:                 #endif /*_USART_WAKEONSTART_DEFAULT_H*/
160:                 
161:                 /******************************************************************************
162:                  End of File
163:                 */
164:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_transmitterempty_default.h  -
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterEmpty_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterEmpty
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_TransmitterIsEmpty
16:                          PLIB_USART_ExistsTransmitterEmptyStatus
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTEREMPTY_DEFAULT_H
47:                  #define _USART_TRANSMITTEREMPTY_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_TransmitterIsEmpty_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_TransmitterIsEmpty 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_TransmitterIsEmpty function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool USART_TransmitterIsEmpty_Default( USART_MODULE_ID index )
62:                  {
63:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
64:                      return (bool)usart->UxSTA.TRMT;
00000038  00000000   NOP
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ExistsTransmitterEmptyStatus_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ExistsTransmitterEmptyStatus
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterEmptyStatus function.
76:                  */
77:                  
78:                  #define PLIB_USART_ExistsTransmitterEmptyStatus PLIB_USART_ExistsTransmitterEmptyStatus
79:                  PLIB_TEMPLATE bool USART_ExistsTransmitterEmptyStatus_Default( USART_MODULE_ID index )
80:                  {
81:                      return true;
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_TRANSMITTEREMPTY_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_transmitterbufferfull_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_TransmitterBufferFull_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterBufferFull
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitterBufferFullStatus
16:                          PLIB_USART_TransmitterBufferIsFull
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
47:                  #define _USART_TRANSMITTERBUFFERFULL_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitterBufferFullStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsTransmitterBufferFullStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitterBufferFullStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitterBufferFullStatus PLIB_USART_ExistsTransmitterBufferFullStatus
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitterBufferFullStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_TransmitterBufferIsFull_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_TransmitterBufferIsFull 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_TransmitterBufferIsFull function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_TransmitterBufferIsFull_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D003750  8C420000   LW V0, 0(V0)
81:                      return (bool)usart->UxSTA.UTXBF;
9D003754  8C420010   LW V0, 16(V0)
9D003758  7C420240   EXT V0, V0, 9, 1
0000004C  00000000   NOP
00000108  00000000   NOP
00000180  00000000   NOP
000001C4  00000000   NOP
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_TRANSMITTERBUFFERFULL_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_transmitter_default.h  ------
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter
16:                          PLIB_USART_TransmitterByteSend
17:                          PLIB_USART_TransmitterAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_TRANSMITTER_DEFAULT_H
48:                  #define _USART_TRANSMITTER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsTransmitter_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsTransmitter
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsTransmitter function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsTransmitter PLIB_USART_ExistsTransmitter
63:                  PLIB_TEMPLATE bool USART_ExistsTransmitter_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_TransmitterByteSend_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_TransmitterByteSend
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_TransmitterByteSend function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_TransmitterByteSend_Default( USART_MODULE_ID index , int8_t data )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D003218  8C430000   LW V1, 0(V0)
82:                      usart->UxTXREG = data;
9D00321C  7C108420   SEB S0, S0
9D003220  AC700020   SW S0, 32(V1)
000001B0  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_TransmitterAddressGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_TransmitterAddressGet
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_TransmitterAddressGet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void* USART_TransmitterAddressGet_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
99:                      return (uint32_t*)(&usart->UxTXREG);
100:                 }
101:                 
102:                 #endif /*_USART_TRANSMITTER_DEFAULT_H*/
103:                 
104:                 /******************************************************************************
105:                  End of File
106:                 */
107:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_transmitter9bits_indataonly.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Transmitter9Bits_InDataOnly.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Transmitter9Bits
13:                      and its Variant : InDataOnly
14:                      For following APIs :
15:                          PLIB_USART_ExistsTransmitter9BitsSend
16:                          PLIB_USART_Transmitter9BitsSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_TRANSMITTER9BITS_INDATAONLY_H
47:                  #define _USART_TRANSMITTER9BITS_INDATAONLY_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsTransmitter9BitsSend_InDataOnly
53:                  
54:                    Summary:
55:                      Implements InDataOnly variant of PLIB_USART_ExistsTransmitter9BitsSend
56:                  
57:                    Description:
58:                      This template implements the InDataOnly variant of the PLIB_USART_ExistsTransmitter9BitsSend function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsTransmitter9BitsSend PLIB_USART_ExistsTransmitter9BitsSend
62:                  PLIB_TEMPLATE bool USART_ExistsTransmitter9BitsSend_InDataOnly( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_Transmitter9BitsSend_InDataOnly
70:                  
71:                    Summary:
72:                      Implements InDataOnly variant of PLIB_USART_Transmitter9BitsSend
73:                  
74:                    Description:
75:                      This template implements the InDataOnly variant of the PLIB_USART_Transmitter9BitsSend function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_Transmitter9BitsSend_InDataOnly( USART_MODULE_ID index , int8_t data , bool bit9th )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                      uint32_t temp;
82:                  
83:                      if (0 == bit9th)
84:                      {
85:                          usart->UxTXREG = (uint32_t)data;
0000016C  00000000   NOP
86:                      }
87:                      else
88:                      {
89:                          temp = (uint32_t)data;
00000154  00000000   NOP
90:                          temp = ( temp | 0x0100);
00000158  00000000   NOP
91:                          usart->UxTXREG = temp;
0000015C  00000000   NOP
92:                      }
93:                  }
94:                  
95:                  
96:                  #endif /*_USART_TRANSMITTER9BITS_INDATAONLY_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiveroverrunerror_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverOverrunError_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverrunError
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverOverrunStatus
16:                          PLIB_USART_ReceiverOverrunErrorClear
17:                          PLIB_USART_ReceiverOverrunHasOccurred
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVEROVERRUNERROR_DEFAULT_H
48:                  #define _USART_RECEIVEROVERRUNERROR_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverOverrunStatus_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverOverrunStatus
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverOverrunStatus function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverOverrunStatus PLIB_USART_ExistsReceiverOverrunStatus
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverOverrunStatus_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverOverrunErrorClear_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverOverrunErrorClear 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunErrorClear function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverOverrunErrorClear_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      usart->UxSTACLR = UxSTA_OERR_MASK;
9D002AB4  AC430014   SW V1, 20(V0)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  USART_ReceiverOverrunHasOccurred_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_USART_ReceiverOverrunHasOccurred 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_USART_ReceiverOverrunHasOccurred function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE bool USART_ReceiverOverrunHasOccurred_Default( USART_MODULE_ID index )
97:                  {
98:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D002AA0  8E020000   LW V0, 0(S0)
99:                      return (bool)usart->UxSTA.OERR;
9D002AA4  8C430010   LW V1, 16(V0)
9D002AA8  30630002   ANDI V1, V1, 2
100:                 }
101:                 
102:                 
103:                 #endif /*_USART_RECEIVEROVERRUNERROR_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiverinterruptmode_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverInterruptMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverInterruptMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverInterruptMode
16:                          PLIB_USART_ReceiverInterruptModeSelect
17:                          PLIB_USART_InitializeOperation
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
48:                  #define _USART_RECEIVERINTERRUPTMODE_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverInterruptMode_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverInterruptMode
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverInterruptMode function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverInterruptMode PLIB_USART_ExistsReceiverInterruptMode
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverInterruptMode_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverInterruptModeSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverInterruptModeSelect 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverInterruptModeSelect function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverInterruptModeSelect_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE interruptMode )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_URXISEL_MASK;
87:                      usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)interruptMode << UxSTA_URXISEL_POSITION) );
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_InitializeOperation_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_InitializeOperation 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_InitializeOperation function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_InitializeOperation_Default( USART_MODULE_ID index , USART_RECEIVE_INTR_MODE receiveInterruptMode ,
102:                         USART_TRANSMIT_INTR_MODE transmitInterruptMode, USART_OPERATION_MODE operationMode)
103:                 {
104:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
105:                 
106:                     /* Clear and Set, as UxSTA contains status bits and 
107:                        hence need to be accessed atomically.
108:                        Using bit field access may erroneously cause status bits to get cleared */
109:                     usart->UxSTACLR = UxSTA_URXISEL_MASK;
9D001644  240200C0   ADDIU V0, ZERO, 192
9D001648  AC820014   SW V0, 20(A0)
110:                     usart->UxSTASET = ( UxSTA_URXISEL_MASK & ((uint32_t)receiveInterruptMode << UxSTA_URXISEL_POSITION) );
9D00164C  AC800018   SW ZERO, 24(A0)
111:                 
112:                     /* Clear and Set, as UxSTA contains status bits and 
113:                        hence need to be accessed atomically.
114:                        Using bit field access may erroneously cause status bits to get cleared */
115:                     usart->UxSTACLR = UxSTA_UTXISEL_MASK;
9D001650  3402C000   ORI V0, ZERO, -16384
9D001654  AC820014   SW V0, 20(A0)
116:                     usart->UxSTASET = ( UxSTA_UTXISEL_MASK & ((uint32_t)transmitInterruptMode << UxSTA_UTXISEL_POSITION) );
9D001658  24024000   ADDIU V0, ZERO, 16384
9D00165C  AC820018   SW V0, 24(A0)
117:                 
118:                     /* Select the operation mode */
119:                     usart->UxMODE.UEN = operationMode;
9D001660  94820000   LHU V0, 0(A0)
9D001664  7CE24A04   INS V0, A3, 8, 2
9D001668  A4820000   SH V0, 0(A0)
120:                 
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_RECEIVERINTERRUPTMODE_DEFAULT_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiverdataavailable_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverDataAvailable_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverDataAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverDataAvailableStatus
16:                          PLIB_USART_ReceiverDataIsAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
47:                  #define _USART_RECEIVERDATAAVAILABLE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsReceiverDataAvailableStatus_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsReceiverDataAvailableStatus
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverDataAvailableStatus function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsReceiverDataAvailableStatus PLIB_USART_ExistsReceiverDataAvailableStatus
62:                  PLIB_TEMPLATE bool USART_ExistsReceiverDataAvailableStatus_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_ReceiverDataIsAvailable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_ReceiverDataIsAvailable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_ReceiverDataIsAvailable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE bool USART_ReceiverDataIsAvailable_Default( USART_MODULE_ID index )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D003718  8C420000   LW V0, 0(V0)
0000001C  00000000   NOP
00000038  00000000   NOP
81:                     return (usart->UxSTA.URXDA);
9D00371C  8C420010   LW V0, 16(V0)
9D003720  30420001   ANDI V0, V0, 1
9D003724  38420001   XORI V0, V0, 1
00000020  00000000   NOP
0000003C  00000000   NOP
0000007C  00000000   NOP
82:                  }
83:                  
84:                  
85:                  #endif /*_USART_RECEIVERDATAAVAILABLE_DEFAULT_H*/
86:                  
87:                  /******************************************************************************
88:                   End of File
89:                  */
90:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiveraddressdetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressDetect
16:                          PLIB_USART_ReceiverAddressDetectEnable
17:                          PLIB_USART_ReceiverAddressDetectDisable
18:                          PLIB_USART_ReceiverAddressIsReceived
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_RECEIVERADDRESSDETECT_DEFAULT_H
49:                  #define _USART_RECEIVERADDRESSDETECT_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsReceiverAddressDetect_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressDetect
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressDetect function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsReceiverAddressDetect PLIB_USART_ExistsReceiverAddressDetect
64:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressDetect_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_ReceiverAddressDetectEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectEnable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectEnable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
83:                      usart->UxSTASET = UxSTA_ADDEN_MASK;
9D001550  24020020   ADDIU V0, ZERO, 32
9D001554  AC820018   SW V0, 24(A0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_ReceiverAddressDetectDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_ReceiverAddressDetectDisable
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressDetectDisable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_ReceiverAddressDetectDisable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
100:                     usart->UxSTACLR = UxSTA_ADDEN_MASK;
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  USART_ReceiverAddressIsReceived_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_USART_ReceiverAddressIsReceived
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_USART_ReceiverAddressIsReceived function.
112:                 */
113:                 
114:                 PLIB_TEMPLATE bool USART_ReceiverAddressIsReceived_Default( USART_MODULE_ID index )
115:                 {
116:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
117:                     return (bool)usart->UxSTA.ADDEN;
118:                 }
119:                 
120:                 
121:                 #endif /*_USART_RECEIVERADDRESSDETECT_DEFAULT_H*/
122:                 
123:                 /******************************************************************************
124:                  End of File
125:                 */
126:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiveraddressautodetect_default.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddressAutoDetect_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddressAutoDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddressAutoDetect
16:                          PLIB_USART_ReceiverAddressAutoDetectEnable
17:                          PLIB_USART_ReceiverAddressAutoDetectDisable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddressAutoDetect_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddressAutoDetect
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddressAutoDetect function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddressAutoDetect PLIB_USART_ExistsReceiverAddressAutoDetect
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddressAutoDetect_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverAddressAutoDetectEnable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectEnable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectEnable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectEnable_Default( USART_MODULE_ID index , int8_t mask )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                  
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D001574  AC820014   SW V0, 20(A0)
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)mask) << UxSTA_ADDR_POSITION) ) | (UxSTA_ADM_EN_MASK);
9D001578  7C031C20   SEB V1, V1
9D00157C  00031C00   SLL V1, V1, 16
9D001580  00621024   AND V0, V1, V0
9D001584  3C030100   LUI V1, 256
9D001588  00431025   OR V0, V0, V1
9D00158C  AC820018   SW V0, 24(A0)
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_ReceiverAddressAutoDetectDisable_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_ReceiverAddressAutoDetectDisable 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressAutoDetectDisable function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void USART_ReceiverAddressAutoDetectDisable_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     usart->UxSTACLR = UxSTA_ADM_EN_MASK;
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESSAUTODETECT_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiveraddress_default.h  --
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_ReceiverAddress_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiverAddress
16:                          PLIB_USART_AddressSet
17:                          PLIB_USART_AddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVERADDRESS_DEFAULT_H
48:                  #define _USART_RECEIVERADDRESS_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiverAddress_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiverAddress
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiverAddress function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiverAddress PLIB_USART_ExistsReceiverAddress
63:                  PLIB_TEMPLATE bool USART_ExistsReceiverAddress_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_AddressSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_AddressSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_AddressSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_AddressSet_Default( USART_MODULE_ID index , uint8_t address )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      
83:                      /* Clear and Set, as UxSTA contains status bits and 
84:                         hence need to be accessed atomically.
85:                         Using bit field access may erroneously cause status bits to get cleared */
86:                      usart->UxSTACLR = UxSTA_ADDR_MASK;
9D00155C  3C0200FF   LUI V0, 255
9D001560  AC820014   SW V0, 20(A0)
87:                      usart->UxSTASET = ( UxSTA_ADDR_MASK & (((uint32_t)address) << UxSTA_ADDR_POSITION) );
9D001564  00031C00   SLL V1, V1, 16
9D001568  00621824   AND V1, V1, V0
9D00156C  AC830018   SW V1, 24(A0)
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  USART_AddressGet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_USART_AddressGet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_USART_AddressGet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE uint8_t USART_AddressGet_Default( USART_MODULE_ID index )
102:                 {
103:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
104:                     return (uint8_t)usart->UxSTA.ADDR;
9D001570  90830012   LBU V1, 18(A0)
105:                 }
106:                 
107:                 
108:                 #endif /*_USART_RECEIVERADDRESS_DEFAULT_H*/
109:                 
110:                 /******************************************************************************
111:                  End of File
112:                 */
113:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_receiver_default.h  ---------
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_Receiver_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Receiver
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsReceiver
16:                          PLIB_USART_ReceiverByteReceive
17:                          PLIB_USART_ReceiverAddressGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_RECEIVER_DEFAULT_H
48:                  #define _USART_RECEIVER_DEFAULT_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsReceiver_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_USART_ExistsReceiver
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_USART_ExistsReceiver function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsReceiver PLIB_USART_ExistsReceiver
63:                  PLIB_TEMPLATE bool USART_ExistsReceiver_Default( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_ReceiverByteReceive_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_USART_ReceiverByteReceive
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_USART_ReceiverByteReceive function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE int8_t USART_ReceiverByteReceive_Default( USART_MODULE_ID index )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D0034AC  8C620000   LW V0, 0(V1)
82:                      return (int8_t)usart->UxRXREG;
9D0034B0  8C420030   LW V0, 48(V0)
00000060  00000000   NOP
83:                  }
84:                  
85:                  //******************************************************************************
86:                  /* Function :  USART_ReceiverAddressGet_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_USART_ReceiverAddressGet
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_USART_ReceiverAddressGet function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void* USART_ReceiverAddressGet_Default( USART_MODULE_ID index )
96:                  {
97:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
98:                      return (uint32_t*)(&usart->UxRXREG);
99:                  }
100:                 
101:                 #endif /*_USART_RECEIVER_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_linecontrolmode_rxandtxcombined.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_LineControlMode_RXandTXCombined.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : LineControlMode
13:                      and its Variant : RXandTXCombined
14:                      For following APIs :
15:                          PLIB_USART_ExistsLineControlMode
16:                          PLIB_USART_LineControlModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
47:                  #define _USART_LINECONTROLMODE_RXANDTXCOMBINED_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsLineControlMode_RXandTXCombined
53:                  
54:                    Summary:
55:                      Implements RXandTXCombined variant of PLIB_USART_ExistsLineControlMode
56:                  
57:                    Description:
58:                      This template implements the RXandTXCombined variant of the PLIB_USART_ExistsLineControlMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsLineControlMode PLIB_USART_ExistsLineControlMode
62:                  PLIB_TEMPLATE bool USART_ExistsLineControlMode_RXandTXCombined( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_LineControlModeSelect_RXandTXCombined
70:                  
71:                    Summary:
72:                      Implements RXandTXCombined variant of PLIB_USART_LineControlModeSelect 
73:                  
74:                    Description:
75:                      This template implements the RXandTXCombined variant of the PLIB_USART_LineControlModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_LineControlModeSelect_RXandTXCombined( USART_MODULE_ID index , USART_LINECONTROL_MODE dataFlowConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      if (dataFlowConfig > USART_9N1)
9D001618  2C430004   SLTIU V1, V0, 4
9D00161C  14600004   BNE V1, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_LineControlModeSelect
9D001620  24030001   ADDIU V1, ZERO, 1
00000030  00000000   NOP
83:                      {
84:                          usart->UxMODESET = UxMODE_STSEL_MASK;
9D001624  AC830008   SW V1, 8(A0)
0000003C  00000000   NOP
85:                          dataFlowConfig = (USART_LINECONTROL_MODE)(dataFlowConfig - USART_8N2);
9D001628  0B40058E   J 0x9D001638
9D00162C  2443FFFC   ADDIU V1, V0, -4
00000044  00000000   NOP
86:                      }
87:                      else
88:                      {
89:                          usart->UxMODECLR = UxMODE_STSEL_MASK;
9D001630  AC830004   SW V1, 4(A0)
9D001634  00401821   ADDU V1, V0, ZERO
0000004C  00000000   NOP
90:                      }
91:                      usart->UxMODE.PDSEL = dataFlowConfig;
9D001638  94820000   LHU V0, 0(A0)
9D00163C  7C621044   INS V0, V1, 1, 2
9D001640  A4820000   SH V0, 0(A0)
00000054  00000000   NOP
92:                  }
93:                  
94:                  
95:                  #endif /*_USART_LINECONTROLMODE_RXANDTXCOMBINED_H*/
96:                  
97:                  /******************************************************************************
98:                   End of File
99:                  */
100:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_handshakemode_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_HandShakeMode_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HandShakeMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsHandshakeMode
16:                          PLIB_USART_HandshakeModeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _USART_HANDSHAKEMODE_DEFAULT_H
47:                  #define _USART_HANDSHAKEMODE_DEFAULT_H
48:                  
49:                  #include "usart_registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  USART_ExistsHandshakeMode_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_USART_ExistsHandshakeMode
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_USART_ExistsHandshakeMode function.
59:                  */
60:                  
61:                  #define PLIB_USART_ExistsHandshakeMode PLIB_USART_ExistsHandshakeMode
62:                  PLIB_TEMPLATE bool USART_ExistsHandshakeMode_Default( USART_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  USART_HandshakeModeSelect_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_USART_HandshakeModeSelect 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_USART_HandshakeModeSelect function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void USART_HandshakeModeSelect_Default( USART_MODULE_ID index , USART_HANDSHAKE_MODE handshakeConfig )
79:                  {
80:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
81:                  
82:                      usart->UxMODE.RTSMD = handshakeConfig;
9D0015BC  94860000   LHU A2, 0(A0)
9D0015C0  7C665AC4   INS A2, V1, 11, 1
9D0015C4  A4860000   SH A2, 0(A0)
83:                  }
84:                  
85:                  
86:                  #endif /*_USART_HANDSHAKEMODE_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_enablecontrol_default.h  ----
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_USART_ExistsEnable
16:                          PLIB_USART_Disable
17:                          PLIB_USART_Enable
18:                          PLIB_USART_BaudSetAndEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_ENABLECONTROL_DEFAULT_H
49:                  #define _USART_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_USART_ExistsEnable
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_USART_ExistsEnable function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsEnable PLIB_USART_ExistsEnable
64:                  PLIB_TEMPLATE bool USART_ExistsEnable_Default( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_USART_Disable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_USART_Disable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_Disable_Default( USART_MODULE_ID index )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D00171C  8CA20004   LW V0, 4(A1)
00000050  00000000   NOP
83:                      usart->UxMODECLR = UxMODE_ON_MASK;
9D001720  34038000   ORI V1, ZERO, -32768
9D001724  AC430004   SW V1, 4(V0)
00000054  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  USART_Enable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_USART_Enable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_USART_Enable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void USART_Enable_Default( USART_MODULE_ID index )
98:                  {
99:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
9D001858  8E020004   LW V0, 4(S0)
100:                     usart->UxMODESET = UxMODE_ON_MASK;
9D00185C  34038000   ORI V1, ZERO, -32768
9D001860  AC430008   SW V1, 8(V0)
101:                 }
102:                 
103:                 //******************************************************************************
104:                 /* Function :  USART_BaudSetAndEnable_Default
105:                 
106:                   Summary:
107:                     Implements Default variant of PLIB_USART_BaudSetAndEnable 
108:                 
109:                   Description:
110:                     This template implements the Default variant of the PLIB_USART_BaudSetAndEnable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void USART_BaudSetAndEnable_Default( USART_MODULE_ID index, uint32_t systemClock, uint32_t baud  )
114:                 {
115:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
116:                     uint32_t brgValueLow = 0;
117:                     uint32_t brgValueHigh = 0;
118:                 
119:                     /* Enable transmit and receive */
120:                     usart->UxSTASET = (UxSTA_UTXEN_MASK | UxSTA_URXEN_MASK);
9D001674  24031400   ADDIU V1, ZERO, 5120
9D001678  AC830018   SW V1, 24(A0)
121:                 
122:                     /* Find the BRG Value */
123:                     brgValueLow  = ( ((systemClock >> 4u) + (baud >> 1u)) / baud ) - 1u;
9D00167C  00022842   SRL A1, V0, 1
9D0016C0  00063102   SRL A2, A2, 4
9D0016C4  00A62821   ADDU A1, A1, A2
9D0016C8  00A2001B   DIVU A1, V0
9D0016CC  004001F4   TEQ V0, ZERO
9D0016D0  00002812   MFLO A1
9D0016D4  24A5FFFF   ADDIU A1, A1, -1
124:                     brgValueHigh = ( ((systemClock >> 2u) + (baud >> 1u)) / baud ) - 1u;
9D001680  00061882   SRL V1, A2, 2
9D001684  00651821   ADDU V1, V1, A1
9D001688  0062001B   DIVU V1, V0
9D00168C  004001F4   TEQ V0, ZERO
9D001690  00001812   MFLO V1
9D001694  2463FFFF   ADDIU V1, V1, -1
125:                 
126:                     /* Check if the baud value can be set with high baud settings */
127:                     if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
9D001698  3C070001   LUI A3, 1
9D00169C  0067382B   SLTU A3, V1, A3
9D0016A0  50E00006   BEQL A3, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0016A4  24030008   ADDIU V1, ZERO, 8
128:                     {
129:                         /* Set BRGH */
130:                         usart->UxMODESET = UxMODE_BRGH_MASK;
9D0016A8  24020008   ADDIU V0, ZERO, 8
9D0016AC  AC820008   SW V0, 8(A0)
131:                         usart->UxBRG = brgValueHigh;
9D0016B0  AC830040   SW V1, 64(A0)
132:                     }
133:                     else
134:                     {
135:                         /* Clear BRGH */
136:                         usart->UxMODECLR = UxMODE_BRGH_MASK;
9D0016BC  AC830004   SW V1, 4(A0)
137:                         usart->UxBRG = brgValueLow;
9D0016D8  AC850040   SW A1, 64(A0)
138:                     }
139:                 
140:                     /* Enable the UART */
141:                     usart->UxMODESET = UxMODE_ON_MASK;
9D0016B4  0B4005B8   J 0x9D0016E0
9D0016B8  34028000   ORI V0, ZERO, -32768
9D0016DC  34028000   ORI V0, ZERO, -32768
9D0016E0  AC820008   SW V0, 8(A0)
9D0016E4  03E00008   JR RA
9D0016E8  00000000   NOP
142:                 }
143:                 
144:                 #endif /*_USART_ENABLECONTROL_DEFAULT_H*/
145:                 
146:                 /******************************************************************************
147:                  End of File
148:                 */
149:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_baudratehigh_in16bitregister.h
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRateHigh_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRateHigh
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRateHigh
16:                          PLIB_USART_BaudRateHighSet
17:                          PLIB_USART_BaudRateHighDisable
18:                          PLIB_USART_BaudRateHighEnable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _USART_BAUDRATEHIGH_IN16BITREGISTER_H
49:                  #define _USART_BAUDRATEHIGH_IN16BITREGISTER_H
50:                  
51:                  #include "usart_registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  USART_ExistsBaudRateHigh_In16BitRegister
55:                  
56:                    Summary:
57:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRateHigh
58:                  
59:                    Description:
60:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRateHigh function.
61:                  */
62:                  
63:                  #define PLIB_USART_ExistsBaudRateHigh PLIB_USART_ExistsBaudRateHigh
64:                  PLIB_TEMPLATE bool USART_ExistsBaudRateHigh_In16BitRegister( USART_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  USART_BaudRateHighSet_In16BitRegister
72:                  
73:                    Summary:
74:                      Implements In16BitRegister variant of PLIB_USART_BaudRateHighSet 
75:                  
76:                    Description:
77:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void USART_BaudRateHighSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
81:                  {
82:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
83:                      uint32_t brg = 0;
84:                      
85:                      brg = ( ((clockFrequency >> 2) + (baudRate >> 1)) / baudRate ) - 1; 
00000064  00000000   NOP
86:                      usart->UxBRG = brg;
00000084  00000000   NOP
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  USART_BaudRateHighDisable_In16BitRegister
92:                  
93:                    Summary:
94:                      Implements In16BitRegister variant of PLIB_USART_BaudRateHighDisable 
95:                  
96:                    Description:
97:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighDisable function.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void USART_BaudRateHighDisable_In16BitRegister( USART_MODULE_ID index )
101:                 {
102:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
103:                     usart->UxMODECLR = UxMODE_BRGH_MASK;
000000A4  00000000   NOP
104:                 }
105:                 
106:                 
107:                 //******************************************************************************
108:                 /* Function :  USART_BaudRateHighEnable_In16BitRegister
109:                 
110:                   Summary:
111:                     Implements In16BitRegister variant of PLIB_USART_BaudRateHighEnable 
112:                 
113:                   Description:
114:                     This template implements the In16BitRegister variant of the PLIB_USART_BaudRateHighEnable function.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void USART_BaudRateHighEnable_In16BitRegister( USART_MODULE_ID index )
118:                 {
119:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
120:                     usart->UxMODESET = UxMODE_BRGH_MASK;
0000005C  00000000   NOP
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_BAUDRATEHIGH_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/usart/templates/usart_baudrate_in16bitregister.h  -
1:                   /*******************************************************************************
2:                     USART Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       usart_BaudRate_In16BitRegister.h
6:                   
7:                     Summary:
8:                       USART PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRate
13:                      and its Variant : In16BitRegister
14:                      For following APIs :
15:                          PLIB_USART_ExistsBaudRate
16:                          PLIB_USART_BaudRateSet
17:                          PLIB_USART_BaudRateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _USART_BAUDRATE_IN16BITREGISTER_H
48:                  #define _USART_BAUDRATE_IN16BITREGISTER_H
49:                  
50:                  #include "usart_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  USART_ExistsBaudRate_In16BitRegister
54:                  
55:                    Summary:
56:                      Implements In16BitRegister variant of PLIB_USART_ExistsBaudRate
57:                  
58:                    Description:
59:                      This template implements the In16BitRegister variant of the PLIB_USART_ExistsBaudRate function.
60:                  */
61:                  
62:                  #define PLIB_USART_ExistsBaudRate PLIB_USART_ExistsBaudRate
63:                  PLIB_TEMPLATE bool USART_ExistsBaudRate_In16BitRegister( USART_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  USART_BaudRateSet_In16BitRegister
71:                  
72:                    Summary:
73:                      Implements In16BitRegister variant of PLIB_USART_BaudRateSet 
74:                  
75:                    Description:
76:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void USART_BaudRateSet_In16BitRegister( USART_MODULE_ID index , uint32_t clockFrequency , uint32_t baudRate )
80:                  {
81:                      usart_registers_t volatile * usart = ((usart_registers_t *)(index));
82:                      uint32_t brg;
83:                  
84:                      brg = ( ((clockFrequency >> 4) + (baudRate >> 1)) / baudRate ) - 1;
000000AC  00000000   NOP
85:                      usart->UxBRG = brg;
000000CC  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  USART_BaudRateGet_In16BitRegister
91:                  
92:                    Summary:
93:                      Implements In16BitRegister variant of PLIB_USART_BaudRateGet 
94:                  
95:                    Description:
96:                      This template implements the In16BitRegister variant of the PLIB_USART_BaudRateGet function.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint32_t USART_BaudRateGet_In16BitRegister( USART_MODULE_ID index , int32_t clockFrequency )
100:                 {
101:                     usart_registers_t volatile * usart = ((usart_registers_t *)(index));
102:                     int32_t baudReg;
103:                     bool highEnableStatus;
104:                     uint32_t returnValue;
105:                     
106:                     baudReg = (int32_t)usart->UxBRG;
107:                     highEnableStatus = (bool)usart->UxMODE.BRGH ;
108:                     
109:                     if(highEnableStatus)
110:                     {
111:                         /* This is the formula for high baud rate selection */
112:                         returnValue = (clockFrequency/(4 *(baudReg + 1)));
113:                     }
114:                     else
115:                     {
116:                         /* This is the formula for normal baud rate selection */
117:                         returnValue = (clockFrequency/(16 *(baudReg + 1)));
118:                     }
119:                 
120:                     return returnValue;
121:                 }
122:                 
123:                 
124:                 #endif /*_USART_BAUDRATE_IN16BITREGISTER_H*/
125:                 
126:                 /******************************************************************************
127:                  End of File
128:                 */
129:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_remapoutput_pic32_2.h  ------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapOutput_PIC32_2.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapOutput
13:                      and its Variant : PIC32_2
14:                      For following APIs :
15:                          PLIB_PORTS_RemapOutput
16:                          PLIB_PORTS_ExistsRemapOutput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPOUTPUT_PIC32_2_H
47:                  #define _PORTS_REMAPOUTPUT_PIC32_2_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapOutput_PIC32_2
52:                  
53:                    Summary:
54:                      Implements PIC32_2 variant of PLIB_PORTS_RemapOutput 
55:                  
56:                    Description:
57:                      This template implements the PIC32_2 variant of the PLIB_PORTS_RemapOutput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapOutput_PIC32_2( PORTS_MODULE_ID      index , PORTS_REMAP_OUTPUT_FUNCTION outputFunction , PORTS_REMAP_OUTPUT_PIN      remapOutputPin )
61:                  {
62:                      *(&RPA0R + remapOutputPin) = ( ( *((SFR_TYPE *)(&RPA0R  + remapOutputPin)) ) & ~(_RPA0R_RPA0R_MASK) ) | ( (_RPA0R_RPA0R_MASK) & ((outputFunction)<<(_RPA0R_RPA0R_POSITION)) );
9D0025EC  3C03BF81   LUI V1, -16511
00000034  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapOutput_PIC32_2
68:                  
69:                    Summary:
70:                      Implements PIC32_2 variant of PLIB_PORTS_ExistsRemapOutput
71:                  
72:                    Description:
73:                      This template implements the PIC32_2 variant of the PLIB_PORTS_ExistsRemapOutput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapOutput PLIB_PORTS_ExistsRemapOutput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapOutput_PIC32_2( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPOUTPUT_PIC32_2_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_remapinput_default.h  -------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_RemapInput_default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : RemapInput
13:                      and its Variant : default
14:                      For following APIs :
15:                          PLIB_PORTS_RemapInput
16:                          PLIB_PORTS_ExistsRemapInput
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_REMAPINPUT_DEFAULT_H
47:                  #define _PORTS_REMAPINPUT_DEFAULT_H
48:                  
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PORTS_RemapInput_default
52:                  
53:                    Summary:
54:                      Implements default variant of PLIB_PORTS_RemapInput 
55:                  
56:                    Description:
57:                      This template implements the default variant of the PLIB_PORTS_RemapInput function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void PORTS_RemapInput_default( PORTS_MODULE_ID      index , PORTS_REMAP_INPUT_FUNCTION inputFunction , PORTS_REMAP_INPUT_PIN      remapInputPin )
61:                  {
62:                      *(&INT1R + inputFunction) = ( ( *((SFR_TYPE *)(&INT1R + inputFunction)) ) & ~(_INT1R_INT1R_MASK) ) | ( (_INT1R_INT1R_MASK) & ((remapInputPin)<<(_INT1R_INT1R_POSITION)) );
9D0025AC  3C04BF81   LUI A0, -16511
9D0025B0  2483FA04   ADDIU V1, A0, -1532
9D0025B4  8C65004C   LW A1, 76(V1)
9D0025B8  2402FFF0   ADDIU V0, ZERO, -16
9D0025BC  00A22824   AND A1, A1, V0
9D0025C0  AC65004C   SW A1, 76(V1)
9D0025C4  8C65000C   LW A1, 12(V1)
9D0025C8  00A22824   AND A1, A1, V0
9D0025CC  34A50003   ORI A1, A1, 3
9D0025D0  AC65000C   SW A1, 12(V1)
9D0025D4  8C85FA04   LW A1, -1532(A0)
9D0025D8  00A22824   AND A1, A1, V0
9D0025DC  AC85FA04   SW A1, -1532(A0)
9D0025E0  8C640008   LW A0, 8(V1)
9D0025E4  00822024   AND A0, A0, V0
9D0025E8  AC640008   SW A0, 8(V1)
00000034  00000000   NOP
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PORTS_ExistsRemapInput_default
68:                  
69:                    Summary:
70:                      Implements default variant of PLIB_PORTS_ExistsRemapInput
71:                  
72:                    Description:
73:                      This template implements the default variant of the PLIB_PORTS_ExistsRemapInput function.
74:                  */
75:                  
76:                  #define PLIB_PORTS_ExistsRemapInput PLIB_PORTS_ExistsRemapInput
77:                  PLIB_TEMPLATE bool PORTS_ExistsRemapInput_default( PORTS_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  #endif /*_PORTS_REMAPINPUT_DEFAULT_H*/
84:                  
85:                  /******************************************************************************
86:                   End of File
87:                  */
88:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_portswrite_mcu32_pps.h  -----
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsWrite_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsWrite
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinWrite
16:                          PLIB_PORTS_PinSet
17:                          PLIB_PORTS_PinClear
18:                          PLIB_PORTS_PinToggle
19:                          PLIB_PORTS_Write
20:                          PLIB_PORTS_Set
21:                          PLIB_PORTS_Toggle
22:                          PLIB_PORTS_Clear
23:                          PLIB_PORTS_ExistsPortsWrite
24:                  
25:                  *******************************************************************************/
26:                  
27:                  //DOM-IGNORE-BEGIN
28:                  /*******************************************************************************
29:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
30:                  
31:                  Microchip licenses to you the right to use, modify, copy and distribute
32:                  Software only when embedded on a Microchip microcontroller or digital signal
33:                  controller that is integrated into your product or third party product
34:                  (pursuant to the sublicense terms in the accompanying license agreement).
35:                  
36:                  You should refer to the license agreement accompanying this Software for
37:                  additional information regarding your rights and obligations.
38:                  
39:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
46:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
48:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                  *******************************************************************************/
50:                  
51:                  //DOM-IGNORE-END
52:                  
53:                  #ifndef _PORTS_PORTSWRITE_MCU32_PPS_H
54:                  #define _PORTS_PORTSWRITE_MCU32_PPS_H
55:                  
56:                  
57:                  //******************************************************************************
58:                  /* Function :  PORTS_PinWrite_MCU32_PPS
59:                  
60:                    Summary:
61:                      Implements MCU32_PPS variant of PLIB_PORTS_PinWrite 
62:                  
63:                    Description:
64:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinWrite function.
65:                  */
66:                  
67:                  PLIB_TEMPLATE void PORTS_PinWrite_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos , bool            value )
68:                  {
69:                      /* Atomic Implementation */
70:                      if(value == true)
00000004  00000000   NOP
71:                      {
72:                          *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
0000000C  00000000   NOP
73:                      }
74:                      else
75:                      {
76:                          *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000038  00000000   NOP
77:                      }
78:                  }
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  PORTS_PinSet_MCU32_PPS
83:                  
84:                    Summary:
85:                      Implements MCU32_PPS variant of PLIB_PORTS_PinSet 
86:                  
87:                    Description:
88:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinSet function.
89:                  */
90:                  
91:                  PLIB_TEMPLATE void PORTS_PinSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
92:                  {
93:                  
94:                      *(&LATBSET + (channel - 1) * 0x40) = 1<<bitPos;
95:                      
96:                  }
97:                  
98:                  
99:                  //******************************************************************************
100:                 /* Function :  PORTS_PinClear_MCU32_PPS
101:                 
102:                   Summary:
103:                     Implements MCU32_PPS variant of PLIB_PORTS_PinClear 
104:                 
105:                   Description:
106:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinClear function.
107:                 */
108:                 
109:                 PLIB_TEMPLATE void PORTS_PinClear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
110:                 {
111:                 	
112:                     *(&LATBCLR + (channel - 1) * 0x40) = 1<<bitPos;	
00000000  00000000   NOP
00000014  00000000   NOP
113:                 						   
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_PinToggle_MCU32_PPS
119:                 
120:                   Summary:
121:                     Implements MCU32_PPS variant of PLIB_PORTS_PinToggle 
122:                 
123:                   Description:
124:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_PinToggle function.
125:                 */
126:                 
127:                 PLIB_TEMPLATE void PORTS_PinToggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
128:                 {
129:                 
130:                     *(&LATBINV + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
131:                 						   
132:                 }
133:                 
134:                 
135:                 //******************************************************************************
136:                 /* Function :  PORTS_Write_MCU32_PPS
137:                 
138:                   Summary:
139:                     Implements MCU32_PPS variant of PLIB_PORTS_Write 
140:                 
141:                   Description:
142:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Write function.
143:                 */
144:                 
145:                 PLIB_TEMPLATE void PORTS_Write_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value )
146:                 {
147:                     *(&LATB + (channel - 1) * 0x40) = value;
9D00251C  3C09BF88   LUI T1, -16504
9D002520  25226130   ADDIU V0, T1, 24880
9D002524  24030018   ADDIU V1, ZERO, 24
9D002528  AC43FF00   SW V1, -256(V0)
9D002588  AD206130   SW ZERO, 24880(T1)
00000000  00000000   NOP
148:                 }
149:                 
150:                 
151:                 //******************************************************************************
152:                 /* Function :  PORTS_Set_MCU32_PPS
153:                 
154:                   Summary:
155:                     Implements MCU32_PPS variant of PLIB_PORTS_Set 
156:                 
157:                   Description:
158:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Set function.
159:                 */
160:                 
161:                 PLIB_TEMPLATE void PORTS_Set_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_TYPE value , PORTS_DATA_MASK mask )
162:                 {
163:                     
164:                     *(&LATBSET + (channel - 1) * 0x40) = (value & mask);
165:                 	
166:                 }
167:                 
168:                 
169:                 //******************************************************************************
170:                 /* Function :  PORTS_Toggle_MCU32_PPS
171:                 
172:                   Summary:
173:                     Implements MCU32_PPS variant of PLIB_PORTS_Toggle 
174:                 
175:                   Description:
176:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Toggle function.
177:                 */
178:                 
179:                 PLIB_TEMPLATE void PORTS_Toggle_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK toggleMask )
180:                 {
181:                     *(&LATBINV + (channel - 1) * 0x40) = toggleMask;
182:                 }
183:                 
184:                 
185:                 //******************************************************************************
186:                 /* Function :  PORTS_Clear_MCU32_PPS
187:                 
188:                   Summary:
189:                     Implements MCU32_PPS variant of PLIB_PORTS_Clear 
190:                 
191:                   Description:
192:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_Clear function.
193:                 */
194:                 
195:                 PLIB_TEMPLATE void PORTS_Clear_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK clearMask )
196:                 {
197:                     
198:                     *(&LATBCLR + (channel - 1) * 0x40) = clearMask;	
00000004  00000000   NOP
199:                 						 
200:                 }
201:                 
202:                 
203:                 //******************************************************************************
204:                 /* Function :  PORTS_ExistsPortsWrite_MCU32_PPS
205:                 
206:                   Summary:
207:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsWrite
208:                 
209:                   Description:
210:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsWrite function.
211:                 */
212:                 
213:                 #define PLIB_PORTS_ExistsPortsWrite PLIB_PORTS_ExistsPortsWrite
214:                 PLIB_TEMPLATE bool PORTS_ExistsPortsWrite_MCU32_PPS( PORTS_MODULE_ID index )
215:                 {
216:                     return true;
217:                 }
218:                 
219:                 
220:                 #endif /*_PORTS_PORTSWRITE_MCU32_PPS_H*/
221:                 
222:                 /******************************************************************************
223:                  End of File
224:                 */
225:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_portsread_mcu32_pps.h  ------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsRead_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsRead
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinGet
16:                          PLIB_PORTS_Read
17:                          PLIB_PORTS_ExistsPortsRead
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PORTSREAD_MCU32_PPS_H
48:                  #define _PORTS_PORTSREAD_MCU32_PPS_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinGet_MCU32_PPS
53:                  
54:                    Summary:
55:                      Implements MCU32_PPS variant of PLIB_PORTS_PinGet 
56:                  
57:                    Description:
58:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinGet function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE bool PORTS_PinGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
62:                  {
63:                      return (bool)((*(&PORTB + ((channel - 1) * 0x40)) >> bitPos) & 1);
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_Read_MCU32_PPS
69:                  
70:                    Summary:
71:                      Implements MCU32_PPS variant of PLIB_PORTS_Read 
72:                  
73:                    Description:
74:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_Read function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE PORTS_DATA_TYPE PORTS_Read_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
78:                  {
79:                      return (*(&PORTB + ((channel - 1) * 0x40)));
00000000  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsPortsRead_MCU32_PPS
85:                  
86:                    Summary:
87:                      Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsRead
88:                  
89:                    Description:
90:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsRead function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsPortsRead PLIB_PORTS_ExistsPortsRead
94:                  PLIB_TEMPLATE bool PORTS_ExistsPortsRead_MCU32_PPS( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_PORTSREAD_MCU32_PPS_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsOpenDrain_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsOpenDrain
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinOpenDrainEnable
16:                          PLIB_PORTS_PinOpenDrainDisable
17:                          PLIB_PORTS_OpenDrainEnable
18:                          PLIB_PORTS_OpenDrainDisable
19:                          PLIB_PORTS_ExistsPortsOpenDrain
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
50:                  #define _PORTS_PORTSOPENDRAIN_MCU32_PPS_H
51:                  
52:                  
53:                  
54:                  
55:                  //******************************************************************************
56:                  /* Function :  PORTS_PinOpenDrainEnable_MCU32_PPS
57:                  
58:                    Summary:
59:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainEnable 
60:                  
61:                    Description:
62:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainEnable function.
63:                  */
64:                  
65:                  PLIB_TEMPLATE void PORTS_PinOpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
66:                  {
67:                      *(&ODCBSET + (channel - 1) * 0x40) = 1<<bitPos;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  PORTS_PinOpenDrainDisable_MCU32_PPS
73:                  
74:                    Summary:
75:                      Implements MCU32_PPS variant of PLIB_PORTS_PinOpenDrainDisable 
76:                  
77:                    Description:
78:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinOpenDrainDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void PORTS_PinOpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
82:                  {
83:                      *(&ODCBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000000  00000000   NOP
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  PORTS_OpenDrainEnable_MCU32_PPS
89:                  
90:                    Summary:
91:                      Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainEnable 
92:                  
93:                    Description:
94:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainEnable function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE void PORTS_OpenDrainEnable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
98:                  {
99:                      *(&ODCBSET + (channel - 1) * 0x40) = mask;
9D002510  3C0ABF88   LUI T2, -16504
9D002514  25426148   ADDIU V0, T2, 24904
9D002518  AC40FF00   SW ZERO, -256(V0)
9D002584  AD406148   SW ZERO, 24904(T2)
100:                 }
101:                 
102:                 
103:                 //******************************************************************************
104:                 /* Function :  PORTS_OpenDrainDisable_MCU32_PPS
105:                 
106:                   Summary:
107:                     Implements MCU32_PPS variant of PLIB_PORTS_OpenDrainDisable 
108:                 
109:                   Description:
110:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_OpenDrainDisable function.
111:                 */
112:                 
113:                 PLIB_TEMPLATE void PORTS_OpenDrainDisable_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
114:                 {
115:                     *(&ODCBCLR + (channel - 1) * 0x40) = mask;
00000004  00000000   NOP
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  PORTS_ExistsPortsOpenDrain_MCU32_PPS
121:                 
122:                   Summary:
123:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsOpenDrain
124:                 
125:                   Description:
126:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsOpenDrain function.
127:                 */
128:                 
129:                 #define PLIB_PORTS_ExistsPortsOpenDrain PLIB_PORTS_ExistsPortsOpenDrain
130:                 PLIB_TEMPLATE bool PORTS_ExistsPortsOpenDrain_MCU32_PPS( PORTS_MODULE_ID index )
131:                 {
132:                     return true;
133:                 }
134:                 
135:                 
136:                 #endif /*_PORTS_PORTSOPENDRAIN_MCU32_PPS_H*/
137:                 
138:                 /******************************************************************************
139:                  End of File
140:                 */
141:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_portsdirection_mcu32_pps.h  -
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PortsDirection_MCU32_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PortsDirection
13:                      and its Variant : MCU32_PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinDirectionInputSet
16:                          PLIB_PORTS_PinDirectionOutputSet
17:                          PLIB_PORTS_DirectionInputSet
18:                          PLIB_PORTS_DirectionOutputSet
19:                          PLIB_PORTS_DirectionGet
20:                          PLIB_PORTS_ExistsPortsDirection
21:                  
22:                  *******************************************************************************/
23:                  
24:                  //DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                  *******************************************************************************/
47:                  
48:                  //DOM-IGNORE-END
49:                  
50:                  #ifndef _PORTS_PORTSDIRECTION_MCU32_PPS_H
51:                  #define _PORTS_PORTSDIRECTION_MCU32_PPS_H
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinDirectionInputSet_MCU32_PPS
56:                  
57:                    Summary:
58:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionInputSet 
59:                  
60:                    Description:
61:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionInputSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinDirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
65:                  {
66:                      *(&TRISBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000034  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinDirectionOutputSet_MCU32_PPS
72:                  
73:                    Summary:
74:                      Implements MCU32_PPS variant of PLIB_PORTS_PinDirectionOutputSet 
75:                  
76:                    Description:
77:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_PinDirectionOutputSet function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinDirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_BIT_POS       bitPos )
81:                  {
82:                      *(&TRISBCLR + (channel - 1) * 0x40) = 1<<bitPos;
00000008  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_DirectionInputSet_MCU32_PPS
88:                  
89:                    Summary:
90:                      Implements MCU32_PPS variant of PLIB_PORTS_DirectionInputSet 
91:                  
92:                    Description:
93:                      This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionInputSet function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_DirectionInputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
97:                  {
98:                      *(&TRISBSET + (channel - 1) * 0x40) = mask;
0000000C  00000000   NOP
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_DirectionOutputSet_MCU32_PPS
104:                 
105:                   Summary:
106:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionOutputSet 
107:                 
108:                   Description:
109:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionOutputSet function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_DirectionOutputSet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel , PORTS_DATA_MASK mask )
113:                 {
114:                     *(&TRISBCLR + (channel - 1) * 0x40) = mask;
9D00252C  3C08BF88   LUI T0, -16504
9D002530  25026114   ADDIU V0, T0, 24852
9D002534  24030019   ADDIU V1, ZERO, 25
9D002538  AC43FF00   SW V1, -256(V0)
9D00258C  24094000   ADDIU T1, ZERO, 16384
9D002590  AD096114   SW T1, 24852(T0)
00000034  00000000   NOP
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_DirectionGet_MCU32_PPS
120:                 
121:                   Summary:
122:                     Implements MCU32_PPS variant of PLIB_PORTS_DirectionGet 
123:                 
124:                   Description:
125:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_DirectionGet function.
126:                 */
127:                 
128:                 PLIB_TEMPLATE PORTS_DATA_MASK PORTS_DirectionGet_MCU32_PPS( PORTS_MODULE_ID index , PORTS_CHANNEL channel )
129:                 {
130:                     return ( *(&TRISB + (channel - 1) * 0x40) );
00000000  00000000   NOP
131:                 }
132:                 
133:                 
134:                 //******************************************************************************
135:                 /* Function :  PORTS_ExistsPortsDirection_MCU32_PPS
136:                 
137:                   Summary:
138:                     Implements MCU32_PPS variant of PLIB_PORTS_ExistsPortsDirection
139:                 
140:                   Description:
141:                     This template implements the MCU32_PPS variant of the PLIB_PORTS_ExistsPortsDirection function.
142:                 */
143:                 
144:                 #define PLIB_PORTS_ExistsPortsDirection PLIB_PORTS_ExistsPortsDirection
145:                 PLIB_TEMPLATE bool PORTS_ExistsPortsDirection_MCU32_PPS( PORTS_MODULE_ID index )
146:                 {
147:                     return true;
148:                 }
149:                 
150:                 
151:                 #endif /*_PORTS_PORTSDIRECTION_MCU32_PPS_H*/
152:                 
153:                 /******************************************************************************
154:                  End of File
155:                 */
156:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_pinmodeperport_default.h  ---
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinModePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinModePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinModePerPortSelect
16:                          PLIB_PORTS_ChannelModeSelect
17:                          PLIB_PORTS_ExistsPinModePerPort
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_PINMODEPERPORT_DEFAULT_H
48:                  #define _PORTS_PINMODEPERPORT_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModePerPortSelect_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_PinModePerPortSelect 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_PinModePerPortSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModePerPortSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos , PORTS_PIN_MODE   mode )
62:                  {
63:                      if ( mode == PORTS_PIN_MODE_ANALOG )
64:                  	{
65:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;	
66:                  	}
67:                  	else
68:                  	{
69:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
70:                  	}
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  PORTS_ChannelModeSelect_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_PORTS_ChannelModeSelect 
79:                  
80:                    Description:
81:                      This template implements the Default variant of the PLIB_PORTS_ChannelModeSelect function.
82:                  */
83:                  
84:                  PLIB_TEMPLATE void PORTS_ChannelModeSelect_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK   modeMask , PORTS_PIN_MODE mode )
85:                  {
86:                      if ( mode == PORTS_PIN_MODE_ANALOG )
87:                  	{
88:                          *(&ANSELBSET + (channel - 1) * 0x40) = modeMask;	
89:                  	}
90:                  	else
91:                  	{
92:                          *(&ANSELBCLR + (channel - 1) * 0x40) = modeMask;
9D00254C  3C05BF88   LUI A1, -16504
9D002550  24A26104   ADDIU V0, A1, 24836
9D002554  2403001F   ADDIU V1, ZERO, 31
9D002558  AC43FF00   SW V1, -256(V0)
9D002598  3406FFFE   ORI A2, ZERO, -2
9D00259C  ACA66104   SW A2, 24836(A1)
93:                  	}
94:                  }
95:                  
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PORTS_ExistsPinModePerPort_Default
99:                  
100:                   Summary:
101:                     Implements Default variant of PLIB_PORTS_ExistsPinModePerPort
102:                 
103:                   Description:
104:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinModePerPort function.
105:                 */
106:                 
107:                 #define PLIB_PORTS_ExistsPinModePerPort PLIB_PORTS_ExistsPinModePerPort
108:                 PLIB_TEMPLATE bool PORTS_ExistsPinModePerPort_Default( PORTS_MODULE_ID index )
109:                 {
110:                     return true;
111:                 }
112:                 
113:                 
114:                 #endif /*_PORTS_PINMODEPERPORT_DEFAULT_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_pinmode_pps.h  --------------
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinMode_PPS.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinMode
13:                      and its Variant : PPS
14:                      For following APIs :
15:                          PLIB_PORTS_PinModeSelect
16:                          PLIB_PORTS_ExistsPinMode
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PORTS_PINMODE_PPS_H
47:                  #define _PORTS_PINMODE_PPS_H
48:                  
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_PinModeSelect_PPS
53:                  
54:                    Summary:
55:                      Implements PPS variant of PLIB_PORTS_PinModeSelect 
56:                  
57:                    Description:
58:                      This template implements the PPS variant of the PLIB_PORTS_PinModeSelect function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_PinModeSelect_PPS( PORTS_MODULE_ID  index , PORTS_ANALOG_PIN pin , PORTS_PIN_MODE   mode )
62:                  {
63:                  
64:                  uint8_t channel, bitPos;
65:                  
66:                      channel = pin/16;
00000000  00000000   NOP
67:                      bitPos = pin % 16;
68:                  
69:                      if ( mode == PORTS_PIN_MODE_ANALOG )
00000004  00000000   NOP
70:                  	{
71:                          *(&ANSELBSET + (channel - 1) * 0x40) = 1<<bitPos;
00000010  00000000   NOP
72:                  	}
73:                  	else
74:                  	{
75:                          *(&ANSELBCLR + (channel - 1) * 0x40) = 1<<bitPos;
0000003C  00000000   NOP
76:                  	}
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  PORTS_ExistsPinMode_PPS
81:                  
82:                    Summary:
83:                      Implements PPS variant of PLIB_PORTS_ExistsPinMode
84:                  
85:                    Description:
86:                      This template implements the PPS variant of the PLIB_PORTS_ExistsPinMode function.
87:                  */
88:                  
89:                  #define PLIB_PORTS_ExistsPinMode PLIB_PORTS_ExistsPinMode
90:                  PLIB_TEMPLATE bool PORTS_ExistsPinMode_PPS( PORTS_MODULE_ID index )
91:                  {
92:                      return true;
93:                  }
94:                  
95:                  
96:                  #endif /*_PORTS_PINMODE_PPS_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_pinchangenoticeperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_PinChangeNoticePerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PinChangeNoticePerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_PinChangeNoticePerPortEnable
16:                          PLIB_PORTS_PinChangeNoticePerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticeEnable
18:                          PLIB_PORTS_ChannelChangeNoticeDisable
19:                          PLIB_PORTS_ExistsPinChangeNoticePerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
50:                  #define _PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H
51:                  
52:                  
53:                  
54:                  //******************************************************************************
55:                  /* Function :  PORTS_PinChangeNoticePerPortEnable_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortEnable 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortEnable function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
65:                  {
66:                      *(&CNENBSET + (channel - 1) * 0x40) = 1<<bitPos;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  PORTS_PinChangeNoticePerPortDisable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_PORTS_PinChangeNoticePerPortDisable 
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_PORTS_PinChangeNoticePerPortDisable function.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void PORTS_PinChangeNoticePerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
81:                  {
82:                      *(&CNENBCLR + (channel - 1) * 0x40) = 1<<bitPos;
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  PORTS_ChannelChangeNoticeEnable_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticeEnable 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeEnable function.
94:                  */
95:                  
96:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticeEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
97:                  {
98:                      *(&CNENBSET + (channel - 1) * 0x40) = mask;
9D00255C  3C04BF88   LUI A0, -16504
9D002560  24826188   ADDIU V0, A0, 24968
9D002564  AC40FF00   SW ZERO, -256(V0)
9D0025A0  AC806188   SW ZERO, 24968(A0)
99:                  }
100:                 
101:                 
102:                 //******************************************************************************
103:                 /* Function :  PORTS_ChannelChangeNoticeDisable_Default
104:                 
105:                   Summary:
106:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticeDisable 
107:                 
108:                   Description:
109:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticeDisable function.
110:                 */
111:                 
112:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticeDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
113:                 {
114:                     *(&CNENBCLR + (channel - 1) * 0x40) = mask;
115:                 }
116:                 
117:                 
118:                 //******************************************************************************
119:                 /* Function :  PORTS_ExistsPinChangeNoticePerPort_Default
120:                 
121:                   Summary:
122:                     Implements Default variant of PLIB_PORTS_ExistsPinChangeNoticePerPort
123:                 
124:                   Description:
125:                     This template implements the Default variant of the PLIB_PORTS_ExistsPinChangeNoticePerPort function.
126:                 */
127:                 
128:                 #define PLIB_PORTS_ExistsPinChangeNoticePerPort PLIB_PORTS_ExistsPinChangeNoticePerPort
129:                 PLIB_TEMPLATE bool PORTS_ExistsPinChangeNoticePerPort_Default( PORTS_MODULE_ID index )
130:                 {
131:                     return true;
132:                 }
133:                 
134:                 
135:                 #endif /*_PORTS_PINCHANGENOTICEPERPORT_DEFAULT_H*/
136:                 
137:                 /******************************************************************************
138:                  End of File
139:                 */
140:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_changenoticepullupperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullUpPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullUpPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullUpPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullUpPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullUpEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullUpDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullUpPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullUpPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPUBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullUpPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullUpPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullUpPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullUpPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPUBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  //******************************************************************************
85:                  /* Function :  PORTS_ChannelChangeNoticePullUpEnable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpEnable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpEnable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
95:                  {
96:                      *(&CNPUBSET + (channel - 1) * 0x40) = mask;
9D002568  3C03BF88   LUI V1, -16504
9D00256C  24626158   ADDIU V0, V1, 24920
9D002570  240B0010   ADDIU T3, ZERO, 16
9D002574  AC4BFF00   SW T3, -256(V0)
9D0025A4  AC606158   SW ZERO, 24920(V1)
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  PORTS_ChannelChangeNoticePullUpDisable_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullUpDisable 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullUpDisable function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullUpDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
111:                 {
112:                     *(&CNPUBCLR + (channel - 1) * 0x40) = mask;
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  PORTS_ExistsChangeNoticePullUpPerPort_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullUpPerPort
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullUpPerPort function.
124:                 */
125:                 
126:                 #define PLIB_PORTS_ExistsChangeNoticePullUpPerPort PLIB_PORTS_ExistsChangeNoticePullUpPerPort
127:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullUpPerPort_Default( PORTS_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_PORTS_CHANGENOTICEPULLUPPERPORT_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_changenoticepulldownperport_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePullDownPerPort_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePullDownPerPort
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePullDownPerPortEnable
16:                          PLIB_PORTS_ChangeNoticePullDownPerPortDisable
17:                          PLIB_PORTS_ChannelChangeNoticePullDownEnable
18:                          PLIB_PORTS_ChannelChangeNoticePullDownDisable
19:                          PLIB_PORTS_ExistsChangeNoticePullDownPerPort
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
50:                  #define _PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H
51:                  
52:                  
53:                  //******************************************************************************
54:                  /* Function :  PORTS_ChangeNoticePullDownPerPortEnable_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortEnable 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
64:                  {
65:                      *(&CNPDBSET + (channel - 1) * 0x40) = 1<<bitPos;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  PORTS_ChangeNoticePullDownPerPortDisable_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_PORTS_ChangeNoticePullDownPerPortDisable 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePullDownPerPortDisable function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void PORTS_ChangeNoticePullDownPerPortDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_BIT_POS  bitPos )
80:                  {
81:                      *(&CNPDBCLR + (channel - 1) * 0x40) = 1<<bitPos;
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  PORTS_ChannelChangeNoticePullDownEnable_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownEnable 
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownEnable function.
93:                  */
94:                  
95:                  PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownEnable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
96:                  {
97:                      *(&CNPDBSET + (channel - 1) * 0x40) = mask;
9D002578  3C02BF88   LUI V0, -16504
9D00257C  244B6168   ADDIU T3, V0, 24936
9D002580  AD60FF00   SW ZERO, -256(T3)
9D0025A8  AC406168   SW ZERO, 24936(V0)
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  PORTS_ChannelChangeNoticePullDownDisable_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_PORTS_ChannelChangeNoticePullDownDisable 
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_PORTS_ChannelChangeNoticePullDownDisable function.
109:                 */
110:                 
111:                 PLIB_TEMPLATE void PORTS_ChannelChangeNoticePullDownDisable_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel , PORTS_DATA_MASK  mask )
112:                 {
113:                     *(&CNPDBCLR + (channel - 1) * 0x40) = mask;
114:                 }
115:                 
116:                 
117:                 //******************************************************************************
118:                 /* Function :  PORTS_ExistsChangeNoticePullDownPerPort_Default
119:                 
120:                   Summary:
121:                     Implements Default variant of PLIB_PORTS_ExistsChangeNoticePullDownPerPort
122:                 
123:                   Description:
124:                     This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePullDownPerPort function.
125:                 */
126:                 
127:                 #define PLIB_PORTS_ExistsChangeNoticePullDownPerPort PLIB_PORTS_ExistsChangeNoticePullDownPerPort
128:                 PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePullDownPerPort_Default( PORTS_MODULE_ID index )
129:                 {
130:                     return true;
131:                 }
132:                 
133:                 
134:                 #endif /*_PORTS_CHANGENOTICEPULLDOWNPERPORT_DEFAULT_H*/
135:                 
136:                 /******************************************************************************
137:                  End of File
138:                 */
139:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/ports/templates/ports_changenoticeperportturnon_default.h
1:                   /*******************************************************************************
2:                     PORTS Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       ports_ChangeNoticePerPortTurnOn_Default.h
6:                   
7:                     Summary:
8:                       PORTS PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChangeNoticePerPortTurnOn
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PORTS_ChangeNoticePerPortTurnOn
16:                          PLIB_PORTS_ChangeNoticePerPortTurnOff
17:                          PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
48:                  #define _PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H
49:                  
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PORTS_ChangeNoticePerPortTurnOn_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOn 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOn function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
62:                  {
63:                      *(&CNCONBSET + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
9D00253C  3C06BF88   LUI A2, -16504
9D002540  24C26178   ADDIU V0, A2, 24952
9D002544  34078000   ORI A3, ZERO, -32768
9D002548  AC47FF00   SW A3, -256(V0)
9D002594  ACC76178   SW A3, 24952(A2)
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  PORTS_ChangeNoticePerPortTurnOff_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_PORTS_ChangeNoticePerPortTurnOff 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_PORTS_ChangeNoticePerPortTurnOff function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void PORTS_ChangeNoticePerPortTurnOff_Default( PORTS_MODULE_ID  index , PORTS_CHANNEL channel )
78:                  {
79:                      *(&CNCONBCLR + (channel - 1) * 0x40) = _CNCONB_ON_MASK;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  PORTS_ExistsChangeNoticePerPortTurnOn_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_PORTS_ExistsChangeNoticePerPortTurnOn function.
91:                  */
92:                  
93:                  #define PLIB_PORTS_ExistsChangeNoticePerPortTurnOn PLIB_PORTS_ExistsChangeNoticePerPortTurnOn
94:                  PLIB_TEMPLATE bool PORTS_ExistsChangeNoticePerPortTurnOn_Default( PORTS_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 #endif /*_PORTS_CHANGENOTICEPERPORTTURNON_DEFAULT_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_operationmode_default.h  --------
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_OperationMode_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OperationMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsOperationMode
16:                          PLIB_PMP_OperationModeSelect
17:                          PLIB_PMP_OperationModeGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PMP_OPERATIONMODE_DEFAULT_H
48:                  #define _PMP_OPERATIONMODE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PMP_ExistsOperationMode_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_PMP_ExistsOperationMode
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_PMP_ExistsOperationMode function.
58:                  */
59:                  #define PLIB_PMP_ExistsOperationMode PLIB_PMP_ExistsOperationMode
60:                  PLIB_TEMPLATE bool PMP_ExistsOperationMode_Default( PMP_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  PMP_OperationModeSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_PMP_OperationModeSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_PMP_OperationModeSelect function.
73:                  */
74:                  PLIB_TEMPLATE void PMP_OperationModeSelect_Default( PMP_MODULE_ID index , PMP_OPERATION_MODE operationMode )
75:                  {
76:                      PMMODEbits.MODE = operationMode;
9D0035F4  3C02BF80   LUI V0, -16512
9D0035F8  94437010   LHU V1, 28688(V0)
9D0035FC  24040002   ADDIU A0, ZERO, 2
9D003600  7C834A04   INS V1, A0, 8, 2
9D003604  A4437010   SH V1, 28688(V0)
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  PMP_OperationModeGet_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_PMP_OperationModeGet 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_PMP_OperationModeGet function.
87:                  */
88:                  
89:                  PLIB_TEMPLATE PMP_OPERATION_MODE PMP_OperationModeGet_Default( PMP_MODULE_ID index )
90:                  {
91:                      return (PMP_OPERATION_MODE) (((PMMODE) & (_PMMODE_MODE_MASK)) >> (_PMMODE_MODE_POSITION));
92:                  }
93:                  
94:                  #endif /*_PMP_OPERATIONMODE_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_masterrxtx_default.h  -----------
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_MasterRXTX_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterRXTX
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsMasterRXTX
16:                          PLIB_PMP_MasterSend
17:                          PLIB_PMP_MasterReceive
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _PMP_MASTERRXTX_DEFAULT_H
48:                  #define _PMP_MASTERRXTX_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  PMP_ExistsMasterRXTX_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_PMP_ExistsMasterRXTX
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_PMP_ExistsMasterRXTX function.
58:                  */
59:                  #define PLIB_PMP_ExistsMasterRXTX PLIB_PMP_ExistsMasterRXTX
60:                  PLIB_TEMPLATE bool PMP_ExistsMasterRXTX_Default( PMP_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  PMP_MasterSend_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_PMP_MasterSend 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_PMP_MasterSend function.
73:                  */
74:                  PLIB_TEMPLATE void PMP_MasterSend_Default( PMP_MODULE_ID index , uint16_t data )
75:                  {
76:                      PMDIN = (uint32_t)data;
00000004  00000000   NOP
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  PMP_MasterReceive_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_PMP_MasterReceive 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_PMP_MasterReceive function.
87:                  */
88:                  
89:                  PLIB_TEMPLATE uint16_t PMP_MasterReceive_Default( PMP_MODULE_ID index )
90:                  {
91:                      return (( uint16_t ) (PMDIN));
00000000  00000000   NOP
92:                  }
93:                  
94:                  #endif /*_PMP_MASTERRXTX_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_enablecontrol_default.h  --------
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsEnableControl
16:                          PLIB_PMP_Disable
17:                          PLIB_PMP_Enable
18:                          PLIB_PMP_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _PMP_ENABLECONTROL_DEFAULT_H
49:                  #define _PMP_ENABLECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  PMP_ExistsEnableControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_PMP_ExistsEnableControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_PMP_ExistsEnableControl function.
59:                  */
60:                  #define PLIB_PMP_ExistsEnableControl PLIB_PMP_ExistsEnableControl
61:                  PLIB_TEMPLATE bool PMP_ExistsEnableControl_Default( PMP_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  PMP_Disable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_PMP_Disable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_PMP_Disable function.
74:                  */
75:                  PLIB_TEMPLATE void PMP_Disable_Default( PMP_MODULE_ID index )
76:                  {
77:                      PMCONCLR = (_PMCON_ON_MASK);
9D003874  34028000   ORI V0, ZERO, -32768
9D003878  3C03BF80   LUI V1, -16512
9D00387C  AC627004   SW V0, 28676(V1)
78:                  }
79:                  
80:                  //******************************************************************************
81:                  /* Function :  PMP_Enable_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_PMP_Enable 
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_PMP_Enable function.
88:                  */
89:                  
90:                  PLIB_TEMPLATE void PMP_Enable_Default( PMP_MODULE_ID index )
91:                  {
92:                      PMCONSET = (_PMCON_ON_MASK);
9D003880  3C03BF80   LUI V1, -16512
93:                  }
94:                  
95:                  //******************************************************************************
96:                  /* Function :  PMP_IsEnabled_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_PMP_IsEnabled 
100:                 
101:                   Description:
102:                     This template implements the Default variant of the PLIB_PMP_IsEnabled function.
103:                 */
104:                 
105:                 PLIB_TEMPLATE bool PMP_IsEnabled_Default( PMP_MODULE_ID index )
106:                 {
107:                     return ((PMCON) & (_PMCON_ON_MASK));
108:                 }
109:                 
110:                 #endif /*_PMP_ENABLECONTROL_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_datastrobewaitstates_default.h  -
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_DataStrobeWaitStates_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataStrobeWaitStates
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsDataStrobeWaitStates
16:                          PLIB_PMP_WaitStatesStrobeSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PMP_DATASTROBEWAITSTATES_DEFAULT_H
47:                  #define _PMP_DATASTROBEWAITSTATES_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Function :  PMP_ExistsDataStrobeWaitStates_Default
51:                  
52:                    Summary:
53:                      Implements Default variant of PLIB_PMP_ExistsDataStrobeWaitStates
54:                  
55:                    Description:
56:                      This template implements the Default variant of the PLIB_PMP_ExistsDataStrobeWaitStates function.
57:                  */
58:                  #define PLIB_PMP_ExistsDataStrobeWaitStates PLIB_PMP_ExistsDataStrobeWaitStates
59:                  PLIB_TEMPLATE bool PMP_ExistsDataStrobeWaitStates_Default( PMP_MODULE_ID index )
60:                  {
61:                      return true;
62:                  }
63:                  
64:                  //******************************************************************************
65:                  /* Function :  PMP_WaitStatesStrobeSelect_Default
66:                  
67:                    Summary:
68:                      Implements Default variant of PLIB_PMP_WaitStatesStrobeSelect 
69:                  
70:                    Description:
71:                      This template implements the Default variant of the PLIB_PMP_WaitStatesStrobeSelect function.
72:                  */
73:                  PLIB_TEMPLATE void PMP_WaitStatesStrobeSelect_Default( PMP_MODULE_ID index , PMP_STROBE_WAIT_STATES strobeWaitState )
74:                  {
75:                      PMMODEbits.WAITM = strobeWaitState;
9D003614  94437010   LHU V1, 28688(V0)
9D003618  24040004   ADDIU A0, ZERO, 4
9D00361C  7C832884   INS V1, A0, 2, 4
9D003620  A4437010   SH V1, 28688(V0)
00000010  00000000   NOP
76:                  }
77:                  
78:                  #endif /*_PMP_DATASTROBEWAITSTATES_DEFAULT_H*/
79:                  
80:                  /******************************************************************************
81:                   End of File
82:                  */
83:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_datasetupwaitstates_default.h  --
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_DataSetUpWaitStates_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataSetUpWaitStates
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsDataSetUpWaitStates
16:                          PLIB_PMP_WaitStatesDataSetUpSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PMP_DATASETUPWAITSTATES_DEFAULT_H
47:                  #define _PMP_DATASETUPWAITSTATES_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Function :  PMP_ExistsDataSetUpWaitStates_Default
51:                  
52:                    Summary:
53:                      Implements Default variant of PLIB_PMP_ExistsDataSetUpWaitStates
54:                  
55:                    Description:
56:                      This template implements the Default variant of the PLIB_PMP_ExistsDataSetUpWaitStates function.
57:                  */
58:                  #define PLIB_PMP_ExistsDataSetUpWaitStates PLIB_PMP_ExistsDataSetUpWaitStates
59:                  PLIB_TEMPLATE bool PMP_ExistsDataSetUpWaitStates_Default( PMP_MODULE_ID index )
60:                  {
61:                      return true;
62:                  }
63:                  
64:                  //******************************************************************************
65:                  /* Function :  PMP_WaitStatesDataSetUpSelect_Default
66:                  
67:                    Summary:
68:                      Implements Default variant of PLIB_PMP_WaitStatesDataSetUpSelect 
69:                  
70:                    Description:
71:                      This template implements the Default variant of the PLIB_PMP_WaitStatesDataSetUpSelect function.
72:                  */
73:                  PLIB_TEMPLATE void PMP_WaitStatesDataSetUpSelect_Default( PMP_MODULE_ID index , PMP_DATA_WAIT_STATES dataWaitState )
74:                  {
75:                      PMMODEbits.WAITB = dataWaitState;
9D003608  94437010   LHU V1, 28688(V0)
9D00360C  7C033984   INS V1, ZERO, 6, 2
9D003610  A4437010   SH V1, 28688(V0)
00000000  00000000   NOP
76:                  }
77:                  
78:                  #endif /*_PMP_DATASETUPWAITSTATES_DEFAULT_H*/
79:                  
80:                  /******************************************************************************
81:                   End of File
82:                  */
83:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_dataholdwaitstates_default.h  ---
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_DataHoldWaitStates_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataHoldWaitStates
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsDataHoldWaitStates
16:                          PLIB_PMP_WaitStatesDataHoldSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PMP_DATAHOLDWAITSTATES_DEFAULT_H
47:                  #define _PMP_DATAHOLDWAITSTATES_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Function :  PMP_ExistsDataHoldWaitStates_Default
51:                  
52:                    Summary:
53:                      Implements Default variant of PLIB_PMP_ExistsDataHoldWaitStates
54:                  
55:                    Description:
56:                      This template implements the Default variant of the PLIB_PMP_ExistsDataHoldWaitStates function.
57:                  */
58:                  #define PLIB_PMP_ExistsDataHoldWaitStates PLIB_PMP_ExistsDataHoldWaitStates
59:                  PLIB_TEMPLATE bool PMP_ExistsDataHoldWaitStates_Default( PMP_MODULE_ID index )
60:                  {
61:                      return true;
62:                  }
63:                  
64:                  //******************************************************************************
65:                  /* Function :  PMP_WaitStatesDataHoldSelect_Default
66:                  
67:                    Summary:
68:                      Implements Default variant of PLIB_PMP_WaitStatesDataHoldSelect 
69:                  
70:                    Description:
71:                      This template implements the Default variant of the PLIB_PMP_WaitStatesDataHoldSelect function.
72:                  */
73:                  PLIB_TEMPLATE void PMP_WaitStatesDataHoldSelect_Default( PMP_MODULE_ID index , PMP_DATA_HOLD_STATES dataHoldState )
74:                  {
75:                      PMMODEbits.WAITE = dataHoldState;
9D003624  94437010   LHU V1, 28688(V0)
0000001C  00000000   NOP
76:                  }
77:                  
78:                  #endif /*_PMP_DATAHOLDWAITSTATES_DEFAULT_H*/
79:                  
80:                  /******************************************************************************
81:                   End of File
82:                  */
83:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/pmp/templates/pmp_busystatus_default.h  -----------
1:                   /*******************************************************************************
2:                     PMP Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       pmp_BusyStatus_Default.h
6:                   
7:                     Summary:
8:                       PMP PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BusyStatus
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_PMP_ExistsBusyStatus
16:                          PLIB_PMP_PortIsBusy
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _PMP_BUSYSTATUS_DEFAULT_H
47:                  #define _PMP_BUSYSTATUS_DEFAULT_H
48:                  
49:                  //******************************************************************************
50:                  /* Function :  PMP_ExistsBusyStatus_Default
51:                  
52:                    Summary:
53:                      Implements Default variant of PLIB_PMP_ExistsBusyStatus
54:                  
55:                    Description:
56:                      This template implements the Default variant of the PLIB_PMP_ExistsBusyStatus function.
57:                  */
58:                  #define PLIB_PMP_ExistsBusyStatus PLIB_PMP_ExistsBusyStatus
59:                  PLIB_TEMPLATE bool PMP_ExistsBusyStatus_Default( PMP_MODULE_ID index )
60:                  {
61:                      return true;
62:                  }
63:                  
64:                  //******************************************************************************
65:                  /* Function :  PMP_PortIsBusy_Default
66:                  
67:                    Summary:
68:                      Implements Default variant of PLIB_PMP_PortIsBusy 
69:                  
70:                    Description:
71:                      This template implements the Default variant of the PLIB_PMP_PortIsBusy function.
72:                  */
73:                  PLIB_TEMPLATE bool PMP_PortIsBusy_Default( PMP_MODULE_ID index )
74:                  {
75:                      return (PMMODE) & (_PMMODE_BUSY_MASK);
0000000C  00000000   NOP
76:                  }
77:                  
78:                  #endif /*_PMP_BUSYSTATUS_DEFAULT_H*/
79:                  
80:                  /******************************************************************************
81:                   End of File
82:                  */
83:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_secondaryenable_default.h  ------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_SecondaryEnable_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SecondaryEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsSecondaryEnable
16:                          PLIB_OSC_SecondaryEnable
17:                          PLIB_OSC_SecondaryDisable
18:                          PLIB_OSC_SecondaryIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_SECONDARYENABLE_DEFAULT_H
49:                  #define _OSC_SECONDARYENABLE_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsSecondaryEnable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_OSC_ExistsSecondaryEnable
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_OSC_ExistsSecondaryEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsSecondaryEnable PLIB_OSC_ExistsSecondaryEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsSecondaryEnable_Default( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_SecondaryEnable_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_OSC_SecondaryEnable 
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_OSC_SecondaryEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_SecondaryEnable_Default( OSC_MODULE_ID index )
79:                  {
80:                      OSCCONSET = _OSCCON_SOSCEN_MASK;
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_SecondaryDisable_Default
86:                  
87:                    Summary:
88:                      Implements Default variant of PLIB_OSC_SecondaryDisable 
89:                  
90:                    Description:
91:                      This template implements the Default variant of the PLIB_OSC_SecondaryDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_SecondaryDisable_Default( OSC_MODULE_ID index )
95:                  {
96:                      OSCCONCLR = _OSCCON_SOSCEN_MASK;
00000024  00000000   NOP
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_SecondaryIsEnabled_Default
102:                 
103:                   Summary:
104:                     Implements Default variant of PLIB_OSC_SecondaryIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the Default variant of the PLIB_OSC_SecondaryIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_SecondaryIsEnabled_Default( OSC_MODULE_ID index )
111:                 {
112:                    return (bool)OSCCONbits.SOSCEN;
00000000  00000000   NOP
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_SECONDARYENABLE_DEFAULT_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_referenceoutputenable_pic32_1.h  
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOutputEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOutputEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOutputEnable
16:                          PLIB_OSC_ReferenceOutputEnable
17:                          PLIB_OSC_ReferenceOutputDisable
18:                          PLIB_OSC_ReferenceOutputIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOUTPUTENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOutputEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOutputEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOutputEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOutputEnable PLIB_OSC_ExistsReferenceOutputEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOutputEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOutputEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_OE_MASK;
9D002FE0  24021000   ADDIU V0, ZERO, 4096
9D002FE4  AC62F028   SW V0, -4056(V1)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOutputDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOutputDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_OE_MASK;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOutputIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOutputIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOutputIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOutputIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.OE;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOUTPUTENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_referenceosctrim_pic32_1.h  -----
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscTrim_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscTrim
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscTrim
16:                          PLIB_OSC_ReferenceOscTrimSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCTRIM_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCTRIM_PIC32_1_H
48:                  
49:                  // *****************************************************************************
50:                  /* Reference clock out trim type.
51:                  
52:                    Summary:
53:                      Defines Reference clock out trim type.
54:                  
55:                    Description:
56:                      This macro defines the Reference clock out trim type.
57:                  
58:                    Remarks:
59:                      None
60:                  */
61:                  
62:                  #define OSC_REF_TRIM_TYPE						SFR_TYPE
63:                  //******************************************************************************
64:                  /* Function :  OSC_ExistsReferenceOscTrim_PIC32_1
65:                  
66:                    Summary:
67:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscTrim
68:                  
69:                    Description:
70:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscTrim function.
71:                  */
72:                  
73:                  #define PLIB_OSC_ExistsReferenceOscTrim PLIB_OSC_ExistsReferenceOscTrim
74:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscTrim_PIC32_1( OSC_MODULE_ID index )
75:                  {
76:                      return true;
77:                  }
78:                  
79:                  
80:                  //******************************************************************************
81:                  /* Function :  OSC_ReferenceOscTrimSet_PIC32_1
82:                  
83:                    Summary:
84:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscTrimSet 
85:                  
86:                    Description:
87:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscTrimSet function.
88:                  */
89:                  
90:                  PLIB_TEMPLATE void OSC_ReferenceOscTrimSet_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_TRIM_TYPE trimValue )
91:                  {
92:                      REFOTRIMbits.ROTRIM = trimValue;
9D002FC8  3C02BF81   LUI V0, -16511
9D002FCC  8C44F030   LW A0, -4048(V0)
9D002FD0  7C04FDC4   INS A0, ZERO, 23, 9
9D002FD4  AC44F030   SW A0, -4048(V0)
93:                  }
94:                  
95:                  
96:                  #endif /*_OSC_REFERENCEOSCTRIM_PIC32_1_H*/
97:                  
98:                  /******************************************************************************
99:                   End of File
100:                 */
101:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_referenceoscenable_pic32_1.h  ---
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscEnable_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscEnable
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscEnable
16:                          PLIB_OSC_ReferenceOscEnable
17:                          PLIB_OSC_ReferenceOscDisable
18:                          PLIB_OSC_ReferenceOscIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _OSC_REFERENCEOSCENABLE_PIC32_1_H
49:                  #define _OSC_REFERENCEOSCENABLE_PIC32_1_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  OSC_ExistsReferenceOscEnable_PIC32_1
53:                  
54:                    Summary:
55:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscEnable
56:                  
57:                    Description:
58:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscEnable function.
59:                  */
60:                  
61:                  #define PLIB_OSC_ExistsReferenceOscEnable PLIB_OSC_ExistsReferenceOscEnable
62:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscEnable_PIC32_1( OSC_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  OSC_ReferenceOscEnable_PIC32_1
70:                  
71:                    Summary:
72:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscEnable 
73:                  
74:                    Description:
75:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscEnable function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void OSC_ReferenceOscEnable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
79:                  {
80:                      REFOCONSET = _REFOCON_ON_MASK;
9D002FD8  34028000   ORI V0, ZERO, -32768
9D002FDC  AC62F028   SW V0, -4056(V1)
81:                  }
82:                  
83:                  
84:                  //******************************************************************************
85:                  /* Function :  OSC_ReferenceOscDisable_PIC32_1
86:                  
87:                    Summary:
88:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscDisable 
89:                  
90:                    Description:
91:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscDisable function.
92:                  */
93:                  
94:                  PLIB_TEMPLATE void OSC_ReferenceOscDisable_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
95:                  {
96:                      REFOCONCLR = _REFOCON_ON_MASK;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_ReferenceOscIsEnabled_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOscIsEnabled 
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscIsEnabled function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE bool OSC_ReferenceOscIsEnabled_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc )
111:                 {
112:                     return (bool)REFOCONbits.ON;
113:                 }
114:                 
115:                 
116:                 #endif /*_OSC_REFERENCEOSCENABLE_PIC32_1_H*/
117:                 
118:                 /******************************************************************************
119:                  End of File
120:                 */
121:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_referenceoscdivisor_pic32_1.h  --
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscDivisor
16:                          PLIB_OSC_ReferenceOscDivisorValueSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCDIVISOR_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCDIVISOR_PIC32_1_H
48:                  
49:                  // *****************************************************************************
50:                  /* Reference divisor type
51:                  
52:                    Summary:
53:                      Defines Reference clock devisor type.
54:                  
55:                    Description:
56:                      This macro defines Reference clock divisor type.
57:                  
58:                    Remarks:
59:                      None
60:                  */
61:                  
62:                  #define OSC_REF_DIVISOR_TYPE  				SFR_TYPE
63:                  
64:                  
65:                  // *****************************************************************************
66:                  /* Oscillator Reference Bus count
67:                  
68:                    Summary:
69:                      The number of Reference clock buses in available in the device.
70:                  
71:                    Description:
72:                      This macro gives the number of Reference clock buses in available in the device.
73:                  
74:                    Remarks:
75:                      None
76:                  */
77:                  
78:                  #define REFERENCE_BUSES_MAX						1
79:                  
80:                  
81:                  //******************************************************************************
82:                  /* Function :  OSC_ExistsReferenceOscDivisor_PIC32_1
83:                  
84:                    Summary:
85:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscDivisor
86:                  
87:                    Description:
88:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscDivisor function.
89:                  */
90:                  
91:                  #define PLIB_OSC_ExistsReferenceOscDivisor PLIB_OSC_ExistsReferenceOscDivisor
92:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscDivisor_PIC32_1( OSC_MODULE_ID index )
93:                  {
94:                      return true;
95:                  }
96:                  
97:                  
98:                  //******************************************************************************
99:                  /* Function :  OSC_ReferenceOscDivisorValueSet_PIC32_1
100:                 
101:                   Summary:
102:                     Implements PIC32_1 variant of PLIB_OSC_ReferenceOscDivisorValueSet
103:                 
104:                   Description:
105:                     This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscDivisorValueSet function.
106:                 */
107:                 
108:                 PLIB_TEMPLATE void OSC_ReferenceOscDivisorValueSet_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_DIVISOR_TYPE refOscDivValue )
109:                 {
110:                     REFOCONbits.RODIV = refOscDivValue;
9D002FB8  8C44F020   LW A0, -4064(V0)
9D002FBC  24050003   ADDIU A1, ZERO, 3
9D002FC0  7CA4F404   INS A0, A1, 16, 15
9D002FC4  AC44F020   SW A0, -4064(V0)
111:                 }
112:                 
113:                 
114:                 #endif /*_OSC_REFERENCEOSCDIVISOR_PIC32_1_H*/
115:                 
116:                 /******************************************************************************
117:                  End of File
118:                 */
119:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_referenceoscbaseclock_pic32_1.h  
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_ReferenceOscBaseClock_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReferenceOscBaseClock
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsReferenceOscBaseClock
16:                          PLIB_OSC_ReferenceOscBaseClockSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _OSC_REFERENCEOSCBASECLOCK_PIC32_1_H
47:                  #define _OSC_REFERENCEOSCBASECLOCK_PIC32_1_H
48:                  
49:                  
50:                  // *****************************************************************************
51:                  /* Reference oscillator clock divisor maximum value.
52:                  
53:                    Summary:
54:                      Defines the Reference oscillator clock divisor maximum value.
55:                  
56:                    Description:
57:                      This macro defines the Reference oscillator clock divisor maximum value.
58:                  
59:                    Remarks:
60:                      None
61:                  */
62:                  
63:                  #define CLK_REFERENCE_DIVISOR_MAX					0xFFFF
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  OSC_ExistsReferenceOscBaseClock_PIC32_1
68:                  
69:                    Summary:
70:                      Implements PIC32_1 variant of PLIB_OSC_ExistsReferenceOscBaseClock
71:                  
72:                    Description:
73:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsReferenceOscBaseClock function.
74:                  */
75:                  
76:                  #define PLIB_OSC_ExistsReferenceOscBaseClock PLIB_OSC_ExistsReferenceOscBaseClock
77:                  PLIB_TEMPLATE bool OSC_ExistsReferenceOscBaseClock_PIC32_1( OSC_MODULE_ID index )
78:                  {
79:                      return true;
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_ReferenceOscBaseClockSelect_PIC32_1
85:                  
86:                    Summary:
87:                      Implements PIC32_1 variant of PLIB_OSC_ReferenceOscBaseClockSelect
88:                  
89:                    Description:
90:                      This template implements the PIC32_1 variant of the PLIB_OSC_ReferenceOscBaseClockSelect function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE void OSC_ReferenceOscBaseClockSelect_PIC32_1( OSC_MODULE_ID index , OSC_REFERENCE referenceOsc , OSC_REF_BASECLOCK refOscBaseClock )
94:                  {
95:                      REFOCONbits.ROSEL = refOscBaseClock;
9D002F9C  3C02BF81   LUI V0, -16511
9D002FA0  8C43F020   LW V1, -4064(V0)
9D002FA4  7C031804   INS V1, ZERO, 0, 4
9D002FA8  AC43F020   SW V1, -4064(V0)
96:                      REFOCONSET = _REFOCON_DIVSWEN_MASK;
9D002FAC  3C03BF81   LUI V1, -16511
9D002FB0  24040200   ADDIU A0, ZERO, 512
9D002FB4  AC64F028   SW A0, -4056(V1)
97:                  }
98:                  
99:                  
100:                 #endif /*_OSC_REFERENCEOSCBASECLOCK_PIC32_1_H*/
101:                 
102:                 /******************************************************************************
103:                  End of File
104:                 */
105:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_pbclockdivisor_pic32_1.h  -------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_PBClockDivisor_PIC32_1.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : PBClockDivisor
13:                      and its Variant : PIC32_1
14:                      For following APIs :
15:                          PLIB_OSC_ExistsPBClockDivisor
16:                          PLIB_OSC_PBClockDivisorGet
17:                          PLIB_OSC_PBClockDivisorSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_PBCLOCKDIVISOR_PIC32_1_H
48:                  #define _OSC_PBCLOCKDIVISOR_PIC32_1_H
49:                  
50:                  
51:                  // *****************************************************************************
52:                  /* Oscillator Peripheral Bus Clock Divisor Value Type
53:                  
54:                    Summary:
55:                      Type of the oscillator PB Clock divisor value.
56:                  
57:                    Description:
58:                      This macro defines the type of the oscillator PB Clock divisor value.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define OSC_PB_CLOCK_DIV_TYPE						SFR_TYPE
65:                  
66:                  
67:                  // *****************************************************************************
68:                  /* Oscillator Peripheral Bus count
69:                  
70:                    Summary:
71:                      The number of Peripheral buses in available in the device.
72:                  
73:                    Description:
74:                      This macro gives the number of Peripheral buses in available in the device.
75:                  
76:                    Remarks:
77:                      None
78:                  */
79:                  
80:                  #define PERIPHERAL_BUSES_MAX						1
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_ExistsPBClockDivisor_PIC32_1
85:                  
86:                    Summary:
87:                      Implements PIC32_1 variant of PLIB_OSC_ExistsPBClockDivisor
88:                  
89:                    Description:
90:                      This template implements the PIC32_1 variant of the PLIB_OSC_ExistsPBClockDivisor function.
91:                  */
92:                  
93:                  #define PLIB_OSC_ExistsPBClockDivisor PLIB_OSC_ExistsPBClockDivisor
94:                  PLIB_TEMPLATE bool OSC_ExistsPBClockDivisor_PIC32_1( OSC_MODULE_ID index )
95:                  {
96:                      return true;
97:                  }
98:                  
99:                  
100:                 //******************************************************************************
101:                 /* Function :  OSC_PBClockDivisorGet_PIC32_1
102:                 
103:                   Summary:
104:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorGet
105:                 
106:                   Description:
107:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorGet function.
108:                 */
109:                 
110:                 PLIB_TEMPLATE OSC_PB_CLOCK_DIV_TYPE OSC_PBClockDivisorGet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber )
111:                 {
112:                     return (OSC_PB_CLOCK_DIV_TYPE)(0x01u << OSCCONbits.PBDIV);
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  OSC_PBClockDivisorSet_PIC32_1
118:                 
119:                   Summary:
120:                     Implements PIC32_1 variant of PLIB_OSC_PBClockDivisorSet
121:                 
122:                   Description:
123:                     This template implements the PIC32_1 variant of the PLIB_OSC_PBClockDivisorSet function.
124:                 */
125:                 
126:                 PLIB_TEMPLATE void OSC_PBClockDivisorSet_PIC32_1( OSC_MODULE_ID index , OSC_PERIPHERAL_BUS peripheralBusNumber , OSC_PB_CLOCK_DIV_TYPE peripheralBusClkDiv )
127:                 {
128:                     uint8_t regValue;
129:                 
130:                     for (regValue = 0u; regValue < 4u; regValue++)
131:                     {
132:                         if ( peripheralBusClkDiv == ( 0x01u << regValue ) )
133:                         {
134:                             OSCCONbits.PBDIV = regValue;
9D002F90  8C43F000   LW V1, -4096(V0)
9D002F94  7C03A4C4   INS V1, ZERO, 19, 2
9D002F98  AC43F000   SW V1, -4096(V0)
135:                             return;
136:                         }
137:                     }
138:                     PLIB_ASSERT(false, "Given PB Divisor value is not supported for the selected device");
139:                 }
140:                 
141:                 
142:                 #endif /*_OSC_PBCLOCKDIVISOR_PIC32_1_H*/
143:                 
144:                 /******************************************************************************
145:                  End of File
146:                 */
147:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_onwaitaction_default.h  ---------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_OnWaitAction_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : OnWaitAction
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsOnWaitAction
16:                          PLIB_OSC_OnWaitActionSet
17:                          PLIB_OSC_OnWaitActionGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_ONWAITACTION_DEFAULT_H
48:                  #define _OSC_ONWAITACTION_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsOnWaitAction_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsOnWaitAction
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsOnWaitAction function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsOnWaitAction PLIB_OSC_ExistsOnWaitAction
61:                  PLIB_TEMPLATE bool OSC_ExistsOnWaitAction_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_OnWaitActionSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_OnWaitActionSet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionSet function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_OnWaitActionSet_Default( OSC_MODULE_ID index , OSC_OPERATION_ON_WAIT onWait )
78:                  {
79:                      OSCCONbits.SLPEN = onWait;
00000018  00000000   NOP
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_OnWaitActionGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_OnWaitActionGet 
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_OnWaitActionGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE OSC_OPERATION_ON_WAIT OSC_OnWaitActionGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      return (OSC_OPERATION_ON_WAIT)OSCCONbits.SLPEN;
96:                  }
97:                  
98:                  
99:                  #endif /*_OSC_ONWAITACTION_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/osc/templates/osc_frcdivisor_default.h  -----------
1:                   /*******************************************************************************
2:                     OSC Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       osc_FRCDivisor_Default.h
6:                   
7:                     Summary:
8:                       OSC PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : FRCDivisor
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_OSC_ExistsFRCDivisor
16:                          PLIB_OSC_FRCDivisorSelect
17:                          PLIB_OSC_FRCDivisorGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _OSC_FRCDIVISOR_DEFAULT_H
48:                  #define _OSC_FRCDIVISOR_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  OSC_ExistsFRCDivisor_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_OSC_ExistsFRCDivisor
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_OSC_ExistsFRCDivisor function.
58:                  */
59:                  
60:                  #define PLIB_OSC_ExistsFRCDivisor PLIB_OSC_ExistsFRCDivisor
61:                  PLIB_TEMPLATE bool OSC_ExistsFRCDivisor_Default( OSC_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  
67:                  //******************************************************************************
68:                  /* Function :  OSC_FRCDivisorSelect_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_OSC_FRCDivisorSelect 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorSelect function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE void OSC_FRCDivisorSelect_Default( OSC_MODULE_ID index , OSC_FRC_DIV divisorFRC )
78:                  {
79:                      OSCCONbits.FRCDIV = divisorFRC;
9D002F7C  3C02BF81   LUI V0, -16511
9D002F80  8C43F000   LW V1, -4096(V0)
9D002F84  24040001   ADDIU A0, ZERO, 1
9D002F88  7C83D604   INS V1, A0, 24, 3
9D002F8C  AC43F000   SW V1, -4096(V0)
80:                  }
81:                  
82:                  
83:                  //******************************************************************************
84:                  /* Function :  OSC_FRCDivisorGet_Default
85:                  
86:                    Summary:
87:                      Implements Default variant of PLIB_OSC_FRCDivisorGet
88:                  
89:                    Description:
90:                      This template implements the Default variant of the PLIB_OSC_FRCDivisorGet function.
91:                  */
92:                  
93:                  PLIB_TEMPLATE uint16_t OSC_FRCDivisorGet_Default( OSC_MODULE_ID index )
94:                  {
95:                      uint16_t returnValue  = 0u;
96:                  
97:                      if ( OSCCONbits.FRCDIV != 7u )
98:                      {
99:                          returnValue = ( 1u << OSCCONbits.FRCDIV );
100:                     }
101:                     else
102:                     {
103:                         returnValue = 256u;
104:                     }
105:                 
106:                     return returnValue;
107:                 }
108:                 
109:                 
110:                 #endif /*_OSC_FRCDIVISOR_DEFAULT_H*/
111:                 
112:                 /******************************************************************************
113:                  End of File
114:                 */
115:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_vectorselect_default.h  ---------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorSelect
16:                          PLIB_INT_MultiVectorSelect
17:                          PLIB_INT_SingleVectorSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_VECTORSELECT_DEFAULT_H
48:                  #define _INT_VECTORSELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsVectorSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsVectorSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsVectorSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsVectorSelect PLIB_INT_ExistsVectorSelect
60:                  PLIB_TEMPLATE bool INT_ExistsVectorSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_MultiVectorSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_MultiVectorSelect 
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_MultiVectorSelect function.
73:                  */
74:                  PLIB_TEMPLATE void INT_MultiVectorSelect_Default( INT_MODULE_ID index )
75:                  {
76:                      INTCONSET = _INTCON_MVEC_MASK;
9D0038D0  24031000   ADDIU V1, ZERO, 4096
9D0038D4  3C02BF88   LUI V0, -16504
9D0038D8  AC431008   SW V1, 4104(V0)
9D0038DC  03E00008   JR RA
9D0038E0  00000000   NOP
77:                  }
78:                  
79:                  //******************************************************************************
80:                  /* Function :  INT_SingleVectorSelect_Default
81:                  
82:                    Summary:
83:                      Implements Default variant of PLIB_INT_SingleVectorSelect 
84:                  
85:                    Description:
86:                      This template implements the Default variant of the PLIB_INT_SingleVectorSelect function.
87:                  */
88:                  PLIB_TEMPLATE void INT_SingleVectorSelect_Default( INT_MODULE_ID index )
89:                  {
90:                      INTCONCLR = _INTCON_MVEC_MASK;
91:                  }
92:                  
93:                  #endif /*_INT_VECTORSELECT_DEFAULT_H*/
94:                  
95:                  /******************************************************************************
96:                   End of File
97:                  */
98:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_vectorpriority_default.h  -------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_VectorPriority_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : VectorPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsVectorPriority
16:                          PLIB_INT_VectorPrioritySet
17:                          PLIB_INT_VectorPriorityGet
18:                          PLIB_INT_VectorSubPrioritySet
19:                          PLIB_INT_VectorSubPriorityGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _INT_VECTORPRIORITY_DEFAULT_H
50:                  #define _INT_VECTORPRIORITY_DEFAULT_H
51:                  
52:                  //******************************************************************************
53:                  /* Function :  INT_ExistsVectorPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_INT_ExistsVectorPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_INT_ExistsVectorPriority function.
60:                  */
61:                  #define PLIB_INT_ExistsVectorPriority PLIB_INT_ExistsVectorPriority
62:                  PLIB_TEMPLATE bool INT_ExistsVectorPriority_Default( INT_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  //******************************************************************************
68:                  /* Function :  INT_VectorPrioritySet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_INT_VectorPrioritySet 
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_INT_VectorPrioritySet function.
75:                  
76:                    Note:
77:                      The algorithm to calculate and write the field location has changed to use
78:                      actual vector numbers. The enumeration for INT_VECTOR should now match the
79:                      names to the actual vector numbers.
80:                  */
81:                  PLIB_TEMPLATE void INT_VectorPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_PRIORITY_LEVEL priority )
82:                  {
83:                      volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
84:                      uint32_t mask = 0x07 << ((vector & 0x03) * 8 + 2);
85:                      uint32_t position = (vector & 0x03) * 8 + 2;
86:                  
87:                      /* read-modify-write */
88:                      *IPCx &= ~mask;
9D000D74  3C10BF88   LUI S0, -16504
9D000D78  26101090   ADDIU S0, S0, 4240
9D000D7C  8E030090   LW V1, 144(S0)
9D000D80  3C02FFE3   LUI V0, -29
9D000D84  3442FFFF   ORI V0, V0, -1
9D000D88  00621024   AND V0, V1, V0
9D000D8C  AE020090   SW V0, 144(S0)
9D000DE4  8E0200A0   LW V0, 160(S0)
9D000DE8  2413FFE3   ADDIU S3, ZERO, -29
9D000DEC  00531024   AND V0, V0, S3
9D000DF0  AE0200A0   SW V0, 160(S0)
9D000E3C  8E020080   LW V0, 128(S0)
9D000E40  00539824   AND S3, V0, S3
9D000E44  AE130080   SW S3, 128(S0)
9D000E70  8E020030   LW V0, 48(S0)
9D000E74  3C13E3FF   LUI S3, -7169
9D000E78  3673FFFF   ORI S3, S3, -1
9D000E7C  00531024   AND V0, V0, S3
9D000E80  AE020030   SW V0, 48(S0)
9D000EC4  8E020010   LW V0, 16(S0)
9D000EC8  00531024   AND V0, V0, S3
9D000ECC  AE020010   SW V0, 16(S0)
9D000F04  8E020040   LW V0, 64(S0)
9D000F08  00539824   AND S3, V0, S3
9D000F0C  AE130040   SW S3, 64(S0)
9D000FAC  3C02BF88   LUI V0, -16504
9D000FB0  8C441090   LW A0, 4240(V0)
9D000FB4  2403E3FF   ADDIU V1, ZERO, -7169
9D000FB8  00831824   AND V1, A0, V1
9D000FBC  AC431090   SW V1, 4240(V0)
9D000FF4  8C441090   LW A0, 4240(V0)
9D000FF8  3C03FFE3   LUI V1, -29
9D000FFC  3463FFFF   ORI V1, V1, -1
9D001000  00831824   AND V1, A0, V1
9D001004  AC431090   SW V1, 4240(V0)
89:                      *IPCx |= (priority << position) & mask;
9D000D90  8E030090   LW V1, 144(S0)
9D000D94  3C020018   LUI V0, 24
9D000D98  00621025   OR V0, V1, V0
9D000D9C  AE020090   SW V0, 144(S0)
9D000DF4  8E0200A0   LW V0, 160(S0)
9D000DF8  34420014   ORI V0, V0, 20
9D000DFC  AE0200A0   SW V0, 160(S0)
9D000E48  8E020080   LW V0, 128(S0)
9D000E4C  34420004   ORI V0, V0, 4
9D000E50  AE020080   SW V0, 128(S0)
9D000E84  8E020030   LW V0, 48(S0)
9D000E88  3C120C00   LUI S2, 3072
9D000E8C  00521025   OR V0, V0, S2
9D000E90  AE020030   SW V0, 48(S0)
9D000ED0  8E020010   LW V0, 16(S0)
9D000ED4  00521025   OR V0, V0, S2
9D000ED8  AE020010   SW V0, 16(S0)
9D000F10  8E020040   LW V0, 64(S0)
9D000F14  00529025   OR S2, V0, S2
9D000F18  AE120040   SW S2, 64(S0)
9D000FC0  8C431090   LW V1, 4240(V0)
9D000FC4  34631800   ORI V1, V1, 6144
9D000FC8  AC431090   SW V1, 4240(V0)
9D001008  8C441090   LW A0, 4240(V0)
9D00100C  3C03001C   LUI V1, 28
9D001010  00831825   OR V1, A0, V1
9D001014  AC431090   SW V1, 4240(V0)
90:                  }
91:                  
92:                  //******************************************************************************
93:                  /* Function :  INT_VectorPriorityGet_Default
94:                  
95:                    Summary:
96:                      Implements Default variant of PLIB_INT_VectorPriorityGet 
97:                  
98:                    Description:
99:                      This template implements the Default variant of the PLIB_INT_VectorPriorityGet function.
100:                 
101:                   Note:
102:                     The algorithm to calculate and write the field location has changed to use
103:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
104:                     names to the actual vector numbers.
105:                 */
106:                 PLIB_TEMPLATE INT_PRIORITY_LEVEL INT_VectorPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
107:                 {
108:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
109:                     uint32_t mask = 0x07 << (((vector & 0x03) * 8) + 2);
110:                     uint32_t position = (((vector & 0x03) * 8) + 2);
111:                 
112:                     return (INT_PRIORITY_LEVEL) ((*IPCx & mask) >> position);
113:                 }
114:                 
115:                 //******************************************************************************
116:                 /* Function :  INT_VectorSubPrioritySet_Default
117:                 
118:                   Summary:
119:                     Implements Default variant of PLIB_INT_VectorSubPrioritySet 
120:                 
121:                   Description:
122:                     This template implements the Default variant of the PLIB_INT_VectorSubPrioritySet function.
123:                 
124:                   Note:
125:                     The algorithm to calculate and write the field location has changed to use
126:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
127:                     names to the actual vector numbers.
128:                 */
129:                 PLIB_TEMPLATE void INT_VectorSubPrioritySet_Default( INT_MODULE_ID index , INT_VECTOR vector , INT_SUBPRIORITY_LEVEL subPriority )
130:                 {
131:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
132:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
133:                     uint32_t position = (vector & 0x03) * 8;
134:                 
135:                     /* read-modify-write */
136:                     *IPCx &= ~mask; /* zeroed mask */
9D000DA0  8E030090   LW V1, 144(S0)
9D000DA4  3C02FFFC   LUI V0, -4
9D000DA8  3442FFFF   ORI V0, V0, -1
9D000DAC  00621024   AND V0, V1, V0
9D000DB0  AE020090   SW V0, 144(S0)
9D000E00  8E0200A0   LW V0, 160(S0)
9D000E04  2412FFFC   ADDIU S2, ZERO, -4
9D000E08  00521024   AND V0, V0, S2
9D000E0C  AE0200A0   SW V0, 160(S0)
9D000E54  8E020080   LW V0, 128(S0)
9D000E58  00529024   AND S2, V0, S2
9D000E5C  AE120080   SW S2, 128(S0)
9D000E94  8E020030   LW V0, 48(S0)
9D000E98  3C11FCFF   LUI S1, -769
9D000E9C  3631FFFF   ORI S1, S1, -1
9D000EA0  00511024   AND V0, V0, S1
9D000EA4  AE020030   SW V0, 48(S0)
9D000EDC  8E020010   LW V0, 16(S0)
9D000EE0  00511024   AND V0, V0, S1
9D000EE4  AE020010   SW V0, 16(S0)
9D000F1C  8E020040   LW V0, 64(S0)
9D000F20  00518824   AND S1, V0, S1
9D000F24  AE110040   SW S1, 64(S0)
9D000FCC  8C441090   LW A0, 4240(V0)
9D000FD0  2403FCFF   ADDIU V1, ZERO, -769
9D000FD4  00831824   AND V1, A0, V1
9D000FD8  AC431090   SW V1, 4240(V0)
9D001018  8C441090   LW A0, 4240(V0)
9D00101C  3C03FFFC   LUI V1, -4
9D001020  3463FFFF   ORI V1, V1, -1
9D001024  00831824   AND V1, A0, V1
9D001028  AC431090   SW V1, 4240(V0)
137:                     *IPCx |= (subPriority << position) & mask; /* set value */
9D000DB4  8E030090   LW V1, 144(S0)
9D000DB8  3C020001   LUI V0, 1
9D000DBC  00621025   OR V0, V1, V0
9D000DC0  AE020090   SW V0, 144(S0)
9D000E10  8E0200A0   LW V0, 160(S0)
9D000E14  AE0200A0   SW V0, 160(S0)
9D000E60  8E020080   LW V0, 128(S0)
9D000E64  AE020080   SW V0, 128(S0)
9D000EA8  8E030030   LW V1, 48(S0)
9D000EAC  3C020300   LUI V0, 768
9D000EB0  00621025   OR V0, V1, V0
9D000EB4  AE020030   SW V0, 48(S0)
9D000EE8  8E030010   LW V1, 16(S0)
9D000EEC  3C020200   LUI V0, 512
9D000EF0  00621025   OR V0, V1, V0
9D000EF4  AE020010   SW V0, 16(S0)
9D000F28  8E030040   LW V1, 64(S0)
9D000F2C  3C020100   LUI V0, 256
9D000F30  00621025   OR V0, V1, V0
9D000F34  AE020040   SW V0, 64(S0)
9D000FDC  8C431090   LW V1, 4240(V0)
9D000FE0  AC431090   SW V1, 4240(V0)
9D00102C  8C431090   LW V1, 4240(V0)
9D001030  AC431090   SW V1, 4240(V0)
138:                 }
139:                 
140:                 //******************************************************************************
141:                 /* Function :  INT_VectorSubPriorityGet_Default
142:                 
143:                   Summary:
144:                     Implements Default variant of PLIB_INT_VectorSubPriorityGet 
145:                 
146:                   Description:
147:                     This template implements the Default variant of the PLIB_INT_VectorSubPriorityGet function.
148:                 
149:                   Note:
150:                     The algorithm to calculate and write the field location has changed to use
151:                     actual vector numbers. The enumeration for INT_VECTOR should now match the
152:                     names to the actual vector numbers.
153:                 */
154:                 PLIB_TEMPLATE INT_SUBPRIORITY_LEVEL INT_VectorSubPriorityGet_Default( INT_MODULE_ID index , INT_VECTOR vector )
155:                 {
156:                     volatile uint32_t *IPCx = (volatile uint32_t *)(&IPC0 + ((0x10 * (vector >> 2)) >> 2));
157:                     uint32_t mask = 0x03 << ((vector & 0x03) * 8);
158:                     uint32_t position = (vector & 0x03) * 8;
159:                 
160:                     return (INT_SUBPRIORITY_LEVEL) ((*IPCx & mask) >> position);
161:                 }
162:                 
163:                 #endif /*_INT_VECTORPRIORITY_DEFAULT_H*/
164:                 
165:                 /******************************************************************************
166:                  End of File
167:                 */
168:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_sourceflag_default.h  -----------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceFlag_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceFlag
16:                          PLIB_INT_SourceFlagGet
17:                          PLIB_INT_SourceFlagSet
18:                          PLIB_INT_SourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCEFLAG_DEFAULT_H
49:                  #define _INT_SOURCEFLAG_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceFlag_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceFlag
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceFlag function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceFlag PLIB_INT_ExistsSourceFlag
61:                  PLIB_TEMPLATE bool INT_ExistsSourceFlag_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceFlagGet_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceFlagGet 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceFlagGet function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE bool INT_SourceFlagGet_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IFSx = (volatile uint32_t *)(&IFS0 + ((0x10 * (source / 32)) / 4));
9D000820  00022142   SRL A0, V0, 5
9D000824  00042100   SLL A0, A0, 4
9D000828  3C03BF88   LUI V1, -16504
9D00082C  24631030   ADDIU V1, V1, 4144
9D000830  00641821   ADDU V1, V1, A0
9D000888  00022142   SRL A0, V0, 5
9D00088C  00042100   SLL A0, A0, 4
9D000890  3C03BF88   LUI V1, -16504
9D000894  24631030   ADDIU V1, V1, 4144
9D000898  00641821   ADDU V1, V1, A0
9D0008C4  00022142   SRL A0, V0, 5
9D0008C8  00042100   SLL A0, A0, 4
9D0008CC  3C03BF88   LUI V1, -16504
9D0008D0  24631030   ADDIU V1, V1, 4144
9D0008D4  00641821   ADDU V1, V1, A0
9D000908  00022142   SRL A0, V0, 5
9D00090C  00042100   SLL A0, A0, 4
9D000910  3C03BF88   LUI V1, -16504
9D000914  24631030   ADDIU V1, V1, 4144
9D000918  00641821   ADDU V1, V1, A0
9D0012F4  00031142   SRL V0, V1, 5
9D0012F8  00021100   SLL V0, V0, 4
9D0012FC  3C04BF88   LUI A0, -16504
9D001300  24841030   ADDIU A0, A0, 4144
9D001304  00822021   ADDU A0, A0, V0
9D002A78  00022942   SRL A1, V0, 5
9D002A7C  00052900   SLL A1, A1, 4
9D002A80  3C03BF88   LUI V1, -16504
9D002A84  24631030   ADDIU V1, V1, 4144
9D002A88  00651821   ADDU V1, V1, A1
9D002C8C  00022942   SRL A1, V0, 5
9D002C90  00052900   SLL A1, A1, 4
9D002C94  3C03BF88   LUI V1, -16504
9D002C98  24631030   ADDIU V1, V1, 4144
9D002C9C  00651821   ADDU V1, V1, A1
9D002D30  00022942   SRL A1, V0, 5
9D002D34  00052900   SLL A1, A1, 4
9D002D38  3C03BF88   LUI V1, -16504
9D002D3C  24631030   ADDIU V1, V1, 4144
9D002D40  00651821   ADDU V1, V1, A1
00000004  00000000   NOP
00000038  00000000   NOP
0000004C  00000000   NOP
0000017C  00000000   NOP
00000180  00000000   NOP
0000018C  00000000   NOP
00000194  00000000   NOP
000001A0  00000000   NOP
82:                  
83:                      return (bool)((*IFSx >> (source & 0x1f)) & 0x1);
9D000834  8C630000   LW V1, 0(V1)
9D000838  00431006   SRLV V0, V1, V0
9D00083C  30420001   ANDI V0, V0, 1
9D00089C  8C640000   LW A0, 0(V1)
9D0008A0  3042001F   ANDI V0, V0, 31
9D0008A4  00442006   SRLV A0, A0, V0
9D0008A8  30840001   ANDI A0, A0, 1
9D0008D8  8C640000   LW A0, 0(V1)
9D0008DC  3042001F   ANDI V0, V0, 31
9D0008E0  00442006   SRLV A0, A0, V0
9D0008E4  30840001   ANDI A0, A0, 1
9D00091C  8C640000   LW A0, 0(V1)
9D000920  3042001F   ANDI V0, V0, 31
9D000924  00442006   SRLV A0, A0, V0
9D000928  30840001   ANDI A0, A0, 1
9D001308  8C840000   LW A0, 0(A0)
9D00130C  3063001F   ANDI V1, V1, 31
9D001310  00642006   SRLV A0, A0, V1
9D001314  30840001   ANDI A0, A0, 1
9D002A8C  8C630000   LW V1, 0(V1)
9D002A90  00431006   SRLV V0, V1, V0
9D002A94  30420001   ANDI V0, V0, 1
9D002CA0  8C630000   LW V1, 0(V1)
9D002CA4  00431006   SRLV V0, V1, V0
9D002CA8  30420001   ANDI V0, V0, 1
9D002D44  8C630000   LW V1, 0(V1)
9D002D48  00431006   SRLV V0, V1, V0
9D002D4C  30420001   ANDI V0, V0, 1
00000018  00000000   NOP
00000058  00000000   NOP
00000190  00000000   NOP
00000194  00000000   NOP
000001A0  00000000   NOP
000001A8  00000000   NOP
000001B4  00000000   NOP
84:                  }
85:                  
86:                  //******************************************************************************
87:                  /* Function :  INT_SourceFlagSet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_INT_SourceFlagSet 
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_INT_SourceFlagSet function.
94:                  
95:                    Note:
96:                      The source enum encoding is (x * 32) + y, where x is the register number 
97:                      (IFSx) and y is the bit position. 0b0xxy_yyyy
98:                  */
99:                  PLIB_TEMPLATE void INT_SourceFlagSet_Default( INT_MODULE_ID index , INT_SOURCE source )
100:                 {
101:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
102:                     volatile uint32_t *IFSxSET = (volatile uint32_t *)(IFSx + 2);
103:                 
104:                     *IFSxSET = 1 << (source & 0x1f);
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  INT_SourceFlagClear_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_INT_SourceFlagClear 
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_INT_SourceFlagClear function.
115:                 
116:                   Note:
117:                     The source enum encoding is (x * 32) + y, where x is the register number 
118:                     (IFSx) and y is the bit position. 0b0xxy_yyyy
119:                 */
120:                 PLIB_TEMPLATE void INT_SourceFlagClear_Default( INT_MODULE_ID index , INT_SOURCE source )
121:                 {
122:                     volatile uint32_t *IFSx = (volatile uint32_t *) (&IFS0 + ((0x10 * (source / 32)) / 4));
9D0006F4  00031142   SRL V0, V1, 5
9D0006F8  00021100   SLL V0, V0, 4
9D0006FC  3C04BF88   LUI A0, -16504
9D000700  24841030   ADDIU A0, A0, 4144
9D000704  00822021   ADDU A0, A0, V0
9D000864  00022142   SRL A0, V0, 5
9D000868  00042100   SLL A0, A0, 4
9D00086C  3C03BF88   LUI V1, -16504
9D000870  24631030   ADDIU V1, V1, 4144
9D000874  00641821   ADDU V1, V1, A0
9D000C10  3C04BF88   LUI A0, -16504
9D000C14  24841030   ADDIU A0, A0, 4144
9D000C18  00831821   ADDU V1, A0, V1
9D000C70  00063942   SRL A3, A2, 5
9D000C74  00073900   SLL A3, A3, 4
9D000C78  3C04BF88   LUI A0, -16504
9D000C7C  24841030   ADDIU A0, A0, 4144
9D000C80  00873821   ADDU A3, A0, A3
9D000C94  00063942   SRL A3, A2, 5
9D000C98  00073900   SLL A3, A3, 4
9D000C9C  00873821   ADDU A3, A0, A3
9D000CAC  00063942   SRL A3, A2, 5
9D000CB0  00073900   SLL A3, A3, 4
9D000CB4  00872021   ADDU A0, A0, A3
9D0012A4  00021942   SRL V1, V0, 5
9D0012A8  00031900   SLL V1, V1, 4
9D0012AC  3C04BF88   LUI A0, -16504
9D0012B0  24841030   ADDIU A0, A0, 4144
9D0012B4  00832021   ADDU A0, A0, V1
9D0017CC  00042942   SRL A1, A0, 5
9D0017D0  00052900   SLL A1, A1, 4
9D0017D4  3C03BF88   LUI V1, -16504
9D0017D8  24631030   ADDIU V1, V1, 4144
9D0017DC  00652821   ADDU A1, V1, A1
9D0017F0  00042942   SRL A1, A0, 5
9D0017F4  00052900   SLL A1, A1, 4
9D0017F8  00653021   ADDU A2, V1, A1
9D001808  00063942   SRL A3, A2, 5
9D00180C  00073900   SLL A3, A3, 4
9D001810  00671821   ADDU V1, V1, A3
9D002654  00032142   SRL A0, V1, 5
9D002658  00042100   SLL A0, A0, 4
9D00265C  3C02BF88   LUI V0, -16504
9D002660  24421030   ADDIU V0, V0, 4144
9D002664  00441021   ADDU V0, V0, A0
9D0026BC  00032142   SRL A0, V1, 5
9D0026C0  00042100   SLL A0, A0, 4
9D0026C4  3C02BF88   LUI V0, -16504
9D0026C8  24421030   ADDIU V0, V0, 4144
9D0026CC  00441021   ADDU V0, V0, A0
9D002AC4  00022142   SRL A0, V0, 5
9D002AC8  00042100   SLL A0, A0, 4
9D002ACC  3C03BF88   LUI V1, -16504
9D002AD0  24631030   ADDIU V1, V1, 4144
9D002AD4  00641821   ADDU V1, V1, A0
9D002CC0  00022142   SRL A0, V0, 5
9D002CC4  00042100   SLL A0, A0, 4
9D002CC8  3C03BF88   LUI V1, -16504
9D002CCC  24631030   ADDIU V1, V1, 4144
9D002CD0  00641821   ADDU V1, V1, A0
9D002D64  00022142   SRL A0, V0, 5
9D002D68  00042100   SLL A0, A0, 4
9D002D6C  3C03BF88   LUI V1, -16504
9D002D70  24631030   ADDIU V1, V1, 4144
9D002D74  00641821   ADDU V1, V1, A0
0000005C  00000000   NOP
0000012C  00000000   NOP
00000130  00000000   NOP
0000013C  00000000   NOP
00000144  00000000   NOP
00000150  00000000   NOP
123:                     volatile uint32_t *IFSxCLR = (volatile uint32_t *)(IFSx + 1);
124:                 
125:                     *IFSxCLR = 1 << (source & 0x1f);
9D000708  24020001   ADDIU V0, ZERO, 1
9D00070C  00621804   SLLV V1, V0, V1
9D000710  AC830004   SW V1, 4(A0)
9D000878  24040001   ADDIU A0, ZERO, 1
9D00087C  00441004   SLLV V0, A0, V0
9D000880  AC620004   SW V0, 4(V1)
9D0008B4  24040001   ADDIU A0, ZERO, 1
9D0008B8  00441004   SLLV V0, A0, V0
9D0008BC  AC620004   SW V0, 4(V1)
9D0008F0  24040001   ADDIU A0, ZERO, 1
9D0008F4  00441004   SLLV V0, A0, V0
9D0008F8  AC620004   SW V0, 4(V1)
9D000934  24040001   ADDIU A0, ZERO, 1
9D000938  00441004   SLLV V0, A0, V0
9D00093C  AC620004   SW V0, 4(V1)
9D000C1C  AC620004   SW V0, 4(V1)
9D000C84  24030001   ADDIU V1, ZERO, 1
9D000C88  00C33004   SLLV A2, V1, A2
9D000C8C  ACE60004   SW A2, 4(A3)
9D000CA0  00C33004   SLLV A2, V1, A2
9D000CA4  ACE60004   SW A2, 4(A3)
9D000CB8  00C33004   SLLV A2, V1, A2
9D000CBC  AC860004   SW A2, 4(A0)
9D0012B8  24030001   ADDIU V1, ZERO, 1
9D0012BC  00431004   SLLV V0, V1, V0
9D0012C0  AC820004   SW V0, 4(A0)
9D0017E0  24020001   ADDIU V0, ZERO, 1
9D0017E4  00822004   SLLV A0, V0, A0
9D0017E8  ACA40004   SW A0, 4(A1)
9D0017FC  00822004   SLLV A0, V0, A0
9D001800  ACC40004   SW A0, 4(A2)
9D001814  00C23004   SLLV A2, V0, A2
9D001818  AC660004   SW A2, 4(V1)
9D001D38  3C030004   LUI V1, 4
9D001D3C  3C02BF88   LUI V0, -16504
9D001D40  24421030   ADDIU V0, V0, 4144
9D001D44  AC430004   SW V1, 4(V0)
9D001E78  24030100   ADDIU V1, ZERO, 256
9D001E7C  3C02BF88   LUI V0, -16504
9D001E80  24421030   ADDIU V0, V0, 4144
9D001E84  AC430004   SW V1, 4(V0)
9D00234C  24030004   ADDIU V1, ZERO, 4
9D002350  3C02BF88   LUI V0, -16504
9D002354  24421030   ADDIU V0, V0, 4144
9D002358  AC430004   SW V1, 4(V0)
9D002668  24040001   ADDIU A0, ZERO, 1
9D00266C  00641804   SLLV V1, A0, V1
9D002670  AC430004   SW V1, 4(V0)
9D0026D0  24040001   ADDIU A0, ZERO, 1
9D0026D4  00641804   SLLV V1, A0, V1
9D0026D8  AC430004   SW V1, 4(V0)
9D002AD8  24040001   ADDIU A0, ZERO, 1
9D002ADC  00441004   SLLV V0, A0, V0
9D002AE0  AC620004   SW V0, 4(V1)
9D002CD4  24040001   ADDIU A0, ZERO, 1
9D002CD8  00441004   SLLV V0, A0, V0
9D002CDC  AC620004   SW V0, 4(V1)
9D002D78  24040001   ADDIU A0, ZERO, 1
9D002D7C  00441004   SLLV V0, A0, V0
9D002D80  AC620004   SW V0, 4(V1)
9D0030B8  3C030080   LUI V1, 128
9D0030BC  3C02BF88   LUI V0, -16504
9D0030C0  24421030   ADDIU V0, V0, 4144
9D0030C4  AC430004   SW V1, 4(V0)
0000005C  00000000   NOP
00000070  00000000   NOP
00000084  00000000   NOP
00000140  00000000   NOP
00000144  00000000   NOP
00000150  00000000   NOP
00000158  00000000   NOP
00000164  00000000   NOP
126:                 }
127:                 
128:                 #endif /*_INT_SOURCEFLAG_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_sourcecontrol_default.h  --------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_SourceControl_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SourceControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsSourceControl
16:                          PLIB_INT_SourceEnable
17:                          PLIB_INT_SourceDisable
18:                          PLIB_INT_SourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_SOURCECONTROL_DEFAULT_H
49:                  #define _INT_SOURCECONTROL_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  INT_ExistsSourceControl_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_INT_ExistsSourceControl
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_INT_ExistsSourceControl function.
59:                  */
60:                  #define PLIB_INT_ExistsSourceControl PLIB_INT_ExistsSourceControl
61:                  PLIB_TEMPLATE bool INT_ExistsSourceControl_Default( INT_MODULE_ID index )
62:                  {
63:                      return true;
64:                  }
65:                  
66:                  //******************************************************************************
67:                  /* Function :  INT_SourceEnable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_INT_SourceEnable 
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_INT_SourceEnable function.
74:                  
75:                    Note:
76:                      The source enum encoding is (x * 32) + y, where x is the register number 
77:                      (IECx) and y is the bit position. 0b0xxy_yyyy
78:                  */
79:                  PLIB_TEMPLATE void INT_SourceEnable_Default( INT_MODULE_ID index , INT_SOURCE source )
80:                  {
81:                      volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D000BF0  00021942   SRL V1, V0, 5
9D000BF4  00031900   SLL V1, V1, 4
9D000BF8  3C04BF88   LUI A0, -16504
9D000BFC  24841060   ADDIU A0, A0, 4192
9D000C00  00832021   ADDU A0, A0, V1
9D001264  24841060   ADDIU A0, A0, 4192
9D001268  00822821   ADDU A1, A0, V0
9D00127C  00032942   SRL A1, V1, 5
9D001280  00052900   SLL A1, A1, 4
9D001284  00852021   ADDU A0, A0, A1
9D0012C8  00022942   SRL A1, V0, 5
9D0012CC  00052900   SLL A1, A1, 4
9D0012D0  3C04BF88   LUI A0, -16504
9D0012D4  24841060   ADDIU A0, A0, 4192
9D0012D8  00852021   ADDU A0, A0, A1
9D001404  00022942   SRL A1, V0, 5
9D001408  00052900   SLL A1, A1, 4
9D00140C  3C04BF88   LUI A0, -16504
9D001410  24841060   ADDIU A0, A0, 4192
9D001414  00852021   ADDU A0, A0, A1
9D00142C  00022942   SRL A1, V0, 5
9D001430  00052900   SLL A1, A1, 4
9D001434  3C04BF88   LUI A0, -16504
9D001438  24841060   ADDIU A0, A0, 4192
9D00143C  00852021   ADDU A0, A0, A1
9D0014AC  00022142   SRL A0, V0, 5
9D0014B0  00042100   SLL A0, A0, 4
9D0014B4  3C03BF88   LUI V1, -16504
9D0014B8  24631060   ADDIU V1, V1, 4192
9D0014BC  00641821   ADDU V1, V1, A0
9D0014D4  00022142   SRL A0, V0, 5
9D0014D8  00042100   SLL A0, A0, 4
9D0014DC  3C03BF88   LUI V1, -16504
9D0014E0  24631060   ADDIU V1, V1, 4192
9D0014E4  00641821   ADDU V1, V1, A0
9D00181C  3C03BF88   LUI V1, -16504
9D001820  24631060   ADDIU V1, V1, 4192
9D001824  00673821   ADDU A3, V1, A3
9D00182C  00651821   ADDU V1, V1, A1
9D003228  00041942   SRL V1, A0, 5
9D00322C  00031900   SLL V1, V1, 4
9D003230  3C05BF88   LUI A1, -16504
9D003234  24A51060   ADDIU A1, A1, 4192
9D003238  00A32821   ADDU A1, A1, V1
000000EC  00000000   NOP
000000F0  00000000   NOP
000000FC  00000000   NOP
00000104  00000000   NOP
00000108  00000000   NOP
00000110  00000000   NOP
00000114  00000000   NOP
0000011C  00000000   NOP
00000128  00000000   NOP
00000150  00000000   NOP
00000154  00000000   NOP
00000160  00000000   NOP
00000168  00000000   NOP
00000174  00000000   NOP
000001D0  00000000   NOP
82:                      volatile uint32_t *IECxSET = (volatile uint32_t *)(IECx + 2);
83:                  
84:                      *IECxSET = 1 << (source & 0x1f);
9D000C04  24050001   ADDIU A1, ZERO, 1
9D000C08  00451004   SLLV V0, A1, V0
9D000C0C  AC820008   SW V0, 8(A0)
9D000E18  3C031000   LUI V1, 4096
9D000E1C  3C02BF88   LUI V0, -16504
9D000E20  24421060   ADDIU V0, V0, 4192
9D000E24  AC430018   SW V1, 24(V0)
9D000FE4  3C11BF88   LUI S1, -16504
9D000FE8  26311060   ADDIU S1, S1, 4192
9D000FEC  24030002   ADDIU V1, ZERO, 2
9D000FF0  AE230008   SW V1, 8(S1)
9D001034  24020004   ADDIU V0, ZERO, 4
9D001038  AE220008   SW V0, 8(S1)
9D001118  3C020004   LUI V0, 4
9D00111C  AE220008   SW V0, 8(S1)
9D00126C  24020001   ADDIU V0, ZERO, 1
9D001270  00621804   SLLV V1, V0, V1
9D001274  ACA30008   SW V1, 8(A1)
9D001288  00621804   SLLV V1, V0, V1
9D00128C  AC830008   SW V1, 8(A0)
9D0012DC  00431004   SLLV V0, V1, V0
9D0012E0  AC820008   SW V0, 8(A0)
9D001418  24050001   ADDIU A1, ZERO, 1
9D00141C  00451004   SLLV V0, A1, V0
9D001420  AC820008   SW V0, 8(A0)
9D001440  24050001   ADDIU A1, ZERO, 1
9D001444  00451004   SLLV V0, A1, V0
9D001448  AC820008   SW V0, 8(A0)
9D0014C0  24040001   ADDIU A0, ZERO, 1
9D0014C4  00441004   SLLV V0, A0, V0
9D0014C8  AC620008   SW V0, 8(V1)
9D0014E8  24040001   ADDIU A0, ZERO, 1
9D0014EC  00441004   SLLV V0, A0, V0
9D0014F0  AC620008   SW V0, 8(V1)
9D001828  ACE60008   SW A2, 8(A3)
9D001830  AC640008   SW A0, 8(V1)
9D0028D8  3C02BF88   LUI V0, -16504
9D0028DC  24421060   ADDIU V0, V0, 4192
9D0028E0  AC430008   SW V1, 8(V0)
9D0028E4  0B400A58   J 0x9D002960
9D0028E8  A3808010   SB ZERO, -32752(GP)
9D002948  3C02BF88   LUI V0, -16504
9D00294C  24421060   ADDIU V0, V0, 4192
9D002950  24030100   ADDIU V1, ZERO, 256
9D002954  AC430008   SW V1, 8(V0)
9D002958  3C030080   LUI V1, 128
9D00295C  AC430008   SW V1, 8(V0)
9D00323C  24030001   ADDIU V1, ZERO, 1
9D003240  00832004   SLLV A0, V1, A0
9D003244  ACA40008   SW A0, 8(A1)
00000000  00000000   NOP
000000F4  00000000   NOP
000000F8  00000000   NOP
00000100  00000000   NOP
00000104  00000000   NOP
0000010C  00000000   NOP
00000110  00000000   NOP
00000114  00000000   NOP
00000118  00000000   NOP
00000120  00000000   NOP
00000128  00000000   NOP
00000134  00000000   NOP
00000164  00000000   NOP
00000168  00000000   NOP
00000174  00000000   NOP
0000017C  00000000   NOP
00000188  00000000   NOP
000001E4  00000000   NOP
85:                  }
86:                  
87:                  //******************************************************************************
88:                  /* Function :  INT_SourceDisable_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_INT_SourceDisable 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_INT_SourceDisable function.
95:                  
96:                    Note:
97:                      The source enum encoding is (x * 32) + y, where x is the register number
98:                      (IECx) and y is the bit position. 0b0xxy_yyyy
99:                  */
100:                 PLIB_TEMPLATE void INT_SourceDisable_Default( INT_MODULE_ID index , INT_SOURCE source )
101:                 {
102:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
103:                     volatile uint32_t *IECxCLR = (volatile uint32_t *)(IECx + 1);
104:                 
105:                     *IECxCLR = 1 << (source & 0x1f);
9D003458  24060001   ADDIU A2, ZERO, 1
9D00345C  00863004   SLLV A2, A2, A0
9D003460  AC660004   SW A2, 4(V1)
106:                 }
107:                 
108:                 //******************************************************************************
109:                 /* Function :  INT_SourceIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_INT_SourceIsEnabled 
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_INT_SourceIsEnabled function.
116:                 
117:                   Note:
118:                     The source enum encoding is (x * 32) + y, where x is the register number 
119:                     (IECx) and y is the bit position. 0b0xxy_yyyy
120:                 */
121:                 PLIB_TEMPLATE bool INT_SourceIsEnabled_Default( INT_MODULE_ID index , INT_SOURCE source )
122:                 {
123:                     volatile uint32_t *IECx = (volatile uint32_t *) (&IEC0 + ((0x10 * (source / 32)) / 4));
9D00302C  00022142   SRL A0, V0, 5
9D003030  00042100   SLL A0, A0, 4
9D003034  3C03BF88   LUI V1, -16504
9D003038  24631060   ADDIU V1, V1, 4192
9D00303C  00641821   ADDU V1, V1, A0
9D003128  00023142   SRL A2, V0, 5
9D00312C  00063100   SLL A2, A2, 4
9D003130  3C05BF88   LUI A1, -16504
9D003134  24A51060   ADDIU A1, A1, 4192
9D003138  00A62821   ADDU A1, A1, A2
9D003198  00023142   SRL A2, V0, 5
9D00319C  00063100   SLL A2, A2, 4
9D0031A0  3C05BF88   LUI A1, -16504
9D0031A4  24A51060   ADDIU A1, A1, 4192
9D0031A8  00A62821   ADDU A1, A1, A2
9D00343C  00041142   SRL V0, A0, 5
9D003440  00021100   SLL V0, V0, 4
9D003444  3C03BF88   LUI V1, -16504
9D003448  24631060   ADDIU V1, V1, 4192
9D00344C  00621821   ADDU V1, V1, V0
124:                 
125:                     return (bool)((*IECx >> (source & 0x1f)) & 0x01);
9D003040  8C630000   LW V1, 0(V1)
9D003044  00431806   SRLV V1, V1, V0
9D003048  30630001   ANDI V1, V1, 1
9D00313C  8CA50000   LW A1, 0(A1)
9D003140  00451006   SRLV V0, A1, V0
9D003144  30420001   ANDI V0, V0, 1
9D0031AC  8CA50000   LW A1, 0(A1)
9D0031B0  00451006   SRLV V0, A1, V0
9D0031B4  30420001   ANDI V0, V0, 1
9D003450  8C620000   LW V0, 0(V1)
9D003454  3084001F   ANDI A0, A0, 31
9D00346C  00821006   SRLV V0, V0, A0
9D003470  30420001   ANDI V0, V0, 1
9D003474  8FBF0004   LW RA, 4(SP)
9D003478  03E00008   JR RA
9D00347C  27BD0008   ADDIU SP, SP, 8
126:                 }
127:                 
128:                 #endif /*_INT_SOURCECONTROL_DEFAULT_H*/
129:                 
130:                 /******************************************************************************
131:                  End of File
132:                 */
133:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_externalintedgeselect_default.h  
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_ExternalINTEdgeSelect_Default.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ExternalINTEdgeSelect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_INT_ExistsExternalINTEdgeSelect
16:                          PLIB_INT_ExternalRisingEdgeSelect
17:                          PLIB_INT_ExternalFallingEdgeSelect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _INT_EXTERNALINTEDGESELECT_DEFAULT_H
48:                  #define _INT_EXTERNALINTEDGESELECT_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  INT_ExistsExternalINTEdgeSelect_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_INT_ExistsExternalINTEdgeSelect
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_INT_ExistsExternalINTEdgeSelect function.
58:                  */
59:                  #define PLIB_INT_ExistsExternalINTEdgeSelect PLIB_INT_ExistsExternalINTEdgeSelect
60:                  PLIB_TEMPLATE bool INT_ExistsExternalINTEdgeSelect_Default( INT_MODULE_ID index )
61:                  {
62:                      return true;
63:                  }
64:                  
65:                  //******************************************************************************
66:                  /* Function :  INT_ExternalRisingEdgeSelect_Default
67:                  
68:                    Summary:
69:                      Implements Default variant of PLIB_INT_ExternalRisingEdgeSelect
70:                  
71:                    Description:
72:                      This template implements the Default variant of the PLIB_INT_ExternalRisingEdgeSelect function.
73:                  */
74:                  
75:                  PLIB_TEMPLATE void INT_ExternalRisingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
76:                  {
77:                      INTCONSET = source << _INTCON_INT0EP_POSITION;
9D0037CC  3C02BF88   LUI V0, -16504
9D0037D0  AC441008   SW A0, 4104(V0)
9D0037D4  03E00008   JR RA
9D0037D8  00000000   NOP
78:                  }
79:                  
80:                  //******************************************************************************
81:                  /* Function :  INT_ExternalFallingEdgeSelect_Default
82:                  
83:                    Summary:
84:                      Implements Default variant of PLIB_INT_ExternalFallingEdgeSelect
85:                  
86:                    Description:
87:                      This template implements the Default variant of the PLIB_INT_ExternalFallingEdgeSelect function.
88:                  */
89:                  PLIB_TEMPLATE void INT_ExternalFallingEdgeSelect_Default( INT_MODULE_ID index , INT_EXTERNAL_SOURCES source )
90:                  {
91:                      INTCONCLR = source << _INTCON_INT0EP_POSITION;
9D0037DC  AC441004   SW A0, 4100(V0)
92:                  }
93:                  
94:                  #endif /*_INT_EXTERNALINTEDGESELECT_DEFAULT_H*/
95:                  
96:                  /******************************************************************************
97:                   End of File
98:                  */
99:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/int/templates/int_enablecontrol_pic32.h  ----------
1:                   /*******************************************************************************
2:                     INT Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       int_EnableControl_PIC32.h
6:                   
7:                     Summary:
8:                       INT PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : PIC32
14:                      For following APIs :
15:                          PLIB_INT_ExistsEnableControl
16:                          PLIB_INT_Enable
17:                          PLIB_INT_Disable
18:                          PLIB_INT_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _INT_ENABLECONTROL_PIC32_H
49:                  #define _INT_ENABLECONTROL_PIC32_H
50:                  
51:                  #include "peripheral/int/plib_int_private_pic32.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  INT_ExistsEnableControl_PIC32
55:                  
56:                    Summary:
57:                      Implements PIC32 variant of PLIB_INT_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the PIC32 variant of the PLIB_INT_ExistsEnableControl function.
61:                  */
62:                  #define PLIB_INT_ExistsEnableControl PLIB_INT_ExistsEnableControl
63:                  PLIB_TEMPLATE bool INT_ExistsEnableControl_PIC32( INT_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  //******************************************************************************
69:                  /* Function :  INT_Enable_PIC32
70:                  
71:                    Summary:
72:                      Implements PIC32 variant of PLIB_INT_Enable 
73:                  
74:                    Description:
75:                      This template implements the PIC32 variant of the PLIB_INT_Enable function.
76:                  */
77:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_Enable_PIC32( INT_MODULE_ID index )
78:                  {
79:                      __builtin_mtc0(12, 0,(__builtin_mfc0(12, 0) | 0x0001));
9D000F44  40026000   MFC0 V0, Status
9D000F48  34420001   ORI V0, V0, 1
9D000F4C  40826000   MTC0 V0, Status
9D000F50  000000C0   EHB
9D003308  40026000   MFC0 V0, Status
9D00330C  34420001   ORI V0, V0, 1
9D003310  40826000   MTC0 V0, Status
9D003314  000000C0   EHB
9D0033BC  40026000   MFC0 V0, Status
9D0033C0  34420001   ORI V0, V0, 1
9D0033C4  40826000   MTC0 V0, Status
9D0033C8  000000C0   EHB
9D003548  40026000   MFC0 V0, Status
9D00354C  34420001   ORI V0, V0, 1
9D003550  40826000   MTC0 V0, Status
9D003554  000000C0   EHB
80:                      
81:                  }
82:                  
83:                  //******************************************************************************
84:                  /* Function :  INT_Disable_PIC32
85:                  
86:                    Summary:
87:                      Implements PIC32 variant of PLIB_INT_Disable 
88:                  
89:                    Description:
90:                      This template implements the PIC32 variant of the PLIB_INT_Disable function.
91:                  */
92:                  PLIB_TEMPLATE __attribute__((nomips16,always_inline))void INT_Disable_PIC32( INT_MODULE_ID index )
93:                  {
94:                      __builtin_disable_interrupts();
95:                  }
96:                  
97:                  //******************************************************************************
98:                  /* Function :  PLIB_INT_SetState_PIC32
99:                  
100:                   Summary:
101:                     Implements PIC32 variant of PLIB_INT_Enable 
102:                 
103:                   Description:
104:                     This template implements the PIC32 variant of the PLIB_INT_Enable function.
105:                 */
106:                 PLIB_TEMPLATE __attribute__((nomips16,always_inline)) void INT_SetState_PIC32( INT_MODULE_ID index, INT_STATE_GLOBAL interrupt_state )
107:                 {
108:                     __builtin_mtc0(12, 0, interrupt_state);
9D003464  40856000   MTC0 A1, Status
9D003468  000000C0   EHB
00000008  00000000   NOP
109:                 }
110:                 
111:                 //******************************************************************************
112:                 /* Function :  PLIB_INT_GetStateAndDisable_PIC32
113:                 
114:                   Summary:
115:                     Implements PIC32 variant of PLIB_INT_Disable 
116:                 
117:                   Description:
118:                     This template implements the PIC32 variant of the PLIB_INT_Disable function.
119:                 */
120:                 INT_STATE_GLOBAL PLIB_TEMPLATE __attribute__((nomips16,always_inline)) INT_GetStateAndDisable_PIC32( INT_MODULE_ID index )
121:                 {
122:                     return (INT_STATE_GLOBAL)__builtin_disable_interrupts();
9D0032E4  41646000   DI A0
9D0032E8  000000C0   EHB
9D003388  41636000   DI V1
9D00338C  000000C0   EHB
9D003434  41656000   DI A1
9D003438  000000C0   EHB
9D003524  41626000   DI V0
9D003528  000000C0   EHB
00000008  00000000   NOP
123:                 }
124:                 
125:                 //******************************************************************************
126:                 /* Function :  INT_IsEnabled_PIC32
127:                 
128:                   Summary:
129:                     Implements PIC32 variant of PLIB_INT_IsEnabled 
130:                 
131:                   Description:
132:                     This template implements the PIC32 variant of the PLIB_INT_IsEnabled function.
133:                 */
134:                 PLIB_TEMPLATE bool __attribute__((nomips16,always_inline)) INT_IsEnabled_PIC32( INT_MODULE_ID index )
135:                 {
136:                     return (bool)(_CP0_GET_STATUS() & 0x01);
137:                 }
138:                 
139:                 #endif /*_INT_ENABLECONTROL_PIC32_H*/
140:                 
141:                 /******************************************************************************
142:                  End of File
143:                 */
144:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_transmitterbytesend_default.h  --
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteSend_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteSend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteSend
16:                          PLIB_I2C_ExistsTransmitterByteSend
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTESEND_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTESEND_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteSend_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteSend 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteSend function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_TransmitterByteSend_Default( I2C_MODULE_ID index , uint8_t data )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      regs->I2CxTRN = data;
9D0000B8  304200FF   ANDI V0, V0, 255
9D0000BC  AE420050   SW V0, 80(S2)
9D0000D8  AE420050   SW V0, 80(S2)
9D0001EC  90420000   LBU V0, 0(V0)
9D0001F0  AE420050   SW V0, 80(S2)
9D000368  90420000   LBU V0, 0(V0)
9D00036C  AE420050   SW V0, 80(S2)
9D000408  AE400050   SW ZERO, 80(S2)
9D000490  00031842   SRL V1, V1, 1
9D000494  AE430050   SW V1, 80(S2)
9D000498  0B400207   J 0x9D00081C
9D00049C  AC820044   SW V0, 68(A0)
9D0004A8  00021042   SRL V0, V0, 1
9D0004AC  AE420050   SW V0, 80(S2)
9D0004D0  304200FF   ANDI V0, V0, 255
9D0004D4  AE420050   SW V0, 80(S2)
9D000640  90420000   LBU V0, 0(V0)
9D000644  AE420050   SW V0, 80(S2)
9D000674  90420000   LBU V0, 0(V0)
9D000678  AE420050   SW V0, 80(S2)
9D00067C  24020007   ADDIU V0, ZERO, 7
9D000680  0B400207   J 0x9D00081C
9D000684  AE020044   SW V0, 68(S0)
9D000688  AC820044   SW V0, 68(A0)
9D00068C  24020004   ADDIU V0, ZERO, 4
9D000690  AE420008   SW V0, 8(S2)
9D000694  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000698  8E020038   LW V0, 56(S0)
9D00069C  AC820044   SW V0, 68(A0)
9D0006A0  24020004   ADDIU V0, ZERO, 4
9D0006A4  AE420008   SW V0, 8(S2)
9D0006A8  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006AC  8E020038   LW V0, 56(S0)
9D0006B0  8E420010   LW V0, 16(S2)
9D0006B4  30428000   ANDI V0, V0, -32768
9D0006B8  5040000A   BEQL V0, ZERO, 0x9D0006E4
9D0006BC  8E23000C   LW V1, 12(S1)
9D0006C0  8E420010   LW V0, 16(S2)
9D0006C4  30424000   ANDI V0, V0, 16384
9D0006C8  54400055   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006CC  8E020038   LW V0, 56(S0)
9D0006D0  8E420010   LW V0, 16(S2)
9D0006D4  30428000   ANDI V0, V0, -32768
9D0006D8  50400051   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006DC  8E020038   LW V0, 56(S0)
9D0006E0  8E23000C   LW V1, 12(S1)
9D0006E4  24020002   ADDIU V0, ZERO, 2
9D0006E8  54620016   BNEL V1, V0, 0x9D000744
9D0006EC  24020008   ADDIU V0, ZERO, 8
9D0006F0  8E030030   LW V1, 48(S0)
9D0006F4  00031142   SRL V0, V1, 5
9D0006F8  00021100   SLL V0, V0, 4
9D0006FC  3C04BF88   LUI A0, -16504
9D000700  24841030   ADDIU A0, A0, 4144
9D000704  00822021   ADDU A0, A0, V0
9D000708  24020001   ADDIU V0, ZERO, 1
9D00070C  00621804   SLLV V1, V0, V1
9D000710  AC830004   SW V1, 4(A0)
9D000714  24030009   ADDIU V1, ZERO, 9
9D000718  AE030044   SW V1, 68(S0)
9D00071C  AE22000C   SW V0, 12(S1)
9D000720  8E22001C   LW V0, 28(S1)
9D000724  AE220018   SW V0, 24(S1)
9D000728  24020004   ADDIU V0, ZERO, 4
9D00072C  AE22002C   SW V0, 44(S1)
9D000730  8E020004   LW V0, 4(S0)
9D000734  24030002   ADDIU V1, ZERO, 2
9D000738  AC430008   SW V1, 8(V0)
9D00073C  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000740  8E020038   LW V0, 56(S0)
9D000744  AE020044   SW V0, 68(S0)
9D000748  24020004   ADDIU V0, ZERO, 4
9D00074C  AE420008   SW V0, 8(S2)
9D000750  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000754  8E020038   LW V0, 56(S0)
9D000758  8E420010   LW V0, 16(S2)
9D00075C  30424000   ANDI V0, V0, 16384
9D000760  5440002F   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000764  8E020038   LW V0, 56(S0)
9D000768  8E420010   LW V0, 16(S2)
9D00076C  30428000   ANDI V0, V0, -32768
9D000770  1440000A   BNE V0, ZERO, 0x9D00079C
9D000774  24020008   ADDIU V0, ZERO, 8
9D000778  8E420000   LW V0, 0(S2)
9D00077C  30420010   ANDI V0, V0, 16
9D000780  54400027   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000784  8E020038   LW V0, 56(S0)
9D000788  24020008   ADDIU V0, ZERO, 8
9D00078C  AE420008   SW V0, 8(S2)
9D000790  24020003   ADDIU V0, ZERO, 3
9D000794  0B400207   J 0x9D00081C
9D000798  AC820044   SW V0, 68(A0)
9D00079C  AC820044   SW V0, 68(A0)
9D0007A0  24020004   ADDIU V0, ZERO, 4
9D0007A4  AE420008   SW V0, 8(S2)
9D0007A8  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0007AC  8E020038   LW V0, 56(S0)
9D0007B0  AC800044   SW ZERO, 68(A0)
9D0007B4  8E220018   LW V0, 24(S1)
9D0007B8  10400004   BEQ V0, ZERO, 0x9D0007CC
9D0007BC  24020001   ADDIU V0, ZERO, 1
9D0007C0  24020002   ADDIU V0, ZERO, 2
9D0007C4  0B4001F4   J 0x9D0007D0
9D0007C8  AE22002C   SW V0, 44(S1)
9D0007CC  AE22002C   SW V0, 44(S1)
9D0007D0  8E220004   LW V0, 4(S1)
9D0007D4  8C420020   LW V0, 32(V0)
9D0007D8  1040000C   BEQ V0, ZERO, 0x9D00080C
9D0007DC  02202821   ADDU A1, S1, ZERO
9D0007E0  8E020068   LW V0, 104(S0)
9D0007E4  24420001   ADDIU V0, V0, 1
9D0007E8  AE020068   SW V0, 104(S0)
9D0007EC  8E220004   LW V0, 4(S1)
9D0007F0  8C420020   LW V0, 32(V0)
9D0007F4  8E24002C   LW A0, 44(S1)
9D0007F8  0040F809   JALR V0
9D0007FC  00003021   ADDU A2, ZERO, ZERO
9D000800  8E020068   LW V0, 104(S0)
9D000804  2442FFFF   ADDIU V0, V0, -1
9D000808  AE020068   SW V0, 104(S0)
9D00080C  52200004   BEQL S1, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000810  8E020038   LW V0, 56(S0)
9D000814  A2200000   SB ZERO, 0(S1)
9D000818  00000040   SSNOP
9D00081C  8E020038   LW V0, 56(S0)
9D000820  00022142   SRL A0, V0, 5
9D000824  00042100   SLL A0, A0, 4
9D000828  3C03BF88   LUI V1, -16504
9D00082C  24631030   ADDIU V1, V1, 4144
9D000830  00641821   ADDU V1, V1, A0
9D000834  8C630000   LW V1, 0(V1)
9D000838  00431006   SRLV V0, V1, V0
9D00083C  30420001   ANDI V0, V0, 1
9D000840  50400011   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000844  8E020030   LW V0, 48(S0)
9D000848  8E420010   LW V0, 16(S2)
9D00084C  30420040   ANDI V0, V0, 64
9D000850  50400004   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagClear
9D000854  8E020038   LW V0, 56(S0)
9D000858  24020040   ADDIU V0, ZERO, 64
9D00085C  AE420014   SW V0, 20(S2)
9D000860  8E020038   LW V0, 56(S0)
9D000864  00022142   SRL A0, V0, 5
9D000868  00042100   SLL A0, A0, 4
9D00086C  3C03BF88   LUI V1, -16504
9D000870  24631030   ADDIU V1, V1, 4144
9D000874  00641821   ADDU V1, V1, A0
9D000878  24040001   ADDIU A0, ZERO, 1
9D00087C  00441004   SLLV V0, A0, V0
9D000880  AC620004   SW V0, 4(V1)
9D000884  8E020030   LW V0, 48(S0)
9D000888  00022142   SRL A0, V0, 5
9D00088C  00042100   SLL A0, A0, 4
9D000890  3C03BF88   LUI V1, -16504
9D000894  24631030   ADDIU V1, V1, 4144
9D000898  00641821   ADDU V1, V1, A0
9D00089C  8C640000   LW A0, 0(V1)
9D0008A0  3042001F   ANDI V0, V0, 31
9D0008A4  00442006   SRLV A0, A0, V0
9D0008A8  30840001   ANDI A0, A0, 1
9D0008AC  50800005   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0008B0  8E020034   LW V0, 52(S0)
9D0008B4  24040001   ADDIU A0, ZERO, 1
9D0008B8  00441004   SLLV V0, A0, V0
9D0008BC  AC620004   SW V0, 4(V1)
9D0008C0  8E020034   LW V0, 52(S0)
9D0008C4  00022142   SRL A0, V0, 5
9D0008C8  00042100   SLL A0, A0, 4
9D0008CC  3C03BF88   LUI V1, -16504
9D0008D0  24631030   ADDIU V1, V1, 4144
9D0008D4  00641821   ADDU V1, V1, A0
9D0008D8  8C640000   LW A0, 0(V1)
9D0008DC  3042001F   ANDI V0, V0, 31
9D0008E0  00442006   SRLV A0, A0, V0
9D0008E4  30840001   ANDI A0, A0, 1
9D0008E8  50800007   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0008EC  8E020038   LW V0, 56(S0)
9D0008F0  24040001   ADDIU A0, ZERO, 1
9D0008F4  00441004   SLLV V0, A0, V0
9D0008F8  AC620004   SW V0, 4(V1)
9D0008FC  24021000   ADDIU V0, ZERO, 4096
9D000900  AE420008   SW V0, 8(S2)
9D000904  8E020038   LW V0, 56(S0)
9D000908  00022142   SRL A0, V0, 5
9D00090C  00042100   SLL A0, A0, 4
9D000910  3C03BF88   LUI V1, -16504
9D000914  24631030   ADDIU V1, V1, 4144
9D000918  00641821   ADDU V1, V1, A0
9D00091C  8C640000   LW A0, 0(V1)
9D000920  3042001F   ANDI V0, V0, 31
9D000924  00442006   SRLV A0, A0, V0
9D000928  30840001   ANDI A0, A0, 1
9D00092C  50800005   BEQL A0, ZERO, 0x9D000944
9D000930  8E020020   LW V0, 32(S0)
9D000934  24040001   ADDIU A0, ZERO, 1
9D000938  00441004   SLLV V0, A0, V0
9D00093C  AC620004   SW V0, 4(V1)
9D000940  8E020020   LW V0, 32(S0)
9D000944  1440001B   BNE V0, ZERO, 0x9D0009B4
9D000948  8FBF001C   LW RA, 28(SP)
9D00094C  1220001A   BEQ S1, ZERO, 0x9D0009B8
9D000950  8FB20018   LW S2, 24(SP)
9D000954  8E22002C   LW V0, 44(S1)
9D000958  2442FFFF   ADDIU V0, V0, -1
9D00095C  2C420002   SLTIU V0, V0, 2
9D000960  50400016   BEQL V0, ZERO, 0x9D0009BC
9D000964  8FB10014   LW S1, 20(SP)
9D000968  0F400DDA   JAL _DRV_I2C_Advance_Queue
9D00096C  02002021   ADDU A0, S0, ZERO
9D000970  0F400DB0   JAL _DRV_I2C_IsQueueEmpty
9D000974  02002021   ADDU A0, S0, ZERO
9D000978  1440000E   BNE V0, ZERO, 0x9D0009B4
9D00097C  8FBF001C   LW RA, 28(SP)
9D000980  8E020004   LW V0, 4(S0)
9D000984  8C430000   LW V1, 0(V0)
9D000988  3063001F   ANDI V1, V1, 31
9D00098C  1460000A   BNE V1, ZERO, 0x9D0009B8
9D000990  8FB20018   LW S2, 24(SP)
9D000994  8C430010   LW V1, 16(V0)
9D000998  30634000   ANDI V1, V1, 16384
9D00099C  14600007   BNE V1, ZERO, 0x9D0009BC
9D0009A0  8FB10014   LW S1, 20(SP)
9D0009A4  24030001   ADDIU V1, ZERO, 1
9D0009A8  AC430008   SW V1, 8(V0)
9D0009AC  00000040   SSNOP
9D0009B0  8FBF001C   LW RA, 28(SP)
9D0009B4  8FB20018   LW S2, 24(SP)
9D0009B8  8FB10014   LW S1, 20(SP)
9D0009BC  8FB00010   LW S0, 16(SP)
9D0009C0  03E00008   JR RA
9D0009C4  27BD0020   ADDIU SP, SP, 32
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteSend_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteSend
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteSend function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteSend PLIB_I2C_ExistsTransmitterByteSend
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteSend_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTESEND_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_transmitterbytecomplete_default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteComplete_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteComplete
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteHasCompleted
16:                          PLIB_I2C_ExistsTransmitterByteComplete
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteHasCompleted_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteHasCompleted 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteHasCompleted function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_TransmitterByteHasCompleted_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)!regs->I2CxSTAT.TRSTAT;
9D0005F0  8E430010   LW V1, 16(S2)
9D0005F4  30634000   ANDI V1, V1, 16384
9D0006C0  8E420010   LW V0, 16(S2)
9D0006C4  30424000   ANDI V0, V0, 16384
9D000758  8E420010   LW V0, 16(S2)
9D00075C  30424000   ANDI V0, V0, 16384
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteComplete_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteComplete
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteComplete function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteComplete PLIB_I2C_ExistsTransmitterByteComplete
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteComplete_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTECOMPLETE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_transmitterbyteacknowledge_default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_TransmitterByteAcknowledge_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : TransmitterByteAcknowledge
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_TransmitterByteWasAcknowledged
16:                          PLIB_I2C_ExistsTransmitterByteAcknowledge
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H
47:                  #define _I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_TransmitterByteWasAcknowledged_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_TransmitterByteWasAcknowledged 
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_TransmitterByteWasAcknowledged function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_TransmitterByteWasAcknowledged_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)!regs->I2CxSTAT.ACKSTAT;
9D000330  8E420010   LW V0, 16(S2)
9D000334  30428000   ANDI V0, V0, -32768
9D000414  8E420010   LW V0, 16(S2)
9D000418  30428000   ANDI V0, V0, -32768
9D000600  8E430010   LW V1, 16(S2)
9D000604  30638000   ANDI V1, V1, -32768
9D0006B0  8E420010   LW V0, 16(S2)
9D0006B4  30428000   ANDI V0, V0, -32768
9D0006D0  8E420010   LW V0, 16(S2)
9D0006D4  30428000   ANDI V0, V0, -32768
9D000768  8E420010   LW V0, 16(S2)
9D00076C  30428000   ANDI V0, V0, -32768
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsTransmitterByteAcknowledge_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsTransmitterByteAcknowledge
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsTransmitterByteAcknowledge function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsTransmitterByteAcknowledge PLIB_I2C_ExistsTransmitterByteAcknowledge
81:                  PLIB_TEMPLATE bool I2C_ExistsTransmitterByteAcknowledge_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_TRANSMITTERBYTEACKNOWLEDGE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_stopinidle_default.h  -----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StopInIdle_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopInIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StopInIdleEnable
16:                          PLIB_I2C_StopInIdleDisable
17:                          PLIB_I2C_ExistsStopInIdle
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STOPINIDLE_DEFAULT_H
48:                  #define _I2C_STOPINIDLE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StopInIdleEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StopInIdleEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StopInIdleEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_StopInIdleEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_SIDL_MASK;
9D000A88  24022000   ADDIU V0, ZERO, 8192
9D000A8C  AE220008   SW V0, 8(S1)
9D000ACC  24022000   ADDIU V0, ZERO, 8192
9D000AD0  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StopInIdleDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StopInIdleDisable
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StopInIdleDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StopInIdleDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_SIDL_MASK;
9D000AAC  24022000   ADDIU V0, ZERO, 8192
9D000AB0  AE220004   SW V0, 4(S1)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStopInIdle_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStopInIdle
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStopInIdle function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStopInIdle PLIB_I2C_ExistsStopInIdle
101:                 PLIB_TEMPLATE bool I2C_ExistsStopInIdle_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STOPINIDLE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_stopdetect_default.h  -----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StopDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StopDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StopWasDetected
16:                          PLIB_I2C_StopClear
17:                          PLIB_I2C_ExistsStopDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STOPDETECT_DEFAULT_H
48:                  #define _I2C_STOPDETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StopWasDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StopWasDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StopWasDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_StopWasDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.P;
9D00121C  8C430010   LW V1, 16(V0)
9D001220  30630010   ANDI V1, V1, 16
9D00122C  8C430010   LW V1, 16(V0)
9D001230  30630010   ANDI V1, V1, 16
000000A4  00000000   NOP
000000A8  00000000   NOP
000000B4  00000000   NOP
000000B8  00000000   NOP
000000BC  00000000   NOP
000000C4  00000000   NOP
000000C8  00000000   NOP
000000CC  00000000   NOP
000000D8  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StopClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StopClear
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StopClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StopClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_P_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStopDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStopDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStopDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStopDetect PLIB_I2C_ExistsStopDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsStopDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STOPDETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_startdetect_default.h  ----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_StartDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StartDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_StartWasDetected
16:                          PLIB_I2C_StartClear
17:                          PLIB_I2C_ExistsStartDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_STARTDETECT_DEFAULT_H
48:                  #define _I2C_STARTDETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_StartWasDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_StartWasDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_StartWasDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_StartWasDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D001208  8E220004   LW V0, 4(S1)
00000090  00000000   NOP
00000094  00000000   NOP
000000A0  00000000   NOP
000000A8  00000000   NOP
000000B4  00000000   NOP
66:                  
67:                      return (bool)regs->I2CxSTAT.S;
9D00120C  8C430010   LW V1, 16(V0)
9D001210  30630008   ANDI V1, V1, 8
00000094  00000000   NOP
00000098  00000000   NOP
000000A4  00000000   NOP
000000AC  00000000   NOP
000000B8  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_StartClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_StartClear 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_StartClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_StartClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_S_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsStartDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsStartDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsStartDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsStartDetect PLIB_I2C_ExistsStartDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsStartDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_STARTDETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slavereadrequest_default.h  -----
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveReadRequest_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveReadRequest
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveReadIsRequested
16:                          PLIB_I2C_ExistsSlaveReadRequest
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_SLAVEREADREQUEST_DEFAULT_H
47:                  #define _I2C_SLAVEREADREQUEST_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_SlaveReadIsRequested_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_SlaveReadIsRequested
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_SlaveReadIsRequested function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_SlaveReadIsRequested_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)regs->I2CxSTAT.R_W;
9D000114  8E420010   LW V0, 16(S2)
9D000118  30420004   ANDI V0, V0, 4
9D00017C  8E420010   LW V0, 16(S2)
9D000180  30420004   ANDI V0, V0, 4
9D000210  8E420010   LW V0, 16(S2)
9D000214  30420004   ANDI V0, V0, 4
9D000308  8E420010   LW V0, 16(S2)
9D00030C  30420004   ANDI V0, V0, 4
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsSlaveReadRequest_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsSlaveReadRequest
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveReadRequest function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsSlaveReadRequest PLIB_I2C_ExistsSlaveReadRequest
81:                  PLIB_TEMPLATE bool I2C_ExistsSlaveReadRequest_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_SLAVEREADREQUEST_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slavemask_default.h  ------------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveMask_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveMask
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveMask7BitSet
16:                          PLIB_I2C_SlaveMask7BitGet
17:                          PLIB_I2C_SlaveMask10BitSet
18:                          PLIB_I2C_SlaveMask10BitGet
19:                          PLIB_I2C_ExistsSlaveMask
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _I2C_SLAVEMASK_DEFAULT_H
50:                  #define _I2C_SLAVEMASK_DEFAULT_H
51:                  
52:                  #include "i2c_Registers.h"
53:                  
54:                  //******************************************************************************
55:                  /* Function :  I2C_SlaveMask7BitSet_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_I2C_SlaveMask7BitSet 
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_I2C_SlaveMask7BitSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void I2C_SlaveMask7BitSet_Default( I2C_MODULE_ID index , uint8_t mask )
65:                  {
66:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
67:                  
68:                      regs->I2CxMSK = mask;
9D000BE0  92020048   LBU V0, 72(S0)
9D000BE4  AE220030   SW V0, 48(S1)
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  I2C_SlaveMask7BitGet_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_I2C_SlaveMask7BitGet 
77:                      Operation is atomic
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_I2C_SlaveMask7BitGet function.
81:                  */
82:                  
83:                  PLIB_TEMPLATE uint8_t I2C_SlaveMask7BitGet_Default( I2C_MODULE_ID index )
84:                  {
85:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
86:                  
87:                      return (uint8_t)regs->I2CxMSK;
88:                  }
89:                  
90:                  
91:                  //******************************************************************************
92:                  /* Function :  I2C_SlaveMask10BitSet_Default
93:                  
94:                    Summary:
95:                      Implements Default variant of PLIB_I2C_SlaveMask10BitSet 
96:                  
97:                    Description:
98:                      This template implements the Default variant of the PLIB_I2C_SlaveMask10BitSet function.
99:                  */
100:                 
101:                 PLIB_TEMPLATE void I2C_SlaveMask10BitSet_Default( I2C_MODULE_ID index , uint16_t mask )
102:                 {
103:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
104:                 
105:                     regs->I2CxMSK = mask;
106:                 }
107:                 
108:                 
109:                 //******************************************************************************
110:                 /* Function :  I2C_SlaveMask10BitGet_Default
111:                 
112:                   Summary:
113:                     Implements Default variant of PLIB_I2C_SlaveMask10BitGet
114:                     Operation is atomic
115:                 
116:                   Description:
117:                     This template implements the Default variant of the PLIB_I2C_SlaveMask10BitGet function.
118:                 */
119:                 
120:                 PLIB_TEMPLATE uint16_t I2C_SlaveMask10BitGet_Default( I2C_MODULE_ID index )
121:                 {
122:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
123:                 
124:                     return (uint16_t)regs->I2CxMSK;
125:                 }
126:                 
127:                 
128:                 //******************************************************************************
129:                 /* Function :  I2C_ExistsSlaveMask_Default
130:                 
131:                   Summary:
132:                     Implements Default variant of PLIB_I2C_ExistsSlaveMask
133:                 
134:                   Description:
135:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveMask function.
136:                 */
137:                 
138:                 #define PLIB_I2C_ExistsSlaveMask PLIB_I2C_ExistsSlaveMask
139:                 PLIB_TEMPLATE bool I2C_ExistsSlaveMask_Default( I2C_MODULE_ID index )
140:                 {
141:                     return true;
142:                 }
143:                 
144:                 
145:                 #endif /*_I2C_SLAVEMASK_DEFAULT_H*/
146:                 
147:                 /******************************************************************************
148:                  End of File
149:                 */
150:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slavedatadetect_default.h  ------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveDataDetect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveDataDetect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveDataIsDetected
16:                          PLIB_I2C_SlaveAddressIsDetected
17:                          PLIB_I2C_ExistsSlaveDataDetect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVEDATADETECT_DEFAULT_H
48:                  #define _I2C_SLAVEDATADETECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveDataIsDetected_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveDataIsDetected
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveDataIsDetected function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_SlaveDataIsDetected_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.D_A;
9D000220  8E420010   LW V0, 16(S2)
9D000224  30420020   ANDI V0, V0, 32
9D000318  8E420010   LW V0, 16(S2)
9D00031C  30420020   ANDI V0, V0, 32
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveAddressIsDetected_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveAddressIsDetected 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveAddressIsDetected function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE bool I2C_SlaveAddressIsDetected_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      return (bool)!regs->I2CxSTAT.D_A;
9D000124  8E420010   LW V0, 16(S2)
9D000128  30420020   ANDI V0, V0, 32
9D00018C  8E420010   LW V0, 16(S2)
9D000190  30420020   ANDI V0, V0, 32
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsSlaveDataDetect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsSlaveDataDetect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveDataDetect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsSlaveDataDetect PLIB_I2C_ExistsSlaveDataDetect
101:                 PLIB_TEMPLATE bool I2C_ExistsSlaveDataDetect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_SLAVEDATADETECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slaveclockhold_default.h  -------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveClockHold_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveClockHold
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveClockHold
16:                          PLIB_I2C_SlaveClockRelease
17:                          PLIB_I2C_ExistsSlaveClockHold
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVECLOCKHOLD_DEFAULT_H
48:                  #define _I2C_SLAVECLOCKHOLD_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveClockHold_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveClockHold
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveClockHold function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveClockHold_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONCLR = I2CxCON_SCLREL_MASK;
9D0001A0  24021000   ADDIU V0, ZERO, 4096
9D0001A4  AE420004   SW V0, 4(S2)
9D000328  24021000   ADDIU V0, ZERO, 4096
9D00032C  AE420004   SW V0, 4(S2)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveClockRelease_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveClockRelease 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveClockRelease function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_SlaveClockRelease_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONSET = I2CxCON_SCLREL_MASK;
9D00016C  24021000   ADDIU V0, ZERO, 4096
9D000170  AE420008   SW V0, 8(S2)
9D000200  24021000   ADDIU V0, ZERO, 4096
9D000204  AE420008   SW V0, 8(S2)
9D00023C  24021000   ADDIU V0, ZERO, 4096
9D000240  AE420008   SW V0, 8(S2)
9D000354  24021000   ADDIU V0, ZERO, 4096
9D000358  AE420008   SW V0, 8(S2)
9D0008FC  24021000   ADDIU V0, ZERO, 4096
9D000900  AE420008   SW V0, 8(S2)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsSlaveClockHold_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsSlaveClockHold
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsSlaveClockHold function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsSlaveClockHold PLIB_I2C_ExistsSlaveClockHold
101:                 PLIB_TEMPLATE bool I2C_ExistsSlaveClockHold_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_SLAVECLOCKHOLD_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slaveaddress7bit_default.h  -----
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveAddress7Bit_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveAddress7Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveAddress7BitSet
16:                          PLIB_I2C_SlaveAddress7BitGet
17:                          PLIB_I2C_ExistsSlaveAddress7Bit
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_SLAVEADDRESS7BIT_DEFAULT_H
48:                  #define _I2C_SLAVEADDRESS7BIT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveAddress7BitSet_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveAddress7BitSet 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress7BitSet function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveAddress7BitSet_Default( I2C_MODULE_ID index , uint8_t address )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxADD = address;
9D000B9C  7C423840   EXT V0, V0, 1, 8
9D000BA0  AE220020   SW V0, 32(S1)
68:                  
69:                      /* Configure for 7-bit address */
70:                      regs->I2CxCONCLR = I2CxCON_A10M_MASK;
9D000BA4  24020400   ADDIU V0, ZERO, 1024
9D000BA8  AE220004   SW V0, 4(S1)
71:                  }
72:                  
73:                  
74:                  //******************************************************************************
75:                  /* Function :  I2C_SlaveAddress7BitGet_Default
76:                  
77:                    Summary:
78:                      Implements Default variant of PLIB_I2C_SlaveAddress7BitGet 
79:                      Operation is atomic
80:                  
81:                    Description:
82:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress7BitGet function.
83:                  */
84:                  
85:                  PLIB_TEMPLATE uint8_t I2C_SlaveAddress7BitGet_Default( I2C_MODULE_ID index )
86:                  {
87:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
88:                  
89:                      return (uint8_t)regs->I2CxADD;
90:                  }
91:                  
92:                  
93:                  //******************************************************************************
94:                  /* Function :  I2C_ExistsSlaveAddress7Bit_Default
95:                  
96:                    Summary:
97:                      Implements Default variant of PLIB_I2C_ExistsSlaveAddress7Bit
98:                      Operation is atomic
99:                  
100:                   Description:
101:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveAddress7Bit function.
102:                 */
103:                 
104:                 #define PLIB_I2C_ExistsSlaveAddress7Bit PLIB_I2C_ExistsSlaveAddress7Bit
105:                 PLIB_TEMPLATE bool I2C_ExistsSlaveAddress7Bit_Default( I2C_MODULE_ID index )
106:                 {
107:                     return true;
108:                 }
109:                 
110:                 
111:                 #endif /*_I2C_SLAVEADDRESS7BIT_DEFAULT_H*/
112:                 
113:                 /******************************************************************************
114:                  End of File
115:                 */
116:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_slaveaddress10bit_default.h  ----
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_SlaveAddress10Bit_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SlaveAddress10Bit
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveAddress10BitSet
16:                          PLIB_I2C_SlaveAddress10BitGet
17:                          PLIB_I2C_SlaveAddressModeIs10Bits
18:                          PLIB_I2C_ExistsSlaveAddress10Bit
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _I2C_SLAVEADDRESS10BIT_DEFAULT_H
49:                  #define _I2C_SLAVEADDRESS10BIT_DEFAULT_H
50:                  
51:                  #include "i2c_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  I2C_SlaveAddress10BitSet_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_I2C_SlaveAddress10BitSet 
58:                      Operation is atomic
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress10BitSet function.
62:                  */
63:                  
64:                  PLIB_TEMPLATE void I2C_SlaveAddress10BitSet_Default( I2C_MODULE_ID index , uint16_t address )
65:                  {
66:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
67:                  
68:                      regs->I2CxADD = address;
9D000BB4  00021042   SRL V0, V0, 1
9D000BB8  AE220020   SW V0, 32(S1)
69:                  
70:                      /* Configure for 10-bit address */
71:                      regs->I2CxCONSET = I2CxCON_A10M_MASK;
9D000BBC  24020400   ADDIU V0, ZERO, 1024
9D000BC0  AE220008   SW V0, 8(S1)
72:                  }
73:                  
74:                  
75:                  //******************************************************************************
76:                  /* Function :  I2C_SlaveAddress10BitGet_Default
77:                  
78:                    Summary:
79:                      Implements Default variant of PLIB_I2C_SlaveAddress10BitGet 
80:                      Operation is atomic
81:                  
82:                    Description:
83:                      This template implements the Default variant of the PLIB_I2C_SlaveAddress10BitGet function.
84:                  */
85:                  
86:                  PLIB_TEMPLATE uint16_t I2C_SlaveAddress10BitGet_Default( I2C_MODULE_ID index )
87:                  {
88:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
89:                  
90:                      return (uint16_t)regs->I2CxADD;
91:                  }
92:                  
93:                  
94:                  //******************************************************************************
95:                  /* Function :  I2C_SlaveAddressModeIs10Bits_Default
96:                  
97:                    Summary:
98:                      Implements Default variant of PLIB_I2C_SlaveAddressModeIs10Bits 
99:                      Operation is atomic
100:                 
101:                   Description:
102:                     This template implements the Default variant of the PLIB_I2C_SlaveAddressModeIs10Bits function.
103:                 */
104:                 
105:                 PLIB_TEMPLATE bool I2C_SlaveAddressModeIs10Bits_Default( I2C_MODULE_ID index )
106:                 {
107:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
108:                     return (bool)regs->I2CxCON.A10M;
109:                 }
110:                 
111:                 
112:                 //******************************************************************************
113:                 /* Function :  I2C_ExistsSlaveAddress10Bit_Default
114:                 
115:                   Summary:
116:                     Implements Default variant of PLIB_I2C_ExistsSlaveAddress10Bit
117:                 
118:                   Description:
119:                     This template implements the Default variant of the PLIB_I2C_ExistsSlaveAddress10Bit function.
120:                 */
121:                 
122:                 #define PLIB_I2C_ExistsSlaveAddress10Bit PLIB_I2C_ExistsSlaveAddress10Bit
123:                 PLIB_TEMPLATE bool I2C_ExistsSlaveAddress10Bit_Default( I2C_MODULE_ID index )
124:                 {
125:                     return true;
126:                 }
127:                 
128:                 
129:                 #endif /*_I2C_SLAVEADDRESS10BIT_DEFAULT_H*/
130:                 
131:                 /******************************************************************************
132:                  End of File
133:                 */
134:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_reservedaddressprotect_default.h  
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReservedAddressProtect_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReservedAddressProtect
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReservedAddressProtectEnable
16:                          PLIB_I2C_ReservedAddressProtectDisable
17:                          PLIB_I2C_ExistsReservedAddressProtect
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_RESERVEDADDRESSPROTECT_DEFAULT_H
48:                  #define _I2C_RESERVEDADDRESSPROTECT_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_ReservedAddressProtectEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_ReservedAddressProtectEnable
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReservedAddressProtectEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_ReservedAddressProtectEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_STRICT_MASK;
9D000BCC  24020800   ADDIU V0, ZERO, 2048
9D000BD0  AE220008   SW V0, 8(S1)
9D000BDC  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_ReservedAddressProtectDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_ReservedAddressProtectDisable 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_ReservedAddressProtectDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_ReservedAddressProtectDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_STRICT_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsReservedAddressProtect_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsReservedAddressProtect
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsReservedAddressProtect function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsReservedAddressProtect PLIB_I2C_ExistsReservedAddressProtect
101:                 PLIB_TEMPLATE bool I2C_ExistsReservedAddressProtect_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_RESERVEDADDRESSPROTECT_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_receiveroverflow_default.h  -----
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceiverOverflow_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceiverOverflow
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceiverOverflowHasOccurred
16:                          PLIB_I2C_ReceiverOverflowClear
17:                          PLIB_I2C_ExistsReceiverOverflow
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_RECEIVEROVERFLOW_DEFAULT_H
48:                  #define _I2C_RECEIVEROVERFLOW_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_ReceiverOverflowHasOccurred_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_ReceiverOverflowHasOccurred
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReceiverOverflowHasOccurred function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE bool I2C_ReceiverOverflowHasOccurred_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      return (bool)regs->I2CxSTAT.I2COV;
9D000848  8E420010   LW V0, 16(S2)
9D00084C  30420040   ANDI V0, V0, 64
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_ReceiverOverflowClear_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_ReceiverOverflowClear
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_ReceiverOverflowClear function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_ReceiverOverflowClear_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxSTATCLR = I2CxSTAT_I2COV_MASK;
9D000858  24020040   ADDIU V0, ZERO, 64
9D00085C  AE420014   SW V0, 20(S2)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsReceiverOverflow_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsReceiverOverflow
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsReceiverOverflow function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsReceiverOverflow PLIB_I2C_ExistsReceiverOverflow
101:                 PLIB_TEMPLATE bool I2C_ExistsReceiverOverflow_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_RECEIVEROVERFLOW_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_receivedbyteget_default.h  ------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteGet_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteGet
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteGet
16:                          PLIB_I2C_ExistsReceivedByteGet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_RECEIVEDBYTEGET_DEFAULT_H
47:                  #define _I2C_RECEIVEDBYTEGET_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_ReceivedByteGet_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_ReceivedByteGet
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteGet function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE uint8_t I2C_ReceivedByteGet_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (uint8_t)regs->I2CxRCV;
9D000168  8E420060   LW V0, 96(S2)
9D00019C  8E420060   LW V0, 96(S2)
9D000264  8E430060   LW V1, 96(S2)
9D000268  A0430000   SB V1, 0(V0)
9D0002C4  8E420060   LW V0, 96(S2)
9D000530  8E430060   LW V1, 96(S2)
9D000534  A0430000   SB V1, 0(V0)
9D0005A4  8E430060   LW V1, 96(S2)
9D0005A8  A0430000   SB V1, 0(V0)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsReceivedByteGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsReceivedByteGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteGet function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsReceivedByteGet PLIB_I2C_ExistsReceivedByteGet
81:                  PLIB_TEMPLATE bool I2C_ExistsReceivedByteGet_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_RECEIVEDBYTEGET_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_receivedbyteavailable_default.h  
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteAvailable_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteAvailable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteIsAvailable
16:                          PLIB_I2C_ExistsReceivedByteAvailable
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H
47:                  #define _I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_ReceivedByteIsAvailable_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_ReceivedByteIsAvailable
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteIsAvailable function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE bool I2C_ReceivedByteIsAvailable_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      return (bool)regs->I2CxSTAT.RBF;
9D000504  8E420010   LW V0, 16(S2)
9D000508  30420002   ANDI V0, V0, 2
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsReceivedByteAvailable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsReceivedByteAvailable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteAvailable function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsReceivedByteAvailable PLIB_I2C_ExistsReceivedByteAvailable
81:                  PLIB_TEMPLATE bool I2C_ExistsReceivedByteAvailable_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_RECEIVEDBYTEAVAILABLE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_receivedbyteacknowledge_default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ReceivedByteAcknowledge_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ReceivedByteAcknowledge
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_ReceivedByteAcknowledge
16:                          PLIB_I2C_ReceiverByteAcknowledgeHasCompleted
17:                          PLIB_I2C_MasterReceiverReadyToAcknowledge
18:                          PLIB_I2C_ExistsReceivedByteAcknowledge
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H
49:                  #define _I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H
50:                  
51:                  #include "i2c_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  I2C_ReceivedByteAcknowledge_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_I2C_ReceivedByteAcknowledge 
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_ReceivedByteAcknowledge function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_ReceivedByteAcknowledge_Default( I2C_MODULE_ID index , bool ack )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      if (ack) {
68:                  	/* Clearing this bit will positively acknowledge */
69:                  	regs->I2CxCONCLR = I2CxCON_ACKDT_MASK;
9D000570  24020020   ADDIU V0, ZERO, 32
9D000574  AE420004   SW V0, 4(S2)
70:                  	regs->I2CxCONSET = I2CxCON_ACKEN_MASK;
9D000578  24020010   ADDIU V0, ZERO, 16
9D00057C  AE420008   SW V0, 8(S2)
71:                      } else {
72:                  	regs->I2CxCONSET = I2CxCON_ACKDT_MASK | I2CxCON_ACKEN_MASK;
9D0005C4  24020030   ADDIU V0, ZERO, 48
9D0005C8  AE420008   SW V0, 8(S2)
73:                      }
74:                  }
75:                  
76:                  
77:                  //******************************************************************************
78:                  /* Function :  I2C_ReceiverByteAcknowledgeHasCompleted_Default
79:                  
80:                    Summary:
81:                      Implements Default variant of PLIB_I2C_ReceiverByteAcknowledgeHasCompleted
82:                      Operation is atomic
83:                  
84:                    Description:
85:                      This template implements the Default variant of the PLIB_I2C_ReceiverByteAcknowledgeHasCompleted function.
86:                  */
87:                  
88:                  PLIB_TEMPLATE bool I2C_ReceiverByteAcknowledgeHasCompleted_Default( I2C_MODULE_ID index )
89:                  {
90:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
91:                      return (bool)!regs->I2CxCON.ACKEN;
9D000778  8E420000   LW V0, 0(S2)
9D00077C  30420010   ANDI V0, V0, 16
92:                  }
93:                  
94:                  
95:                  //******************************************************************************
96:                  /* Function :  I2C_MasterReceiverReadyToAcknowledge_Default
97:                  
98:                    Summary:
99:                      Implements Default variant of PLIB_I2C_MasterReceiverReadyToAcknowledge
100:                     Operation is atomic
101:                 
102:                   Description:
103:                     This template implements the Default variant of the PLIB_I2C_MasterReceiverReadyToAcknowledge function.
104:                 */
105:                 
106:                 PLIB_TEMPLATE bool I2C_MasterReceiverReadyToAcknowledge_Default( I2C_MODULE_ID index )
107:                 {
108:                     volatile i2c_register_t *regs = (i2c_register_t *)index;
109:                     volatile uint32_t *i2c_ctrl_reg = (volatile uint32_t *)&regs->I2CxCON;
110:                 
111:                     /* It is not okay to acknowledge if the last five bits in the I2CCON register is high */
112:                     return (bool)!(*i2c_ctrl_reg & I2C_BUS_IDLE_BITS);
9D000558  8E420000   LW V0, 0(S2)
9D00055C  3042001F   ANDI V0, V0, 31
9D0005AC  8E420000   LW V0, 0(S2)
9D0005B0  3042001F   ANDI V0, V0, 31
113:                 }
114:                 
115:                 
116:                 //******************************************************************************
117:                 /* Function :  I2C_ExistsReceivedByteAcknowledge_Default
118:                 
119:                   Summary:
120:                     Implements Default variant of PLIB_I2C_ExistsReceivedByteAcknowledge
121:                 
122:                   Description:
123:                     This template implements the Default variant of the PLIB_I2C_ExistsReceivedByteAcknowledge function.
124:                 */
125:                 
126:                 #define PLIB_I2C_ExistsReceivedByteAcknowledge PLIB_I2C_ExistsReceivedByteAcknowledge
127:                 PLIB_TEMPLATE bool I2C_ExistsReceivedByteAcknowledge_Default( I2C_MODULE_ID index )
128:                 {
129:                     return true;
130:                 }
131:                 
132:                 
133:                 #endif /*_I2C_RECEIVEDBYTEACKNOWLEDGE_DEFAULT_H*/
134:                 
135:                 /******************************************************************************
136:                  End of File
137:                 */
138:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_moduleenable_default.h  ---------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ModuleEnable_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ModuleEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_Enable
16:                          PLIB_I2C_Disable
17:                          PLIB_I2C_ExistsModuleEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_MODULEENABLE_DEFAULT_H
48:                  #define _I2C_MODULEENABLE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_Enable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_Enable
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_Enable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_Enable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
00000088  00000000   NOP
66:                      regs->I2CxCONSET = I2CxCON_ON_MASK;
9D000CEC  34028000   ORI V0, ZERO, -32768
9D000CF0  AE220008   SW V0, 8(S1)
0000008C  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_Disable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_Disable 
75:                      Operation is atomic
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_I2C_Disable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void I2C_Disable_Default( I2C_MODULE_ID index )
82:                  {
83:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
0000007C  00000000   NOP
84:                      regs->I2CxCONCLR = I2CxCON_ON_MASK;
00000060  00000000   NOP
00000080  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  I2C_ExistsModuleEnable_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_I2C_ExistsModuleEnable
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_I2C_ExistsModuleEnable function.
96:                  */
97:                  
98:                  #define PLIB_I2C_ExistsModuleEnable PLIB_I2C_ExistsModuleEnable
99:                  PLIB_TEMPLATE bool I2C_ExistsModuleEnable_Default( I2C_MODULE_ID index )
100:                 {
101:                     return true;
102:                 }
103:                 
104:                 
105:                 #endif /*_I2C_MODULEENABLE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_masterstop_default.h  -----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStop_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterStop
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStop
16:                          PLIB_I2C_ExistsMasterStop
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTOP_DEFAULT_H
47:                  #define _I2C_MASTERSTOP_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStop_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStop
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_I2C_MasterStop function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void I2C_MasterStop_Default( I2C_MODULE_ID index )
62:                  {
63:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
00000010  00000000   NOP
64:                  
65:                      regs->I2CxCONSET = I2CxCON_PEN_MASK;
9D00068C  24020004   ADDIU V0, ZERO, 4
9D000690  AE420008   SW V0, 8(S2)
9D0006A0  24020004   ADDIU V0, ZERO, 4
9D0006A4  AE420008   SW V0, 8(S2)
9D000748  24020004   ADDIU V0, ZERO, 4
9D00074C  AE420008   SW V0, 8(S2)
9D0007A0  24020004   ADDIU V0, ZERO, 4
9D0007A4  AE420008   SW V0, 8(S2)
00000014  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  I2C_ExistsMasterStop_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_I2C_ExistsMasterStop
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStop function.
77:                  */
78:                  
79:                  #define PLIB_I2C_ExistsMasterStop PLIB_I2C_ExistsMasterStop
80:                  PLIB_TEMPLATE bool I2C_ExistsMasterStop_Default( I2C_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_I2C_MASTERSTOP_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_masterstartrepeat_default.h  ----
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStartRepeat_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations (atomic)
12:                      For Feature : MasterStartRepeat
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStartRepeat
16:                          PLIB_I2C_ExistsMasterStartRepeat
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTARTREPEAT_DEFAULT_H
47:                  #define _I2C_MASTERSTARTREPEAT_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStartRepeat_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStartRepeat.
56:                      This operation is atomic.
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_MasterStartRepeat function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_MasterStartRepeat_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D000730  8E020004   LW V0, 4(S0)
00000010  00000000   NOP
65:                  
66:                      regs->I2CxCONSET = I2CxCON_RSEN_MASK;
9D000734  24030002   ADDIU V1, ZERO, 2
9D000738  AC430008   SW V1, 8(V0)
00000014  00000000   NOP
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsMasterStartRepeat_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsMasterStartRepeat
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStartRepeat function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsMasterStartRepeat PLIB_I2C_ExistsMasterStartRepeat
81:                  PLIB_TEMPLATE bool I2C_ExistsMasterStartRepeat_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_MASTERSTARTREPEAT_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_masterstart_default.h  ----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterStart_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterStart
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterStart
16:                          PLIB_I2C_ExistsMasterStart
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERSTART_DEFAULT_H
47:                  #define _I2C_MASTERSTART_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterStart_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterStart 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_I2C_MasterStart function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void I2C_MasterStart_Default( I2C_MODULE_ID index )
62:                  {
63:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D001294  8E230004   LW V1, 4(S1)
0000011C  00000000   NOP
00000120  00000000   NOP
0000012C  00000000   NOP
00000134  00000000   NOP
00000140  00000000   NOP
64:                  
65:                      regs->I2CxCONSET = I2CxCON_SEN_MASK;
9D0009A4  24030001   ADDIU V1, ZERO, 1
9D0009A8  AC430008   SW V1, 8(V0)
9D001298  AC620008   SW V0, 8(V1)
00000120  00000000   NOP
00000124  00000000   NOP
00000130  00000000   NOP
00000138  00000000   NOP
00000144  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  I2C_ExistsMasterStart_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_I2C_ExistsMasterStart
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterStart function.
77:                  */
78:                  
79:                  #define PLIB_I2C_ExistsMasterStart PLIB_I2C_ExistsMasterStart
80:                  PLIB_TEMPLATE bool I2C_ExistsMasterStart_Default( I2C_MODULE_ID index )
81:                  {
82:                      return true;
83:                  }
84:                  
85:                  
86:                  #endif /*_I2C_MASTERSTART_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_masterreceiverclock1byte_default.h
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_MasterReceiverClock1Byte_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : MasterReceiverClock1Byte
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_MasterReceiverClock1Byte
16:                          PLIB_I2C_ExistsMasterReceiverClock1Byte
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H
47:                  #define _I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  I2C_MasterReceiverClock1Byte_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_I2C_MasterReceiverClock1Byte
56:                      Operation is atomic
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_I2C_MasterReceiverClock1Byte function.
60:                  */
61:                  
62:                  PLIB_TEMPLATE void I2C_MasterReceiverClock1Byte_Default( I2C_MODULE_ID index )
63:                  {
64:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
65:                  
66:                      regs->I2CxCONSET = I2CxCON_RCEN_MASK;
9D000788  24020008   ADDIU V0, ZERO, 8
9D00078C  AE420008   SW V0, 8(S2)
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  I2C_ExistsMasterReceiverClock1Byte_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_I2C_ExistsMasterReceiverClock1Byte
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_I2C_ExistsMasterReceiverClock1Byte function.
78:                  */
79:                  
80:                  #define PLIB_I2C_ExistsMasterReceiverClock1Byte PLIB_I2C_ExistsMasterReceiverClock1Byte
81:                  PLIB_TEMPLATE bool I2C_ExistsMasterReceiverClock1Byte_Default( I2C_MODULE_ID index )
82:                  {
83:                      return true;
84:                  }
85:                  
86:                  
87:                  #endif /*_I2C_MASTERRECEIVERCLOCK1BYTE_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_highfrequency_default.h  --------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_HighFrequency_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : HighFrequency
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_HighFrequencyEnable
16:                          PLIB_I2C_HighFrequencyDisable
17:                          PLIB_I2C_ExistsHighFrequency
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_HIGHFREQUENCY_DEFAULT_H
48:                  #define _I2C_HIGHFREQUENCY_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_HighFrequencyEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_HighFrequencyEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_HighFrequencyEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_HighFrequencyEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_DISSLW_MASK;
9D000B58  AE220008   SW V0, 8(S1)
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_HighFrequencyDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_HighFrequencyDisable 
76:                  
77:                    Description:
78:                      This template implements the Default variant of the PLIB_I2C_HighFrequencyDisable function.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void I2C_HighFrequencyDisable_Default( I2C_MODULE_ID index )
82:                  {
83:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
84:                  
85:                      regs->I2CxCONCLR = I2CxCON_DISSLW_MASK;
9D000B64  AE220004   SW V0, 4(S1)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  I2C_ExistsHighFrequency_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_I2C_ExistsHighFrequency
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_I2C_ExistsHighFrequency function.
97:                  */
98:                  
99:                  #define PLIB_I2C_ExistsHighFrequency PLIB_I2C_ExistsHighFrequency
100:                 PLIB_TEMPLATE bool I2C_ExistsHighFrequency_Default( I2C_MODULE_ID index )
101:                 {
102:                     return true;
103:                 }
104:                 
105:                 
106:                 #endif /*_I2C_HIGHFREQUENCY_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_generalcall_default.h  ----------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_GeneralCall_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : GeneralCall
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_GeneralCallEnable
16:                          PLIB_I2C_GeneralCallDisable
17:                          PLIB_I2C_ExistsGeneralCall
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_GENERALCALL_DEFAULT_H
48:                  #define _I2C_GENERALCALL_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_GeneralCallEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_GeneralCallEnable
57:                      Operation is atomic.
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_GeneralCallEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_GeneralCallEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_GCEN_MASK;
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_GeneralCallDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_GeneralCallDisable 
76:                      Operation is atomic.
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_GeneralCallDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_GeneralCallDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_GCEN_MASK;
9D000BD4  24030080   ADDIU V1, ZERO, 128
9D000BD8  AE230004   SW V1, 4(S1)
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsGeneralCall_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsGeneralCall
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsGeneralCall function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsGeneralCall PLIB_I2C_ExistsGeneralCall
101:                 PLIB_TEMPLATE bool I2C_ExistsGeneralCall_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_GENERALCALL_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_clockstretching_default.h  ------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_ClockStretching_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ClockStretching
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_SlaveClockStretchingEnable
16:                          PLIB_I2C_SlaveClockStretchingDisable
17:                          PLIB_I2C_ExistsClockStretching
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_CLOCKSTRETCHING_DEFAULT_H
48:                  #define _I2C_CLOCKSTRETCHING_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  I2C_SlaveClockStretchingEnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_I2C_SlaveClockStretchingEnable 
57:                      Operation is atomic
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_I2C_SlaveClockStretchingEnable function.
61:                  */
62:                  
63:                  PLIB_TEMPLATE void I2C_SlaveClockStretchingEnable_Default( I2C_MODULE_ID index )
64:                  {
65:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
66:                  
67:                      regs->I2CxCONSET = I2CxCON_STREN_MASK;
9D000BAC  0B4002F2   J 0x9D000BC8
9D000BB0  24020040   ADDIU V0, ZERO, 64
9D000BC4  24020040   ADDIU V0, ZERO, 64
9D000BC8  AE220008   SW V0, 8(S1)
9D000BCC  24020800   ADDIU V0, ZERO, 2048
9D000BD0  AE220008   SW V0, 8(S1)
9D000BD4  24030080   ADDIU V1, ZERO, 128
9D000BD8  AE230004   SW V1, 4(S1)
9D000BDC  AE220008   SW V0, 8(S1)
9D000BE0  92020048   LBU V0, 72(S0)
9D000BE4  AE220030   SW V0, 48(S1)
9D000BE8  3C02A001   LUI V0, -24575
9D000BEC  8C428740   LW V0, -30912(V0)
9D000BF0  00021942   SRL V1, V0, 5
9D000BF4  00031900   SLL V1, V1, 4
9D000BF8  3C04BF88   LUI A0, -16504
9D000BFC  24841060   ADDIU A0, A0, 4192
9D000C00  00832021   ADDU A0, A0, V1
9D000C04  24050001   ADDIU A1, ZERO, 1
9D000C08  00451004   SLLV V0, A1, V0
9D000C0C  AC820008   SW V0, 8(A0)
9D000C10  3C04BF88   LUI A0, -16504
9D000C14  24841030   ADDIU A0, A0, 4144
9D000C18  00831821   ADDU V1, A0, V1
9D000C1C  AC620004   SW V0, 4(V1)
9D000C20  92030024   LBU V1, 36(S0)
9D000C24  3C02A001   LUI V0, -24575
9D000C28  2442870C   ADDIU V0, V0, -30964
9D000C2C  A0430028   SB V1, 40(V0)
9D000C30  A040001C   SB ZERO, 28(V0)
9D000C34  24030002   ADDIU V1, ZERO, 2
9D000C38  AC430058   SW V1, 88(V0)
9D000C3C  8E030044   LW V1, 68(S0)
9D000C40  AC430064   SW V1, 100(V0)
9D000C44  3C02A001   LUI V0, -24575
9D000C48  24428560   ADDIU V0, V0, -31392
9D000C4C  24430188   ADDIU V1, V0, 392
9D000C50  A0400000   SB ZERO, 0(V0)
9D000C54  AC400030   SW ZERO, 48(V0)
9D000C58  24420038   ADDIU V0, V0, 56
9D000C5C  5443FFFD   BNEL V0, V1, 0x9D000C54
9D000C60  A0400000   SB ZERO, 0(V0)
9D000C64  3C05A001   LUI A1, -24575
9D000C68  24A2870C   ADDIU V0, A1, -30964
9D000C6C  8C460030   LW A2, 48(V0)
9D000C70  00063942   SRL A3, A2, 5
9D000C74  00073900   SLL A3, A3, 4
9D000C78  3C04BF88   LUI A0, -16504
9D000C7C  24841030   ADDIU A0, A0, 4144
9D000C80  00873821   ADDU A3, A0, A3
9D000C84  24030001   ADDIU V1, ZERO, 1
9D000C88  00C33004   SLLV A2, V1, A2
9D000C8C  ACE60004   SW A2, 4(A3)
9D000C90  8C460034   LW A2, 52(V0)
9D000C94  00063942   SRL A3, A2, 5
9D000C98  00073900   SLL A3, A3, 4
9D000C9C  00873821   ADDU A3, A0, A3
9D000CA0  00C33004   SLLV A2, V1, A2
9D000CA4  ACE60004   SW A2, 4(A3)
9D000CA8  8C460038   LW A2, 56(V0)
9D000CAC  00063942   SRL A3, A2, 5
9D000CB0  00073900   SLL A3, A3, 4
9D000CB4  00872021   ADDU A0, A0, A3
9D000CB8  00C33004   SLLV A2, V1, A2
9D000CBC  AC860004   SW A2, 4(A0)
9D000CC0  24040002   ADDIU A0, ZERO, 2
9D000CC4  ACA4870C   SW A0, -30964(A1)
9D000CC8  AC400068   SW ZERO, 104(V0)
9D000CCC  A0430060   SB V1, 96(V0)
9D000CD0  9382804C   LBU V0, -32692(GP)
9D000CD4  14400006   BNE V0, ZERO, 0x9D000CF0
9D000CD8  34028000   ORI V0, ZERO, -32768
9D000CDC  2782804C   ADDIU V0, GP, -32692
9D000CE0  A0430001   SB V1, 1(V0)
9D000CE4  A0430002   SB V1, 2(V0)
9D000CE8  A0430000   SB V1, 0(V0)
9D000CEC  34028000   ORI V0, ZERO, -32768
9D000CF0  AE220008   SW V0, 8(S1)
9D000CF4  3C02A001   LUI V0, -24575
9D000CF8  2442870C   ADDIU V0, V0, -30964
9D000CFC  8FBF001C   LW RA, 28(SP)
9D000D00  8FB10018   LW S1, 24(SP)
9D000D04  8FB00014   LW S0, 20(SP)
9D000D08  27BD0020   ADDIU SP, SP, 32
9D000D0C  03E00008   JR RA
9D000D10  00000000   NOP
68:                  }
69:                  
70:                  
71:                  //******************************************************************************
72:                  /* Function :  I2C_SlaveClockStretchingDisable_Default
73:                  
74:                    Summary:
75:                      Implements Default variant of PLIB_I2C_SlaveClockStretchingDisable 
76:                      Operation is atomic
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_I2C_SlaveClockStretchingDisable function.
80:                  */
81:                  
82:                  PLIB_TEMPLATE void I2C_SlaveClockStretchingDisable_Default( I2C_MODULE_ID index )
83:                  {
84:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
85:                  
86:                      regs->I2CxCONCLR = I2CxCON_STREN_MASK;
87:                  }
88:                  
89:                  
90:                  //******************************************************************************
91:                  /* Function :  I2C_ExistsClockStretching_Default
92:                  
93:                    Summary:
94:                      Implements Default variant of PLIB_I2C_ExistsClockStretching
95:                  
96:                    Description:
97:                      This template implements the Default variant of the PLIB_I2C_ExistsClockStretching function.
98:                  */
99:                  
100:                 #define PLIB_I2C_ExistsClockStretching PLIB_I2C_ExistsClockStretching
101:                 PLIB_TEMPLATE bool I2C_ExistsClockStretching_Default( I2C_MODULE_ID index )
102:                 {
103:                     return true;
104:                 }
105:                 
106:                 
107:                 #endif /*_I2C_CLOCKSTRETCHING_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_busidle_default.h  --------------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_BusIdle_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BusIdle
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_BusIsIdle
16:                          PLIB_I2C_ExistsBusIsIdle
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _I2C_BUSIDLE_DEFAULT_H
47:                  #define _I2C_BUSIDLE_DEFAULT_H
48:                  
49:                  #include "i2c_Registers.h"
50:                  
51:                  // *****************************************************************************
52:                  /* I2C bus idle status bits
53:                  
54:                    Summary:
55:                      Creates a mask for i2c bus idle status bits.
56:                  
57:                    Description:
58:                      This macro defines a mask for bus idle bits in the i2c control register.
59:                  
60:                    Remarks:
61:                      None
62:                  */
63:                  
64:                  #define I2C_BUS_IDLE_BITS						0x1F
65:                  
66:                  //******************************************************************************
67:                  /* Function :  I2C_BusIsIdle_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_I2C_BusIsIdle
71:                      Operation is atomic
72:                  
73:                    Description:
74:                      This template implements the Default variant of the PLIB_I2C_BusIsIdle function.
75:                  */
76:                  
77:                  PLIB_TEMPLATE bool I2C_BusIsIdle_Default( I2C_MODULE_ID index )
78:                  {
79:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
9D000980  8E020004   LW V0, 4(S0)
80:                      volatile uint32_t *i2c_ctrl_reg = (volatile uint32_t *)&regs->I2CxCON;
81:                  
82:                      return (bool)!((*i2c_ctrl_reg & I2C_BUS_IDLE_BITS) || regs->I2CxSTAT.TRSTAT);
9D000984  8C430000   LW V1, 0(V0)
9D000988  3063001F   ANDI V1, V1, 31
9D00098C  1460000A   BNE V1, ZERO, 0x9D0009B8
9D000990  8FB20018   LW S2, 24(SP)
9D000994  8C430010   LW V1, 16(V0)
9D000998  30634000   ANDI V1, V1, 16384
9D00099C  14600007   BNE V1, ZERO, 0x9D0009BC
9D0009A0  8FB10014   LW S1, 20(SP)
9D00123C  8C430000   LW V1, 0(V0)
9D001240  3063001F   ANDI V1, V1, 31
9D001244  54600037   BNEL V1, ZERO, 0x9D001324
9D001248  02001021   ADDU V0, S0, ZERO
9D00124C  8C420010   LW V0, 16(V0)
9D001250  30424000   ANDI V0, V0, 16384
9D001254  50400027   BEQL V0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceFlagGet
9D001258  8E230030   LW V1, 48(S1)
000000C4  00000000   NOP
000000C8  00000000   NOP
000000D4  00000000   NOP
000000DC  00000000   NOP
000000E8  00000000   NOP
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  I2C_ExistsBusIsIdle_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_I2C_ExistsBusIsIdle
91:                  
92:                    Description:
93:                      This template implements the Default variant of the PLIB_I2C_ExistsBusIsIdle function.
94:                  */
95:                  
96:                  #define PLIB_I2C_ExistsBusIsIdle PLIB_I2C_ExistsBusIsIdle
97:                  PLIB_TEMPLATE bool I2C_ExistsBusIsIdle_Default( I2C_MODULE_ID index )
98:                  {
99:                      return true;
100:                 }
101:                 
102:                 
103:                 #endif /*_I2C_BUSIDLE_DEFAULT_H*/
104:                 
105:                 /******************************************************************************
106:                  End of File
107:                 */
108:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/i2c/templates/i2c_baudrate_default.h  -------------
1:                   /*******************************************************************************
2:                     I2C Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       i2c_BaudRate_Default.h
6:                   
7:                     Summary:
8:                       I2C PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : BaudRate
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_I2C_BaudRateSet
16:                          PLIB_I2C_BaudRateGet
17:                          PLIB_I2C_ExistsBaudRate
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _I2C_BAUDRATE_DEFAULT_H
48:                  #define _I2C_BAUDRATE_DEFAULT_H
49:                  
50:                  #include "i2c_Registers.h"
51:                  
52:                  // *****************************************************************************
53:                  /* Pulse gobbler delay
54:                  
55:                    Summary:
56:                      Defines the Pulse gobbler delay in micro seconds.
57:                  
58:                    Description:
59:                      This macro defines the Pulse gobbler delay in micro seconds.
60:                  
61:                    Remarks:
62:                      None
63:                  */
64:                  
65:                  #define PULSE_GOBBLER_DELAY						0.104f
66:                  
67:                  //******************************************************************************
68:                  /* Function :  I2C_BaudRateSet_Default
69:                  
70:                    Summary:
71:                      Implements Default variant of PLIB_I2C_BaudRateSet
72:                      Operation is atomic.
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_I2C_BaudRateSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void I2C_BaudRateSet_Default( I2C_MODULE_ID index , uint32_t clockFrequency , I2C_BAUD_RATE baudRate )
79:                  {
80:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
81:                  
82:                      regs->I2CxBRG = (clockFrequency / baudRate / 2) - (clockFrequency / 10000000) - 2;
9D000AF4  8E030028   LW V1, 40(S0)
9D000AF8  0043001B   DIVU V0, V1
9D000AFC  006001F4   TEQ V1, ZERO
9D000B00  00001812   MFLO V1
9D000B04  00031842   SRL V1, V1, 1
9D000B08  3C046B5F   LUI A0, 27487
9D000B0C  3484CA6B   ORI A0, A0, -13717
9D000B10  00440019   MULTU 0, V0, A0
9D000B14  00001010   MFHI V0
9D000B18  00021582   SRL V0, V0, 22
9D000B1C  00621023   SUBU V0, V1, V0
9D000B20  2442FFFE   ADDIU V0, V0, -2
9D000B24  AE220040   SW V0, 64(S1)
83:                  }
84:                  
85:                  
86:                  //******************************************************************************
87:                  /* Function :  I2C_BaudRateGet_Default
88:                  
89:                    Summary:
90:                      Implements Default variant of PLIB_I2C_BaudRateGet
91:                      Operation is atomic
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_I2C_BaudRateGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE I2C_BAUD_RATE I2C_BaudRateGet_Default( I2C_MODULE_ID index , uint32_t clockFrequency )
98:                  {
99:                      volatile i2c_register_t *regs = (i2c_register_t *)index;
100:                     uint32_t div = regs->I2CxBRG;
101:                 
102:                     return (clockFrequency / ((div + 2) + (clockFrequency / 10000000))) >> 1;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  I2C_ExistsBaudRate_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_I2C_ExistsBaudRate
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_I2C_ExistsBaudRate function.
114:                 */
115:                 
116:                 #define PLIB_I2C_ExistsBaudRate PLIB_I2C_ExistsBaudRate
117:                 PLIB_TEMPLATE bool I2C_ExistsBaudRate_Default( I2C_MODULE_ID index )
118:                 {
119:                     return true;
120:                 }
121:                 
122:                 
123:                 #endif /*_I2C_BAUDRATE_DEFAULT_H*/
124:                 
125:                 /******************************************************************************
126:                  End of File
127:                 */
128:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_suspend_default.h  --------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_Suspend_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Suspend
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsSuspend
16:                          PLIB_DMA_SuspendEnable
17:                          PLIB_DMA_SuspendDisable
18:                          PLIB_DMA_SuspendIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_SUSPEND_DEFAULT_H
49:                  #define _DMA_SUSPEND_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsSuspend_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsSuspend
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsSuspend function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsSuspend PLIB_DMA_ExistsSuspend
64:                  PLIB_TEMPLATE bool DMA_ExistsSuspend_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_SuspendEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_SuspendEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_SuspendEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_SuspendEnable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DMACONSET = _DMACON_SUSPEND_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_SuspendDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_SuspendDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_SuspendDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_SuspendDisable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DMACONCLR = _DMACON_SUSPEND_MASK;
00000000  00000000   NOP
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_SuspendIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_SuspendIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_SuspendIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_SuspendIsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DMACON.SUSPEND;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_SUSPEND_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_starttransfer_default.h  --------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_StartTransfer_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : StartTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsStartTransfer
16:                          PLIB_DMA_StartTransferSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_STARTTRANSFER_DEFAULT_H
47:                  #define _DMA_STARTTRANSFER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsStartTransfer_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsStartTransfer
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsStartTransfer function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsStartTransfer PLIB_DMA_ExistsStartTransfer
62:                  PLIB_TEMPLATE bool DMA_ExistsStartTransfer_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_StartTransferSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_StartTransferSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_StartTransferSet function.
76:                      Operation is atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_StartTransferSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
82:                  
83:                      regs->DCHxECONSET = _DCH0ECON_CFORCE_MASK;
00000028  00000000   NOP
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_STARTTRANSFER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_enablecontrol_default.h  --------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_EnableControl_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : EnableControl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsEnableControl
16:                          PLIB_DMA_Enable
17:                          PLIB_DMA_Disable
18:                          PLIB_DMA_IsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_ENABLECONTROL_DEFAULT_H
49:                  #define _DMA_ENABLECONTROL_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsEnableControl_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsEnableControl
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsEnableControl function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsEnableControl PLIB_DMA_ExistsEnableControl
64:                  PLIB_TEMPLATE bool DMA_ExistsEnableControl_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_Enable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_Enable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_Enable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_Enable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DMACONSET = _DMACON_ON_MASK;
9D003264  34038000   ORI V1, ZERO, -32768
9D003268  ACA33008   SW V1, 12296(A1)
9D00326C  24A53060   ADDIU A1, A1, 12384
9D003270  00003021   ADDU A2, ZERO, ZERO
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_Disable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_Disable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_Disable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_Disable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DMACONCLR = _DMACON_ON_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_IsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_IsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_IsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_IsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DMACON.ON;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_ENABLECONTROL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcxorenable_default.h  ---------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCXOREnable_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCXOREnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCXOREnable
16:                          PLIB_DMA_CRCXOREnableSet
17:                          PLIB_DMA_CRCXOREnableGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCXORENABLE_DEFAULT_H
48:                  #define _DMA_CRCXORENABLE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCXOREnable_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCXOREnable
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCXOREnable function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCXOREnable PLIB_DMA_ExistsCRCXOREnable
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCXOREnable_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCXOREnableSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCXOREnableSet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCXOREnableSet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_CRCXOREnableSet_Default( DMA_MODULE_ID index , uint32_t DMACRCXOREnableMask )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      regs->DCRCXOR = DMACRCXOREnableMask;
000000B0  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCXOREnableGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCXOREnableGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCXOREnableGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint32_t DMA_CRCXOREnableGet_Default( DMA_MODULE_ID index )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     return (uint32_t)regs->DCRCXOR;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCXORENABLE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcwritebyteorder_default.h  ----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCWriteByteOrder_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCWriteByteOrder
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCWriteByteOrder
16:                          PLIB_DMA_CRCWriteByteOrderAlter
17:                          PLIB_DMA_CRCWriteByteOrderMaintain
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCWRITEBYTEORDER_DEFAULT_H
48:                  #define _DMA_CRCWRITEBYTEORDER_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCWriteByteOrder_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCWriteByteOrder
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCWriteByteOrder function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCWriteByteOrder PLIB_DMA_ExistsCRCWriteByteOrder
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCWriteByteOrder_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCWriteByteOrderAlter_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCWriteByteOrderAlter
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCWriteByteOrderAlter function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_CRCWriteByteOrderAlter_Default( DMA_MODULE_ID index )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      regs->DCRCCONSET = _DCRCCON_WBO_MASK;
00000098  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCWriteByteOrderMaintain_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCWriteByteOrderMaintain
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCWriteByteOrderMaintain function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_CRCWriteByteOrderMaintain_Default( DMA_MODULE_ID index )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     regs->DCRCCONCLR = _DCRCCON_WBO_MASK;
0000007C  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCWRITEBYTEORDER_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crctype_default.h  --------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCType_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCType
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCType
16:                          PLIB_DMA_CRCTypeGet
17:                          PLIB_DMA_CRCTypeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCTYPE_DEFAULT_H
48:                  #define _DMA_CRCTYPE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCType_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCType
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCType function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCType PLIB_DMA_ExistsCRCType
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCType_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCTypeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCTypeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCTypeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE DMA_CRC_TYPE DMA_CRCTypeGet_Default( DMA_MODULE_ID index )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      return (DMA_CRC_TYPE)regs->DCRCCON.CRCTYP;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCTypeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCTypeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCTypeSet function.
96:                      Operation is not atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_CRCTypeSet_Default( DMA_MODULE_ID index , DMA_CRC_TYPE CRCType )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     regs->DCRCCON.CRCTYP = CRCType;
00000030  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCTYPE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcpolynomiallength_default.h  --
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCPolynomialLength_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCPolynomialLength
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCPolynomialLength
16:                          PLIB_DMA_CRCPolynomialLengthSet
17:                          PLIB_DMA_CRCPolynomialLengthGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCPOLYNOMIALLENGTH_DEFAULT_H
48:                  #define _DMA_CRCPOLYNOMIALLENGTH_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCPolynomialLength_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCPolynomialLength
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCPolynomialLength function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCPolynomialLength PLIB_DMA_ExistsCRCPolynomialLength
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCPolynomialLength_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCPolynomialLengthSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCPolynomialLengthSet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCPolynomialLengthSet function.
77:                      Operation is not atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_CRCPolynomialLengthSet_Default( DMA_MODULE_ID index , uint8_t polyLength )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      regs->DCRCCON.PLEN = polyLength;
00000048  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCPolynomialLengthGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCPolynomialLengthGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCPolynomialLengthGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE uint8_t DMA_CRCPolynomialLengthGet_Default( DMA_MODULE_ID index )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     return (uint8_t)regs->DCRCCON.PLEN;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCPOLYNOMIALLENGTH_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcdata_default.h  --------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCData_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCData
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCData
16:                          PLIB_DMA_CRCDataRead
17:                          PLIB_DMA_CRCDataWrite
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCDATA_DEFAULT_H
48:                  #define _DMA_CRCDATA_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCData_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCData
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCData function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCData PLIB_DMA_ExistsCRCData
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCData_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCDataRead_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCDataRead
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCDataRead function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint32_t DMA_CRCDataRead_Default( DMA_MODULE_ID index )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      return (uint32_t)regs->DCRCDATA;
00000000  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCDataWrite_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCDataWrite
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCDataWrite function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_CRCDataWrite_Default( DMA_MODULE_ID index , uint32_t DMACRCdata )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     regs->DCRCDATA = DMACRCdata;
00000088  00000000   NOP
000000A0  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCDATA_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcchannel_default.h  -----------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCChannel_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCChannel
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCChannel
16:                          PLIB_DMA_CRCChannelSelect
17:                          PLIB_DMA_CRCChannelGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCCHANNEL_DEFAULT_H
48:                  #define _DMA_CRCCHANNEL_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCChannel_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCChannel
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCChannel function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCChannel PLIB_DMA_ExistsCRCChannel
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCChannel_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCChannelSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCChannelSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCChannelSelect function.
77:                      Operation is not atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_CRCChannelSelect_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      regs->DCRCCON.CRCCH = channel;
0000001C  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCChannelGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCChannelGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCChannelGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE DMA_CHANNEL DMA_CRCChannelGet_Default( DMA_MODULE_ID index )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                 
103:                     return (DMA_CHANNEL)regs->DCRCCON.CRCCH;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CRCCHANNEL_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcbyteorder_default.h  ---------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCByteOrder_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCByteOrder
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCByteOrder
16:                          PLIB_DMA_CRCByteOrderSelect
17:                          PLIB_DMA_CRCByteOrderGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CRCBYTEORDER_DEFAULT_H
48:                  #define _DMA_CRCBYTEORDER_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsCRCByteOrder_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsCRCByteOrder
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCByteOrder function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsCRCByteOrder PLIB_DMA_ExistsCRCByteOrder
63:                  PLIB_TEMPLATE bool DMA_ExistsCRCByteOrder_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_CRCByteOrderSelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_CRCByteOrderSelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_CRCByteOrderSelect function.
77:                      Operation is not atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_CRCByteOrderSelect_Default( DMA_MODULE_ID index , DMA_CRC_BYTE_ORDER byteOrder )
81:                  {
82:                      volatile dma_register_t *regs = (dma_register_t *)index;
83:                  
84:                      regs->DCRCCON.BYTO = byteOrder;
00000064  00000000   NOP
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_CRCByteOrderGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_CRCByteOrderGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_CRCByteOrderGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE DMA_CRC_BYTE_ORDER DMA_CRCByteOrderGet_Default( DMA_MODULE_ID index )
100:                 {
101:                     volatile dma_register_t *regs = (dma_register_t *)index;
102:                     return (DMA_CRC_BYTE_ORDER) regs->DCRCCON.BYTO;
103:                 }
104:                 
105:                 
106:                 #endif /*_DMA_CRCBYTEORDER_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcbitorder_default.h  ----------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCBitOrder_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCBitOrder
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCBitOrder
16:                          PLIB_DMA_CRCBitOrderSelect
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CRCBITORDER_DEFAULT_H
47:                  #define _DMA_CRCBITORDER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsCRCBitOrder_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsCRCBitOrder
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCBitOrder function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsCRCBitOrder PLIB_DMA_ExistsCRCBitOrder
62:                  PLIB_TEMPLATE bool DMA_ExistsCRCBitOrder_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_CRCBitOrderSelect_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_CRCBitOrderSelect
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_CRCBitOrderSelect function.
76:                      Operation is not atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_CRCBitOrderSelect_Default( DMA_MODULE_ID index , DMA_CRC_BIT_ORDER bitOrder )
80:                  {
81:                      volatile dma_register_t *regs = (dma_register_t *)index;
82:                  
83:                      regs->DCRCCON.BITO = bitOrder;
00000054  00000000   NOP
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_CRCBITORDER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crcappendmode_default.h  --------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_CRCAppendMode_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : CRCAppendMode
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRCAppendMode
16:                          PLIB_DMA_CRCAppendModeEnable
17:                          PLIB_DMA_CRCAppendModeDisable
18:                          PLIB_DMA_CRCAppendModeIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CRCAPPENDMODE_DEFAULT_H
49:                  #define _DMA_CRCAPPENDMODE_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsCRCAppendMode_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsCRCAppendMode
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsCRCAppendMode function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsCRCAppendMode PLIB_DMA_ExistsCRCAppendMode
64:                  PLIB_TEMPLATE bool DMA_ExistsCRCAppendMode_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_CRCAppendModeEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_CRCAppendModeEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_CRCAppendModeEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_CRCAppendModeEnable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DCRCCONSET = _DCRCCON_CRCAPP_MASK;
000000C4  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_CRCAppendModeDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_CRCAppendModeDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_CRCAppendModeDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_CRCAppendModeDisable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DCRCCONCLR = _DCRCCON_CRCAPP_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_CRCAppendModeIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_CRCAppendModeIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_CRCAppendModeIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_CRCAppendModeIsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DCRCCON.CRCAPP;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CRCAPPENDMODE_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_crc_default.h  ------------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_Crc_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Crc
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsCRC
16:                          PLIB_DMA_CRCEnable
17:                          PLIB_DMA_CRCDisable
18:                          PLIB_DMA_CRCIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CRC_DEFAULT_H
49:                  #define _DMA_CRC_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsCRC_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsCRC
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsCRC function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsCRC PLIB_DMA_ExistsCRC
64:                  PLIB_TEMPLATE bool DMA_ExistsCRC_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_CRCEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_CRCEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_CRCEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_CRCEnable_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DCRCCONSET = _DCRCCON_CRCEN_MASK;
9D001978  24030080   ADDIU V1, ZERO, 128
9D00197C  3C02BF88   LUI V0, -16504
9D001980  AC433038   SW V1, 12344(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_CRCDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_CRCDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_CRCDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_CRCDisable_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DCRCCONCLR = _DCRCCON_CRCEN_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_CRCIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_CRCIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_CRCIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_CRCIsEnabled_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return (bool)regs->DCRCCON.CRCEN;
124:                 }
125:                 
126:                 #endif /*_DMA_CRC_DEFAULT_H*/
127:                 
128:                 /******************************************************************************
129:                  End of File
130:                 */
131:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxtrigger_default.h  ------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXTrigger_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXTrigger
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXTrigger
16:                          PLIB_DMA_ChannelXTriggerEnable
17:                          PLIB_DMA_ChannelXTriggerIsEnabled
18:                          PLIB_DMA_ChannelXTriggerDisable
19:                          PLIB_DMA_ChannelXTriggerSourceNumberGet
20:                  
21:                  *******************************************************************************/
22:                  
23:                  //DOM-IGNORE-BEGIN
24:                  /*******************************************************************************
25:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
26:                  
27:                  Microchip licenses to you the right to use, modify, copy and distribute
28:                  Software only when embedded on a Microchip microcontroller or digital signal
29:                  controller that is integrated into your product or third party product
30:                  (pursuant to the sublicense terms in the accompanying license agreement).
31:                  
32:                  You should refer to the license agreement accompanying this Software for
33:                  additional information regarding your rights and obligations.
34:                  
35:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
36:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
37:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
38:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
39:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
40:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
41:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
42:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
43:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
44:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
45:                  *******************************************************************************/
46:                  
47:                  //DOM-IGNORE-END
48:                  
49:                  #ifndef _DMA_CHANNELXTRIGGER_DEFAULT_H
50:                  #define _DMA_CHANNELXTRIGGER_DEFAULT_H
51:                  
52:                  #include "dma_Registers.h"
53:                  
54:                  //******************************************************************************
55:                  /* Function :  DMA_ExistsChannelXTrigger_Default
56:                  
57:                    Summary:
58:                      Implements Default variant of PLIB_DMA_ExistsChannelXTrigger
59:                  
60:                    Description:
61:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXTrigger function.
62:                      Operation is atomic.
63:                  */
64:                  
65:                  #define PLIB_DMA_ExistsChannelXTrigger PLIB_DMA_ExistsChannelXTrigger
66:                  PLIB_TEMPLATE bool DMA_ExistsChannelXTrigger_Default( DMA_MODULE_ID index )
67:                  {
68:                      return true;
69:                  }
70:                  
71:                  
72:                  //******************************************************************************
73:                  /* Function :  DMA_ChannelXTriggerEnable_Default
74:                  
75:                    Summary:
76:                      Implements Default variant of PLIB_DMA_ChannelXTriggerEnable
77:                  
78:                    Description:
79:                      This template implements the Default variant of the PLIB_DMA_ChannelXTriggerEnable function.
80:                      Operation is atomic.
81:                  */
82:                  
83:                  PLIB_TEMPLATE void DMA_ChannelXTriggerEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
84:                  {
85:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D0018A4  00041180   SLL V0, A0, 6
9D0018A8  00041A00   SLL V1, A0, 8
9D0018AC  00621023   SUBU V0, V1, V0
9D0018B0  3C03BF88   LUI V1, -16504
9D0018B4  24633060   ADDIU V1, V1, 12384
9D0018B8  00431021   ADDU V0, V0, V1
86:                  
87:                      switch (trigger) {
88:                      case DMA_CHANNEL_TRIGGER_TRANSFER_START:
89:                  	   regs->DCHxECONSET = _DCH0ECON_SIRQEN_MASK;
9D0019D8  24020010   ADDIU V0, ZERO, 16
9D0019DC  AC820018   SW V0, 24(A0)
90:                  	   break;
91:                      case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
92:                  	   regs->DCHxECONSET = _DCH0ECON_AIRQEN_MASK;
00000060  00000000   NOP
93:                  	   break;
94:                      case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
95:                  	   regs->DCHxECONSET = _DCH0ECON_PATEN_MASK;
9D0018BC  24030020   ADDIU V1, ZERO, 32
9D0018C0  AC430018   SW V1, 24(V0)
96:                  	   break;
97:                      }
98:                  }
99:                  
100:                 
101:                 //******************************************************************************
102:                 /* Function :  DMA_ChannelXTriggerIsEnabled_Default
103:                 
104:                   Summary:
105:                     Implements Default variant of PLIB_DMA_ChannelXTriggerIsEnabled
106:                 
107:                   Description:
108:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerIsEnabled function.
109:                     Operation is atomic.
110:                 */
111:                 
112:                 PLIB_TEMPLATE bool DMA_ChannelXTriggerIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
113:                 {
114:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
115:                 
116:                     switch (trigger) {
117:                     case DMA_CHANNEL_TRIGGER_TRANSFER_START:
118:                 	   return (bool)regs->DCHxECON.SIRQEN;
119:                     case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
120:                 	   return (bool)regs->DCHxECON.AIRQEN;
121:                     case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
122:                 	   return (bool)regs->DCHxECON.PATEN;
123:                     }
124:                     return false;
125:                 }
126:                 
127:                 
128:                 //******************************************************************************
129:                 /* Function :  DMA_ChannelXTriggerDisable_Default
130:                 
131:                   Summary:
132:                     Implements Default variant of PLIB_DMA_ChannelXTriggerDisable
133:                 
134:                   Description:
135:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerDisable function.
136:                 */
137:                 
138:                 PLIB_TEMPLATE void DMA_ChannelXTriggerDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_TRIGGER_TYPE trigger )
139:                 {
140:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
141:                 
142:                     switch (trigger) {
143:                     case DMA_CHANNEL_TRIGGER_TRANSFER_START:
144:                 	   regs->DCHxECONCLR = _DCH0ECON_SIRQEN_MASK;
145:                 	   break;
146:                     case DMA_CHANNEL_TRIGGER_TRANSFER_ABORT:
147:                 	   regs->DCHxECONCLR = _DCH0ECON_AIRQEN_MASK;
148:                 	   break;
149:                     case DMA_CHANNEL_TRIGGER_PATTERN_MATCH_ABORT:
150:                 	   regs->DCHxECONCLR = _DCH0ECON_PATEN_MASK;
151:                 	   break;
152:                     }
153:                 }
154:                 
155:                 
156:                 //******************************************************************************
157:                 /* Function :  DMA_ChannelXTriggerSourceNumberGet_Default
158:                 
159:                   Summary:
160:                     Implements Default variant of PLIB_DMA_ChannelXTriggerSourceNumberGet
161:                 
162:                   Description:
163:                     This template implements the Default variant of the PLIB_DMA_ChannelXTriggerSourceNumberGet function.
164:                 */
165:                 
166:                 PLIB_TEMPLATE DMA_CHANNEL_INT_SOURCE DMA_ChannelXTriggerSourceNumberGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel)
167:                 {
168:                 	return (DMA_CHANNEL_INT_SOURCE)(DMA_CHANNEL_0_INT_SOURCE + channel);
9D002624  24A3003C   ADDIU V1, A1, 60
00000000  00000000   NOP
169:                 }
170:                 
171:                 
172:                 #endif /*_DMA_CHANNELXTRIGGER_DEFAULT_H*/
173:                 
174:                 /******************************************************************************
175:                  End of File
176:                 */
177:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxstartirq_default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXStartIRQ_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXStartIRQ
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXStartIRQ
16:                          PLIB_DMA_ChannelXStartIRQSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CHANNELXSTARTIRQ_DEFAULT_H
47:                  #define _DMA_CHANNELXSTARTIRQ_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsChannelXStartIRQ_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsChannelXStartIRQ
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXStartIRQ function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsChannelXStartIRQ PLIB_DMA_ExistsChannelXStartIRQ
62:                  PLIB_TEMPLATE bool DMA_ExistsChannelXStartIRQ_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_ChannelXStartIRQSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_ChannelXStartIRQSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_ChannelXStartIRQSet function.
76:                      Operation is not atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_ChannelXStartIRQSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_TRIGGER_SOURCE IRQnum )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D0019BC  00042200   SLL A0, A0, 8
9D0019C0  00822023   SUBU A0, A0, V0
9D0019C4  3C02BF88   LUI V0, -16504
9D0019C8  24423060   ADDIU V0, V0, 12384
9D0019CC  00822021   ADDU A0, A0, V0
82:                  
83:                      regs->DCHxECON.CHSIRQ = IRQnum;
9D0019D0  30C600FF   ANDI A2, A2, 255
9D0019D4  A0860011   SB A2, 17(A0)
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_CHANNELXSTARTIRQ_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxsourcestartaddress_default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXSourceStartAddress_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXSourceStartAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXSourceStartAddress
16:                          PLIB_DMA_ChannelXSourceStartAddressGet
17:                          PLIB_DMA_ChannelXSourceStartAddressSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H
48:                  #define _DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H
49:                  
50:                  #include <sys/kmem.h>
51:                  #include "dma_Registers.h"
52:                  
53:                  #define ConvertToPhysicalAddress(a) ((uint32_t)KVA_TO_PA(a))
54:                  #define ConvertToVirtualAddress(a)  PA_TO_KVA1(a)
55:                  
56:                  //******************************************************************************
57:                  /* Function :  DMA_ExistsChannelXSourceStartAddress_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_DMA_ExistsChannelXSourceStartAddress
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXSourceStartAddress function.
64:                  */
65:                  
66:                  #define PLIB_DMA_ExistsChannelXSourceStartAddress PLIB_DMA_ExistsChannelXSourceStartAddress
67:                  PLIB_TEMPLATE bool DMA_ExistsChannelXSourceStartAddress_Default( DMA_MODULE_ID index )
68:                  {
69:                      return true;
70:                  }
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  DMA_ChannelXSourceStartAddressGet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_DMA_ChannelXSourceStartAddressGet
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceStartAddressGet function.
81:                      Operation is atomic.
82:                  */
83:                  
84:                  PLIB_TEMPLATE uint32_t DMA_ChannelXSourceStartAddressGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
85:                  {
86:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
87:                      uint32_t addr = regs->DCHxSSA;
88:                  
89:                      /* Check if the address lies in the KSEG2 for MZ devices */
90:                      if ((addr & 0x20000000) == 0x20000000) {
91:                  	if((addr >> 28)== 0x2) {
92:                  	    // EBI Address translation
93:                  	    addr = (addr | 0xc0000000) & 0xcFFFFFFF;
94:                  	} else if ((addr >> 28)== 0x3) {
95:                  	    //SQI Address translation
96:                  	    addr = (addr | 0xD0000000) & 0xDFFFFFFF;
97:                          }
98:                      } else {
99:                  	addr = (uint32_t)ConvertToVirtualAddress(addr);
100:                     }
101:                 
102:                     return addr;
103:                 }
104:                 
105:                 
106:                 //******************************************************************************
107:                 /* Function :  DMA_ChannelXSourceStartAddressSet_Default
108:                 
109:                   Summary:
110:                     Implements Default variant of PLIB_DMA_ChannelXSourceStartAddressSet
111:                 
112:                   Description:
113:                     This template implements the Default variant of the PLIB_DMA_ChannelXSourceStartAddressSet function.
114:                     Operation is atomic.
115:                 */
116:                 
117:                 PLIB_TEMPLATE void DMA_ChannelXSourceStartAddressSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint32_t sourceStartAddress )
118:                 {
119:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D001A08  00044180   SLL T0, A0, 6
9D001A0C  00041200   SLL V0, A0, 8
9D001A10  00481023   SUBU V0, V0, T0
9D001A14  3C08BF88   LUI T0, -16504
9D001A18  25083060   ADDIU T0, T0, 12384
9D001A1C  00481021   ADDU V0, V0, T0
00000010  00000000   NOP
120:                 
121:                     /* Check if the address lies in the KSEG2 for MZ devices */
122:                     if ((sourceStartAddress >> 29) == 0x6) {
9D001A20  00052742   SRL A0, A1, 29
9D001A24  24080006   ADDIU T0, ZERO, 6
9D001A28  1488000E   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A2C  00A01821   ADDU V1, A1, ZERO
00000028  00000000   NOP
123:                 	if ((sourceStartAddress >> 28)== 0xc) {
9D001A30  00052702   SRL A0, A1, 28
9D001A34  2408000C   ADDIU T0, ZERO, 12
9D001A38  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A3C  2408000D   ADDIU T0, ZERO, 13
00000038  00000000   NOP
124:                 	    // EBI Address translation
125:                             sourceStartAddress = ((sourceStartAddress | 0x20000000) & 0x2FFFFFFF);
9D001A40  7CA5D800   EXT A1, A1, 0, 28
9D001A44  3C032000   LUI V1, 8192
9D001A48  0B4006A8   J 0x9D001AA0
9D001A4C  00A31825   OR V1, A1, V1
00000048  00000000   NOP
126:                 	} else if((sourceStartAddress >> 28)== 0xD) {
9D001A50  14880013   BNE A0, T0, 0x9D001AA0
9D001A54  7CA5D800   EXT A1, A1, 0, 28
00000058  00000000   NOP
127:                 	    //SQI Address translation
128:                             sourceStartAddress = ((sourceStartAddress | 0x30000000) & 0x3FFFFFFF);
9D001A58  3C033000   LUI V1, 12288
9D001A5C  0B4006A8   J 0x9D001AA0
9D001A60  00A31825   OR V1, A1, V1
00000060  00000000   NOP
129:                         }
130:                     } else if ((sourceStartAddress >> 29) == 0x7) {
9D001A64  24080007   ADDIU T0, ZERO, 7
9D001A68  5488000D   BNEL A0, T0, 0x9D001AA0
9D001A6C  7CA3E000   EXT V1, A1, 0, 29
0000006C  00000000   NOP
131:                 	if ((sourceStartAddress >> 28)== 0xE) {
9D001A70  00052702   SRL A0, A1, 28
9D001A74  2408000E   ADDIU T0, ZERO, 14
9D001A78  14880005   BNE A0, T0, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXSourceStartAddressSet
9D001A7C  2408000F   ADDIU T0, ZERO, 15
00000078  00000000   NOP
132:                 	    // EBI Address translation
133:                             sourceStartAddress = ((sourceStartAddress | 0x20000000) & 0x2FFFFFFF);
9D001A80  7CA5D800   EXT A1, A1, 0, 28
9D001A84  3C032000   LUI V1, 8192
9D001A88  0B4006A8   J 0x9D001AA0
9D001A8C  00A31825   OR V1, A1, V1
00000088  00000000   NOP
134:                 	} else if ((sourceStartAddress >> 28)== 0xF) {
9D001A90  14880003   BNE A0, T0, 0x9D001AA0
9D001A94  7CA5D800   EXT A1, A1, 0, 28
00000098  00000000   NOP
135:                 	    //SQI Address translation
136:                             sourceStartAddress = ((sourceStartAddress | 0x30000000) & 0x3FFFFFFF);
9D001A98  3C033000   LUI V1, 12288
9D001A9C  00A31825   OR V1, A1, V1
000000A0  00000000   NOP
137:                         }
138:                     } else {
139:                         /*For KSEG0 and KSEG1, The translation is done by KVA_TO_PA */
140:                         sourceStartAddress = ConvertToPhysicalAddress(sourceStartAddress);
141:                     }
142:                 
143:                     regs->DCHxSSA = sourceStartAddress;
9D001AA0  AC430030   SW V1, 48(V0)
9D001AA4  30C6FFFF   ANDI A2, A2, -1
000000A8  00000000   NOP
144:                 }
145:                 
146:                 
147:                 #endif /*_DMA_CHANNELXSOURCESTARTADDRESS_DEFAULT_H*/
148:                 
149:                 /******************************************************************************
150:                  End of File
151:                 */
152:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxsourcesize_default.h  ---
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXSourceSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXSourceSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXSourceSize
16:                          PLIB_DMA_ChannelXSourceSizeGet
17:                          PLIB_DMA_ChannelXSourceSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXSOURCESIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXSOURCESIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXSourceSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXSourceSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXSourceSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXSourceSize PLIB_DMA_ExistsChannelXSourceSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXSourceSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXSourceSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXSourceSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXSourceSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxSSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXSourceSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXSourceSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourceSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXSourceSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t sourceSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxSSIZ = sourceSize;
9D001AA8  AC460050   SW A2, 80(V0)
000000B0  00000000   NOP
104:                 }
105:                 
106:                 #endif /*_DMA_CHANNELXSOURCESIZE_DEFAULT_H*/
107:                 
108:                 /******************************************************************************
109:                  End of File
110:                 */
111:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxsourcepointer_default.h  
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXSourcePointer_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXSourcePointer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXSourcePointer
16:                          PLIB_DMA_ChannelXSourcePointerGet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CHANNELXSOURCEPOINTER_DEFAULT_H
47:                  #define _DMA_CHANNELXSOURCEPOINTER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsChannelXSourcePointer_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsChannelXSourcePointer
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXSourcePointer function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsChannelXSourcePointer PLIB_DMA_ExistsChannelXSourcePointer
62:                  PLIB_TEMPLATE bool DMA_ExistsChannelXSourcePointer_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_ChannelXSourcePointerGet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_ChannelXSourcePointerGet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_ChannelXSourcePointerGet function.
76:                      Operation is atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE uint16_t DMA_ChannelXSourcePointerGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
82:                  
83:                      return (uint16_t)regs->DCHxSPTR;
00000028  00000000   NOP
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_CHANNELXSOURCEPOINTER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxpriority_default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXPriority_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXPriority
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXPriority
16:                          PLIB_DMA_ChannelXPrioritySelect
17:                          PLIB_DMA_ChannelXPriorityGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXPRIORITY_DEFAULT_H
48:                  #define _DMA_CHANNELXPRIORITY_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXPriority_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXPriority
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXPriority function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXPriority PLIB_DMA_ExistsChannelXPriority
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXPriority_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXPrioritySelect_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXPrioritySelect
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXPrioritySelect function.
77:                      Operation is not atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXPrioritySelect_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_CHANNEL_PRIORITY channelPriority )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCON.CHPRI = channelPriority;
9D00329C  94A70000   LHU A3, 0(A1)
9D0032A0  7CC70804   INS A3, A2, 0, 2
9D0032A4  A4A70000   SH A3, 0(A1)
9D0032A8  24C60001   ADDIU A2, A2, 1
9D0032AC  24A500C0   ADDIU A1, A1, 192
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXPriorityGet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXPriorityGet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXPriorityGet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE DMA_CHANNEL_PRIORITY DMA_ChannelXPriorityGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     return (DMA_CHANNEL_PRIORITY)regs->DCHxCON.CHPRI;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXPRIORITY_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxpatterndata_default.h  --
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXPatternData_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXPatternData
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXPatternData
16:                          PLIB_DMA_ChannelXPatternDataGet
17:                          PLIB_DMA_ChannelXPatternDataSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013-2014 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXPATTERNDATA_DEFAULT_H
48:                  #define _DMA_CHANNELXPATTERNDATA_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXPatternData_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXPatternData
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXPatternData function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXPatternData PLIB_DMA_ExistsChannelXPatternData
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXPatternData_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXPatternDataGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXPatternDataGet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXPatternDataGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXPatternDataGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxDAT;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXPatternDataSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXPatternDataSet 
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXPatternDataSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXPatternDataSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t patternData )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000014  00000000   NOP
102:                 
103:                     regs->DCHxDAT = patternData;
0000002C  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXPATTERNDATA_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxintsourceflag_default.h  
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXINTSourceFlag_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXINTSourceFlag
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXINTSourceFlag
16:                          PLIB_DMA_ChannelXINTSourceFlagGet
17:                          PLIB_DMA_ChannelXINTSourceFlagSet
18:                          PLIB_DMA_ChannelXINTSourceFlagClear
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H
49:                  #define _DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXINTSourceFlag_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXINTSourceFlag
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXINTSourceFlag function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXINTSourceFlag PLIB_DMA_ExistsChannelXINTSourceFlag
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXINTSourceFlag_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXINTSourceFlagGet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagGet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagGet function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE bool DMA_ChannelXINTSourceFlagGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D002628  00051180   SLL V0, A1, 6
9D00262C  00052200   SLL A0, A1, 8
9D002630  00821023   SUBU V0, A0, V0
9D002634  3C04BF88   LUI A0, -16504
9D002638  24843060   ADDIU A0, A0, 12384
9D00263C  00441021   ADDU V0, V0, A0
00000030  00000000   NOP
84:                      bool intSrcFlag = false;
85:                  
86:                      switch (dmaINTSource) {
87:                      case DMA_INT_ADDRESS_ERROR:
88:                  	intSrcFlag = regs->DCHxINT.CHERIF;
00000044  00000000   NOP
00000070  00000000   NOP
89:                  	break;
90:                  
91:                      case DMA_INT_TRANSFER_ABORT:
92:                  	intSrcFlag = regs->DCHxINT.CHTAIF;
9D0026A8  8C440020   LW A0, 32(V0)
9D0026AC  7C840040   EXT A0, A0, 1, 1
93:                  	break;
94:                  
95:                      case DMA_INT_CELL_TRANSFER_COMPLETE:
96:                  	intSrcFlag = regs->DCHxINT.CHCCIF;
97:                  	break;
98:                  
99:                      case DMA_INT_BLOCK_TRANSFER_COMPLETE:
100:                 	intSrcFlag = regs->DCHxINT.CHBCIF;
9D002640  8C440020   LW A0, 32(V0)
9D002644  7C8400C0   EXT A0, A0, 3, 1
101:                 	break;
102:                 
103:                     case DMA_INT_DESTINATION_HALF_FULL:
104:                 	intSrcFlag = regs->DCHxINT.CHDHIF;
105:                 	break;
106:                 
107:                     case DMA_INT_DESTINATION_DONE:
108:                 	intSrcFlag = regs->DCHxINT.CHDDIF;
109:                 	break;
110:                 
111:                     case DMA_INT_SOURCE_HALF_EMPTY:
112:                 	intSrcFlag = regs->DCHxINT.CHSHIF;
113:                 	break;
114:                 
115:                     case DMA_INT_SOURCE_DONE:
116:                 	intSrcFlag = regs->DCHxINT.CHSDIF;
117:                 	break;
118:                     }
119:                 
120:                     return intSrcFlag;
121:                 }
122:                 
123:                 
124:                 //******************************************************************************
125:                 /* Function :  DMA_ChannelXINTSourceFlagSet_Default
126:                 
127:                   Summary:
128:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagSet
129:                 
130:                   Description:
131:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagSet function.
132:                     Operation is atomic.
133:                 */
134:                 
135:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceFlagSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
136:                 {
137:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
138:                 
139:                     switch (dmaINTSource) {
140:                     case DMA_INT_ADDRESS_ERROR:
141:                 	regs->DCHxINTSET = _DCH0INT_CHERIF_MASK;
142:                 	break;
143:                 
144:                     case DMA_INT_TRANSFER_ABORT:
145:                 	regs->DCHxINTSET = _DCH0INT_CHTAIF_MASK;
146:                 	break;
147:                 
148:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
149:                 	regs->DCHxINTSET = _DCH0INT_CHCCIF_MASK;
150:                 	break;
151:                 
152:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
153:                 	regs->DCHxINTSET = _DCH0INT_CHBCIF_MASK;
154:                 	break;
155:                 
156:                     case DMA_INT_DESTINATION_HALF_FULL:
157:                 	regs->DCHxINTSET = _DCH0INT_CHDHIF_MASK;
158:                 	break;
159:                 
160:                     case DMA_INT_DESTINATION_DONE:
161:                 	regs->DCHxINTSET = _DCH0INT_CHDDIF_MASK;
162:                 	break;
163:                 
164:                     case DMA_INT_SOURCE_HALF_EMPTY:
165:                 	regs->DCHxINTSET = _DCH0INT_CHSHIF_MASK;
166:                 	break;
167:                 
168:                     case DMA_INT_SOURCE_DONE:
169:                 	regs->DCHxINTSET = _DCH0INT_CHSDIF_MASK;
170:                 	break;
171:                     }
172:                 }
173:                 
174:                 //******************************************************************************
175:                 /* Function :  DMA_ChannelXINTSourceFlagClear_Default
176:                 
177:                   Summary:
178:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceFlagClear
179:                 
180:                   Description:
181:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceFlagClear function.
182:                     Operation is atomic.
183:                 */
184:                 
185:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceFlagClear_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
186:                 {
187:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
188:                 
189:                     switch (dmaINTSource) {
190:                     case DMA_INT_ADDRESS_ERROR:
191:                 	regs->DCHxINTCLR = _DCH0INT_CHERIF_MASK;
00000040  00000000   NOP
00000054  00000000   NOP
00000080  00000000   NOP
192:                 	break;
193:                 
194:                     case DMA_INT_TRANSFER_ABORT:
195:                 	regs->DCHxINTCLR = _DCH0INT_CHTAIF_MASK;
9D0026B8  AC440024   SW A0, 36(V0)
196:                 	break;
197:                 
198:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
199:                 	regs->DCHxINTCLR = _DCH0INT_CHCCIF_MASK;
200:                 	break;
201:                 
202:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
203:                 	regs->DCHxINTCLR = _DCH0INT_CHBCIF_MASK;
9D002650  AC440024   SW A0, 36(V0)
204:                 	break;
205:                 
206:                     case DMA_INT_DESTINATION_HALF_FULL:
207:                 	regs->DCHxINTCLR = _DCH0INT_CHDHIF_MASK;
208:                 	break;
209:                 
210:                     case DMA_INT_DESTINATION_DONE:
211:                 	regs->DCHxINTCLR = _DCH0INT_CHDDIF_MASK;
212:                 	break;
213:                 
214:                     case DMA_INT_SOURCE_HALF_EMPTY:
215:                 	regs->DCHxINTCLR = _DCH0INT_CHSHIF_MASK;
216:                 	break;
217:                 
218:                     case DMA_INT_SOURCE_DONE:
219:                 	regs->DCHxINTCLR = _DCH0INT_CHSDIF_MASK;
220:                 	break;
221:                     }
222:                 }
223:                 
224:                 #endif /*_DMA_CHANNELXINTSOURCEFLAG_DEFAULT_H*/
225:                 
226:                 /******************************************************************************
227:                  End of File
228:                 */
229:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxintsource_default.h  ----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXINTSource_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXINTSource
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXINTSource
16:                          PLIB_DMA_ChannelXINTSourceEnable
17:                          PLIB_DMA_ChannelXINTSourceDisable
18:                          PLIB_DMA_ChannelXINTSourceIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXINTSOURCE_DEFAULT_H
49:                  #define _DMA_CHANNELXINTSOURCE_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXINTSource_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXINTSource
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXINTSource function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXINTSource PLIB_DMA_ExistsChannelXINTSource
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXINTSource_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXINTSourceEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXINTSourceEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXINTSourceEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D001990  00042200   SLL A0, A0, 8
9D001994  00822023   SUBU A0, A0, V0
9D001998  3C02BF88   LUI V0, -16504
9D00199C  24423060   ADDIU V0, V0, 12384
9D0019A0  00822021   ADDU A0, A0, V0
84:                  
85:                      switch (dmaINTSource) {
86:                      case DMA_INT_ADDRESS_ERROR:
87:                  	regs->DCHxINTSET = _DCH0INT_CHERIE_MASK;
9D0019AC  3C020001   LUI V0, 1
9D0019B0  AC820028   SW V0, 40(A0)
9D0019B4  03E00008   JR RA
9D0019B8  00000000   NOP
9D0019E8  3C020001   LUI V0, 1
88:                  	break;
89:                  
90:                      case DMA_INT_TRANSFER_ABORT:
91:                  	regs->DCHxINTSET = _DCH0INT_CHTAIE_MASK;
92:                  	break;
93:                      case DMA_INT_CELL_TRANSFER_COMPLETE:
94:                  	regs->DCHxINTSET = _DCH0INT_CHCCIE_MASK;
95:                  	break;
96:                      case DMA_INT_BLOCK_TRANSFER_COMPLETE:
97:                  	regs->DCHxINTSET = _DCH0INT_CHBCIE_MASK;
9D0019A4  3C020008   LUI V0, 8
9D0019A8  AC820028   SW V0, 40(A0)
9D0019E0  3C020008   LUI V0, 8
9D0019E4  AC820028   SW V0, 40(A0)
98:                  	break;
99:                  
100:                     case DMA_INT_DESTINATION_HALF_FULL:
101:                 	regs->DCHxINTSET = _DCH0INT_CHDHIE_MASK;
102:                 	break;
103:                 
104:                     case DMA_INT_DESTINATION_DONE:
105:                 	regs->DCHxINTSET = _DCH0INT_CHDDIE_MASK;
106:                 	break;
107:                 
108:                     case DMA_INT_SOURCE_HALF_EMPTY:
109:                 	regs->DCHxINTSET = _DCH0INT_CHSHIE_MASK;
110:                 	break;
111:                 
112:                     case DMA_INT_SOURCE_DONE:
113:                 	regs->DCHxINTSET = _DCH0INT_CHSDIE_MASK;
114:                 	break;
115:                     }
116:                 }
117:                 
118:                 
119:                 //******************************************************************************
120:                 /* Function :  DMA_ChannelXINTSourceDisable_Default
121:                 
122:                   Summary:
123:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceDisable
124:                 
125:                   Description:
126:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceDisable function.
127:                     Operation is atomic.
128:                 */
129:                 
130:                 PLIB_TEMPLATE void DMA_ChannelXINTSourceDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
131:                 {
132:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000028  00000000   NOP
133:                 
134:                     switch (dmaINTSource) {
00000048  00000000   NOP
00000050  00000000   NOP
00000058  00000000   NOP
00000060  00000000   NOP
00000068  00000000   NOP
00000070  00000000   NOP
00000078  00000000   NOP
00000088  00000000   NOP
135:                     case DMA_INT_ADDRESS_ERROR:
136:                 	regs->DCHxINTCLR = _DCH0INT_CHERIE_MASK;
00000080  00000000   NOP
000000F0  00000000   NOP
137:                 	break;
138:                 
139:                     case DMA_INT_TRANSFER_ABORT:
140:                 	regs->DCHxINTCLR = _DCH0INT_CHTAIE_MASK;
00000074  00000000   NOP
000000FC  00000000   NOP
141:                 	break;
142:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
143:                 	regs->DCHxINTCLR = _DCH0INT_CHCCIE_MASK;
0000007C  00000000   NOP
00000108  00000000   NOP
144:                 	break;
145:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
146:                 	regs->DCHxINTCLR = _DCH0INT_CHBCIE_MASK;
0000004C  00000000   NOP
00000114  00000000   NOP
147:                 	break;
148:                 
149:                     case DMA_INT_DESTINATION_HALF_FULL:
150:                 	regs->DCHxINTCLR = _DCH0INT_CHDHIE_MASK;
0000006C  00000000   NOP
00000120  00000000   NOP
151:                 	break;
152:                 
153:                     case DMA_INT_DESTINATION_DONE:
154:                 	regs->DCHxINTCLR = _DCH0INT_CHDDIE_MASK;
00000054  00000000   NOP
0000012C  00000000   NOP
155:                 	break;
156:                 
157:                     case DMA_INT_SOURCE_HALF_EMPTY:
158:                 	regs->DCHxINTCLR = _DCH0INT_CHSHIE_MASK;
0000005C  00000000   NOP
00000138  00000000   NOP
159:                 	break;
160:                 
161:                     case DMA_INT_SOURCE_DONE:
162:                 	regs->DCHxINTCLR = _DCH0INT_CHSDIE_MASK;
00000064  00000000   NOP
00000144  00000000   NOP
163:                 	break;
164:                     }
165:                 }
166:                 
167:                 
168:                 //******************************************************************************
169:                 /* Function :  DMA_ChannelXINTSourceIsEnabled_Default
170:                 
171:                   Summary:
172:                     Implements Default variant of PLIB_DMA_ChannelXINTSourceIsEnabled
173:                 
174:                   Description:
175:                     This template implements the Default variant of the PLIB_DMA_ChannelXINTSourceIsEnabled function.
176:                     Operation is atomic.
177:                 */
178:                 
179:                 PLIB_TEMPLATE bool DMA_ChannelXINTSourceIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , DMA_INT_TYPE dmaINTSource )
180:                 {
181:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
182:                 
183:                     switch (dmaINTSource) {
184:                     case DMA_INT_ADDRESS_ERROR:
185:                 	return (bool)regs->DCHxINT.CHERIE;
186:                 
187:                     case DMA_INT_TRANSFER_ABORT:
188:                 	return (bool)regs->DCHxINT.CHTAIE;
189:                 
190:                     case DMA_INT_CELL_TRANSFER_COMPLETE:
191:                 	return (bool)regs->DCHxINT.CHCCIE;
192:                 
193:                     case DMA_INT_BLOCK_TRANSFER_COMPLETE:
194:                 	return (bool)regs->DCHxINT.CHBCIE;
195:                 
196:                     case DMA_INT_DESTINATION_HALF_FULL:
197:                 	return (bool)regs->DCHxINT.CHDHIE;
198:                 
199:                     case DMA_INT_DESTINATION_DONE:
200:                 	return (bool)regs->DCHxINT.CHDDIE;
201:                 
202:                     case DMA_INT_SOURCE_HALF_EMPTY:
203:                 	return (bool)regs->DCHxINT.CHSHIE;
204:                 
205:                     case DMA_INT_SOURCE_DONE:
206:                 	return (bool)regs->DCHxINT.CHSDIE;
207:                     }
208:                 
209:                     return (bool)false;
210:                 }
211:                 
212:                 
213:                 #endif /*_DMA_CHANNELXINTSOURCE_DEFAULT_H*/
214:                 
215:                 /******************************************************************************
216:                  End of File
217:                 */
218:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxdisabled_default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDisabled_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDisabled
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDisabled
16:                          PLIB_DMA_ChannelXDisabledEnablesEvents
17:                          PLIB_DMA_ChannelXDisabledDisablesEvents
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDISABLED_DEFAULT_H
48:                  #define _DMA_CHANNELXDISABLED_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXDisabled_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXDisabled
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDisabled function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXDisabled PLIB_DMA_ExistsChannelXDisabled
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDisabled_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXDisabledEnablesEvents_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXDisabledEnablesEvents
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXDisabledEnablesEvents function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXDisabledEnablesEvents_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCONSET = _DCH0CON_CHAED_MASK;
9D0018F8  24030040   ADDIU V1, ZERO, 64
9D0018FC  AC430008   SW V1, 8(V0)
9D001938  24030040   ADDIU V1, ZERO, 64
9D00193C  AC430008   SW V1, 8(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXDisabledDisablesEvents_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXDisabledDisablesEvents
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXDisabledDisablesEvents function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXDisabledDisablesEvents_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCONCLR = _DCH0CON_CHAED_MASK;
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXDISABLED_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxdestinationstartaddress_default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDestinationStartAddress_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDestinationStartAddress
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDestinationStartAddress
16:                          PLIB_DMA_ChannelXDestinationStartAddressGet
17:                          PLIB_DMA_ChannelXDestinationStartAddressSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H
48:                  #define _DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H
49:                  
50:                  #include <sys/kmem.h>
51:                  #include "dma_Registers.h"
52:                  
53:                  #define ConvertToPhysicalAddress(a) ((uint32_t)KVA_TO_PA(a))
54:                  #define ConvertToVirtualAddress(a)  PA_TO_KVA1(a)
55:                  
56:                  //******************************************************************************
57:                  /* Function :  DMA_ExistsChannelXDestinationStartAddress_Default
58:                  
59:                    Summary:
60:                      Implements Default variant of PLIB_DMA_ExistsChannelXDestinationStartAddress
61:                  
62:                    Description:
63:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDestinationStartAddress function.
64:                  */
65:                  
66:                  #define PLIB_DMA_ExistsChannelXDestinationStartAddress PLIB_DMA_ExistsChannelXDestinationStartAddress
67:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDestinationStartAddress_Default( DMA_MODULE_ID index )
68:                  {
69:                      return true;
70:                  }
71:                  
72:                  
73:                  //******************************************************************************
74:                  /* Function :  DMA_ChannelXDestinationStartAddressGet_Default
75:                  
76:                    Summary:
77:                      Implements Default variant of PLIB_DMA_ChannelXDestinationStartAddressGet
78:                  
79:                    Description:
80:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationStartAddressGet function.
81:                      Operation is atomic.
82:                  */
83:                  
84:                  PLIB_TEMPLATE uint32_t DMA_ChannelXDestinationStartAddressGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
85:                  {
86:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
87:                      uint32_t addr = regs->DCHxDSA;
88:                  
89:                      /* Check if the address lies in the KSEG2 for MZ devices */
90:                      if ((addr & 0x20000000) == 0x20000000) {
91:                  	if((addr >> 28)== 0x2) { // EBI Address translation
92:                  	    addr = (addr | 0xc0000000) & 0xcfffffff;
93:                  	} else if ((addr >> 28)== 0x3) { //SQI Address translation
94:                  	    addr = (addr | 0xd0000000) & 0xdfffffff;
95:                          }
96:                      } else {
97:                  	addr = (uint32_t)ConvertToVirtualAddress(addr);
98:                      }
99:                  
100:                     return addr;
101:                 }
102:                 
103:                 
104:                 //******************************************************************************
105:                 /* Function :  DMA_ChannelXDestinationStartAddressSet_Default
106:                 
107:                   Summary:
108:                     Implements Default variant of PLIB_DMA_ChannelXDestinationStartAddressSet
109:                 
110:                   Description:
111:                     This template implements the Default variant of the PLIB_DMA_ChannelXDestinationStartAddressSet function.
112:                     Operation is atomic.
113:                 */
114:                 
115:                 PLIB_TEMPLATE void DMA_ChannelXDestinationStartAddressSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint32_t destinationStartAddress )
116:                 {
117:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
118:                 
119:                     /* Check if the address lies in the KSEG2 for MZ devices */
120:                     if ((destinationStartAddress >> 29) == 0x6) {
9D001AAC  00072742   SRL A0, A3, 29
9D001AB0  24050006   ADDIU A1, ZERO, 6
9D001AB4  1485000E   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001AB8  00E01821   ADDU V1, A3, ZERO
000000B4  00000000   NOP
121:                         // EBI Address translation
122:                 	if ((destinationStartAddress >> 28)== 0xc) {
9D001ABC  00072702   SRL A0, A3, 28
9D001AC0  2405000C   ADDIU A1, ZERO, 12
9D001AC4  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001AC8  2405000D   ADDIU A1, ZERO, 13
000000C4  00000000   NOP
123:                             destinationStartAddress = ((destinationStartAddress | 0x20000000) & 0x2FFFFFFF);
9D001ACC  7CE7D800   EXT A3, A3, 0, 28
9D001AD0  3C032000   LUI V1, 8192
9D001AD4  0B4006CC   J 0x9D001B30
9D001AD8  00E31825   OR V1, A3, V1
000000D4  00000000   NOP
124:                         }
125:                 	//SQI Address translation
126:                 	else if ((destinationStartAddress >> 28)== 0xd) {
9D001ADC  14850014   BNE A0, A1, 0x9D001B30
9D001AE0  7CE7D800   EXT A3, A3, 0, 28
000000E4  00000000   NOP
127:                             destinationStartAddress = ((destinationStartAddress | 0x30000000) & 0x3FFFFFFF);
9D001AE4  3C033000   LUI V1, 12288
9D001AE8  0B4006CC   J 0x9D001B30
9D001AEC  00E31825   OR V1, A3, V1
000000EC  00000000   NOP
128:                         }
129:                     } else if ((destinationStartAddress >> 29) == 0x7) { /* Check if the address lies in the KSEG3 for MZ devices */
9D001AF0  24050007   ADDIU A1, ZERO, 7
9D001AF4  5485000E   BNEL A0, A1, 0x9D001B30
9D001AF8  7CE3E000   EXT V1, A3, 0, 29
000000F8  00000000   NOP
130:                         // EBI Address translation
131:                 	if ((destinationStartAddress >> 28)== 0xe) {
9D001AFC  00072702   SRL A0, A3, 28
9D001B00  2405000E   ADDIU A1, ZERO, 14
9D001B04  14850005   BNE A0, A1, SYS_DMA_ChannelTransferAdd::PLIB_DMA_ChannelXDestinationStartAddressSet
9D001B08  2405000F   ADDIU A1, ZERO, 15
00000104  00000000   NOP
132:                             destinationStartAddress = ((destinationStartAddress | 0x20000000) & 0x2FFFFFFF);
9D001B0C  7CE7D800   EXT A3, A3, 0, 28
9D001B10  3C032000   LUI V1, 8192
9D001B14  0B4006CC   J 0x9D001B30
9D001B18  00E31825   OR V1, A3, V1
00000114  00000000   NOP
133:                         }
134:                         //SQI Address translation
135:                 	else if ((destinationStartAddress >> 28)== 0xf) {
9D001B1C  14850004   BNE A0, A1, 0x9D001B30
9D001B20  00000000   NOP
00000124  00000000   NOP
136:                             destinationStartAddress = ((destinationStartAddress | 0x30000000) & 0x3FFFFFFF);
9D001B24  7CE7D800   EXT A3, A3, 0, 28
9D001B28  3C033000   LUI V1, 12288
9D001B2C  00E31825   OR V1, A3, V1
0000012C  00000000   NOP
137:                         }
138:                     } else {
139:                         /*For KSEG0 and KSEG1, The translation is done by KVA_TO_PA */
140:                         destinationStartAddress = ConvertToPhysicalAddress(destinationStartAddress);
141:                     }
142:                 
143:                     regs->DCHxDSA = destinationStartAddress;
9D001B30  AC430040   SW V1, 64(V0)
9D001B34  97A30010   LHU V1, 16(SP)
00000138  00000000   NOP
144:                 }
145:                 
146:                 
147:                 #endif /*_DMA_CHANNELXDESTINATIONSTARTADDRESS_DEFAULT_H*/
148:                 
149:                 /******************************************************************************
150:                  End of File
151:                 */
152:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxdestinationsize_default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDestinationSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDestinationSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDestinationSize
16:                          PLIB_DMA_ChannelXDestinationSizeGet
17:                          PLIB_DMA_ChannelXDestinationSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXDestinationSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXDestinationSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDestinationSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXDestinationSize PLIB_DMA_ExistsChannelXDestinationSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDestinationSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXDestinationSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXDestinationSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXDestinationSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxDSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXDestinationSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXDestinationSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXDestinationSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t destinationSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxDSIZ = destinationSize;
9D001B38  AC430060   SW V1, 96(V0)
9D001B3C  97A30014   LHU V1, 20(SP)
00000140  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXDESTINATIONSIZE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxdestinationpointer_default.h
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXDestinationPointer_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXDestinationPointer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXDestinationPointer
16:                          PLIB_DMA_ChannelXDestinationPointerGet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CHANNELXDESTINATIONPOINTER_DEFAULT_H
47:                  #define _DMA_CHANNELXDESTINATIONPOINTER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsChannelXDestinationPointer_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsChannelXDestinationPointer
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXDestinationPointer function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsChannelXDestinationPointer PLIB_DMA_ExistsChannelXDestinationPointer
62:                  PLIB_TEMPLATE bool DMA_ExistsChannelXDestinationPointer_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_ChannelXDestinationPointerGet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_ChannelXDestinationPointerGet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_ChannelXDestinationPointerGet function.
76:                      Operation is atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE uint16_t DMA_ChannelXDestinationPointerGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
82:                  
83:                      return (uint16_t)regs->DCHxDPTR;
00000028  00000000   NOP
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_CHANNELXDESTINATIONPOINTER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxchainenbl_default.h  ----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXChainEnbl_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXChainEnbl
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXChainEnbl
16:                          PLIB_DMA_ChannelXChainEnable
17:                          PLIB_DMA_ChannelXChainDisable
18:                          PLIB_DMA_ChannelXChainIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXCHAINENBL_DEFAULT_H
49:                  #define _DMA_CHANNELXCHAINENBL_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXChain_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXChainEnbl
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXChainEnbl function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXChainEnbl PLIB_DMA_ExistsChannelXChainEnbl
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXChainEnbl_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXChainEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXChainEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXChainEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D0018D0  00041180   SLL V0, A0, 6
9D0018D4  00041A00   SLL V1, A0, 8
9D0018D8  00621023   SUBU V0, V1, V0
9D0018DC  3C03BF88   LUI V1, -16504
9D0018E0  24633060   ADDIU V1, V1, 12384
9D0018E4  00431021   ADDU V0, V0, V1
9D001910  00041180   SLL V0, A0, 6
9D001914  00041A00   SLL V1, A0, 8
9D001918  00621023   SUBU V0, V1, V0
9D00191C  3C03BF88   LUI V1, -16504
9D001920  24633060   ADDIU V1, V1, 12384
9D001924  00431021   ADDU V0, V0, V1
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHCHN_MASK;
9D0018E8  24030020   ADDIU V1, ZERO, 32
9D0018EC  AC430008   SW V1, 8(V0)
9D001928  24030020   ADDIU V1, ZERO, 32
9D00192C  AC430008   SW V1, 8(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXChainDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXChainDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_ChannelXChainDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     regs->DCHxCONCLR = _DCH0CON_CHCHN_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_ChannelXChainIsEnabled_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_ChannelXChainIsEnabled
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_ChannelXChainIsEnabled function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_ChannelXChainIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
120:                 {
121:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
122:                 
123:                     return regs->DCHxCON.CHCHN;
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CHANNELXCHAINENBL_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxchain_default.h  --------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXChain_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXChain
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXChain
16:                          PLIB_DMA_ChannelXChainToLower
17:                          PLIB_DMA_ChannelXChainToHigher
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXCHAIN_DEFAULT_H
48:                  #define _DMA_CHANNELXCHAIN_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXChain_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXChain
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXChain function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXChain PLIB_DMA_ExistsChannelXChain
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXChain_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXChainToLower_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXChainToLower
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainToLower function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE void DMA_ChannelXChainToLower_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      regs->DCHxCONSET = _DCH0CON_CHCHNS_MASK;
9D001930  24030100   ADDIU V1, ZERO, 256
9D001934  AC430008   SW V1, 8(V0)
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXChainToHigher_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXChainToHigher
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXChainToHigher function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXChainToHigher_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCONCLR = _DCH0CON_CHCHNS_MASK;
9D0018F0  24030100   ADDIU V1, ZERO, 256
9D0018F4  AC430004   SW V1, 4(V0)
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXCHAIN_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxcellsize_default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXCellSize_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXCellSize
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXCellSize
16:                          PLIB_DMA_ChannelXCellSizeGet
17:                          PLIB_DMA_ChannelXCellSizeSet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DMA_CHANNELXCELLSIZE_DEFAULT_H
48:                  #define _DMA_CHANNELXCELLSIZE_DEFAULT_H
49:                  
50:                  #include "dma_Registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  DMA_ExistsChannelXCellSize_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_DMA_ExistsChannelXCellSize
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXCellSize function.
60:                  */
61:                  
62:                  #define PLIB_DMA_ExistsChannelXCellSize PLIB_DMA_ExistsChannelXCellSize
63:                  PLIB_TEMPLATE bool DMA_ExistsChannelXCellSize_Default( DMA_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DMA_ChannelXCellSizeGet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DMA_ChannelXCellSizeGet
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DMA_ChannelXCellSizeGet function.
77:                      Operation is atomic.
78:                  */
79:                  
80:                  PLIB_TEMPLATE uint16_t DMA_ChannelXCellSizeGet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
81:                  {
82:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
83:                  
84:                      return (uint16_t)regs->DCHxCSIZ;
85:                  }
86:                  
87:                  
88:                  //******************************************************************************
89:                  /* Function :  DMA_ChannelXCellSizeSet_Default
90:                  
91:                    Summary:
92:                      Implements Default variant of PLIB_DMA_ChannelXCellSizeSet
93:                  
94:                    Description:
95:                      This template implements the Default variant of the PLIB_DMA_ChannelXCellSizeSet function.
96:                      Operation is atomic.
97:                  */
98:                  
99:                  PLIB_TEMPLATE void DMA_ChannelXCellSizeSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel , uint16_t CellSize )
100:                 {
101:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
102:                 
103:                     regs->DCHxCSIZ = CellSize;
9D001B40  AC430090   SW V1, 144(V0)
00000148  00000000   NOP
104:                 }
105:                 
106:                 
107:                 #endif /*_DMA_CHANNELXCELLSIZE_DEFAULT_H*/
108:                 
109:                 /******************************************************************************
110:                  End of File
111:                 */
112:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxbusy_default.h  ---------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXBusy_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXBusy
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXBusy
16:                          PLIB_DMA_ChannelXBusyActiveSet
17:                          PLIB_DMA_ChannelXBusyInActiveSet
18:                          PLIB_DMA_ChannelXBusyIsBusy
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXBUSY_DEFAULT_H
49:                  #define _DMA_CHANNELXBUSY_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXBusy_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXBusy
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXBusy function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXBusy PLIB_DMA_ExistsChannelXBusy
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXBusy_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXBusyActiveSet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXBusyActiveSet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXBusyActiveSet function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXBusyActiveSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHBUSY_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXBusyInActiveSet_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXBusyInActiveSet
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXBusyInActiveSet function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_ChannelXBusyInActiveSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     regs->DCHxCONCLR = _DCH0CON_CHBUSY_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_ChannelXBusyIsBusy_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_ChannelXBusyIsBusy
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_ChannelXBusyIsBusy function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_ChannelXBusyIsBusy_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
120:                 {
121:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
122:                 
123:                     return (bool)regs->DCHxCON.CHBUSY;
00000028  00000000   NOP
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CHANNELXBUSY_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxauto_default.h  ---------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXAuto_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXAuto
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXAuto
16:                          PLIB_DMA_ChannelXAutoEnable
17:                          PLIB_DMA_ChannelXAutoDisable
18:                          PLIB_DMA_ChannelXAutoIsEnabled
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELXAUTO_DEFAULT_H
49:                  #define _DMA_CHANNELXAUTO_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelXAuto_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelXAuto
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXAuto function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelXAuto PLIB_DMA_ExistsChannelXAuto
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelXAuto_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXAutoEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXAutoEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXAutoEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXAutoEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
9D00194C  00041180   SLL V0, A0, 6
9D001950  00041A00   SLL V1, A0, 8
9D001954  00621023   SUBU V0, V1, V0
9D001958  3C03BF88   LUI V1, -16504
9D00195C  24633060   ADDIU V1, V1, 12384
9D001960  00431021   ADDU V0, V0, V1
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHAEN_MASK;
9D001964  24030010   ADDIU V1, ZERO, 16
9D001968  AC430008   SW V1, 8(V0)
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXAutoDisable_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXAutoDisable
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXAutoDisable function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_ChannelXAutoDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     regs->DCHxCONCLR = _DCH0CON_CHAEN_MASK;
105:                 }
106:                 
107:                 //******************************************************************************
108:                 /* Function :  DMA_ChannelXAutoIsEnabled_Default
109:                 
110:                   Summary:
111:                     Implements Default variant of PLIB_DMA_ChannelXAutoIsEnabled
112:                 
113:                   Description:
114:                     This template implements the Default variant of the PLIB_DMA_ChannelXAutoIsEnabled function.
115:                     Operation is atomic.
116:                 */
117:                 
118:                 PLIB_TEMPLATE bool DMA_ChannelXAutoIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
119:                 {
120:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
121:                 
122:                     return (bool)regs->DCHxCON.CHAEN;
123:                 }
124:                 
125:                 
126:                 #endif /*_DMA_CHANNELXAUTO_DEFAULT_H*/
127:                 
128:                 /******************************************************************************
129:                  End of File
130:                 */
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelxabortirq_default.h  -----
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelXAbortIRQ_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelXAbortIRQ
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelXAbortIRQ
16:                          PLIB_DMA_ChannelXAbortIRQSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_CHANNELXABORTIRQ_DEFAULT_H
47:                  #define _DMA_CHANNELXABORTIRQ_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsChannelXAbortIRQ_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsChannelXAbortIRQ
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelXAbortIRQ function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsChannelXAbortIRQ PLIB_DMA_ExistsChannelXAbortIRQ
62:                  PLIB_TEMPLATE bool DMA_ExistsChannelXAbortIRQ_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_ChannelXAbortIRQSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_ChannelXAbortIRQSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_ChannelXAbortIRQSet function.
76:                  */
77:                  
78:                  PLIB_TEMPLATE void DMA_ChannelXAbortIRQSet_Default( DMA_MODULE_ID index, DMA_CHANNEL channel, DMA_TRIGGER_SOURCE IRQ)
79:                  {
80:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000040  00000000   NOP
81:                  
82:                      regs->DCHxECON.CHAIRQ = IRQ;
00000058  00000000   NOP
83:                  }
84:                  
85:                  
86:                  #endif /*_DMA_CHANNELXABORTIRQ_DEFAULT_H*/
87:                  
88:                  /******************************************************************************
89:                   End of File
90:                  */
91:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_channelx_default.h  -------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_ChannelX_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : ChannelX
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsChannelX
16:                          PLIB_DMA_ChannelXEnable
17:                          PLIB_DMA_ChannelXIsEnabled
18:                          PLIB_DMA_ChannelXDisable
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_CHANNELX_DEFAULT_H
49:                  #define _DMA_CHANNELX_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsChannelX_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsChannelX
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsChannelX function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsChannelX PLIB_DMA_ExistsChannelX
64:                  PLIB_TEMPLATE bool DMA_ExistsChannelX_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_ChannelXEnable_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_ChannelXEnable
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_ChannelXEnable function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_ChannelXEnable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
82:                  {
83:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
84:                  
85:                      regs->DCHxCONSET = _DCH0CON_CHEN_MASK;
9D001B44  24030080   ADDIU V1, ZERO, 128
00000028  00000000   NOP
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_ChannelXIsEnabled_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_ChannelXIsEnabled
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_ChannelXIsEnabled function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE bool DMA_ChannelXIsEnabled_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
101:                 {
102:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
103:                 
104:                     return (bool)regs->DCHxCON.CHEN;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_ChannelXDisable_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_ChannelXDisable
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_ChannelXDisable function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE void DMA_ChannelXDisable_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
120:                 {
121:                     volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
122:                 
123:                     regs->DCHxCONCLR = _DCH0CON_CHEN_MASK;
00000028  00000000   NOP
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_CHANNELX_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_busy_default.h  -----------------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_Busy_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : Busy
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsBusy
16:                          PLIB_DMA_BusyActiveSet
17:                          PLIB_DMA_BusyActiveReset
18:                          PLIB_DMA_IsBusy
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DMA_BUSY_DEFAULT_H
49:                  #define _DMA_BUSY_DEFAULT_H
50:                  
51:                  #include "dma_Registers.h"
52:                  
53:                  //******************************************************************************
54:                  /* Function :  DMA_ExistsBusy_Default
55:                  
56:                    Summary:
57:                      Implements Default variant of PLIB_DMA_ExistsBusy
58:                  
59:                    Description:
60:                      This template implements the Default variant of the PLIB_DMA_ExistsBusy function.
61:                  */
62:                  
63:                  #define PLIB_DMA_ExistsBusy PLIB_DMA_ExistsBusy
64:                  PLIB_TEMPLATE bool DMA_ExistsBusy_Default( DMA_MODULE_ID index )
65:                  {
66:                      return true;
67:                  }
68:                  
69:                  
70:                  //******************************************************************************
71:                  /* Function :  DMA_BusyActiveSet_Default
72:                  
73:                    Summary:
74:                      Implements Default variant of PLIB_DMA_BusyActiveSet
75:                  
76:                    Description:
77:                      This template implements the Default variant of the PLIB_DMA_BusyActiveSet function.
78:                      Operation is atomic.
79:                  */
80:                  
81:                  PLIB_TEMPLATE void DMA_BusyActiveSet_Default( DMA_MODULE_ID index )
82:                  {
83:                      volatile dma_register_t *regs = (dma_register_t *)index;
84:                  
85:                      regs->DMACONSET = _DMACON_DMABUSY_MASK;
86:                  }
87:                  
88:                  
89:                  //******************************************************************************
90:                  /* Function :  DMA_BusyActiveReset_Default
91:                  
92:                    Summary:
93:                      Implements Default variant of PLIB_DMA_BusyActiveReset
94:                  
95:                    Description:
96:                      This template implements the Default variant of the PLIB_DMA_BusyActiveReset function.
97:                      Operation is atomic.
98:                  */
99:                  
100:                 PLIB_TEMPLATE void DMA_BusyActiveReset_Default( DMA_MODULE_ID index )
101:                 {
102:                     volatile dma_register_t *regs = (dma_register_t *)index;
103:                 
104:                     regs->DMACONCLR = _DMACON_DMABUSY_MASK;
105:                 }
106:                 
107:                 
108:                 //******************************************************************************
109:                 /* Function :  DMA_IsBusy_Default
110:                 
111:                   Summary:
112:                     Implements Default variant of PLIB_DMA_IsBusy
113:                 
114:                   Description:
115:                     This template implements the Default variant of the PLIB_DMA_IsBusy function.
116:                     Operation is atomic.
117:                 */
118:                 
119:                 PLIB_TEMPLATE bool DMA_IsBusy_Default( DMA_MODULE_ID index )
120:                 {
121:                     volatile dma_register_t *regs = (dma_register_t *)index;
122:                 
123:                     return regs->DMACON.DMABUSY;
00000000  00000000   NOP
124:                 }
125:                 
126:                 
127:                 #endif /*_DMA_BUSY_DEFAULT_H*/
128:                 
129:                 /******************************************************************************
130:                  End of File
131:                 */
132:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/dma/templates/dma_aborttransfer_default.h  --------
1:                   /*******************************************************************************
2:                     DMA Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       dma_AbortTransfer_Default.h
6:                   
7:                     Summary:
8:                       DMA PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : AbortTransfer
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DMA_ExistsAbortTransfer
16:                          PLIB_DMA_AbortTransferSet
17:                  
18:                  *******************************************************************************/
19:                  
20:                  //DOM-IGNORE-BEGIN
21:                  /*******************************************************************************
22:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  
44:                  //DOM-IGNORE-END
45:                  
46:                  #ifndef _DMA_ABORTTRANSFER_DEFAULT_H
47:                  #define _DMA_ABORTTRANSFER_DEFAULT_H
48:                  
49:                  #include "dma_Registers.h"
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DMA_ExistsAbortTransfer_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DMA_ExistsAbortTransfer
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DMA_ExistsAbortTransfer function.
59:                  */
60:                  
61:                  #define PLIB_DMA_ExistsAbortTransfer PLIB_DMA_ExistsAbortTransfer
62:                  PLIB_TEMPLATE bool DMA_ExistsAbortTransfer_Default( DMA_MODULE_ID index )
63:                  {
64:                      return true;
65:                  }
66:                  
67:                  
68:                  //******************************************************************************
69:                  /* Function :  DMA_AbortTransferSet_Default
70:                  
71:                    Summary:
72:                      Implements Default variant of PLIB_DMA_AbortTransferSet
73:                  
74:                    Description:
75:                      This template implements the Default variant of the PLIB_DMA_AbortTransferSet function.
76:                      Operation is atomic.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DMA_AbortTransferSet_Default( DMA_MODULE_ID index , DMA_CHANNEL channel )
80:                  {
81:                      volatile dma_ch_register_t *regs = (dma_ch_register_t *)(index + sizeof(dma_register_t) + channel * sizeof(dma_ch_register_t));
00000010  00000000   NOP
00000018  00000000   NOP
82:                  
83:                      regs->DCHxECONSET = _DCH0ECON_CABORT_MASK;
00000028  00000000   NOP
00000030  00000000   NOP
84:                  }
85:                  
86:                  
87:                  #endif /*_DMA_ABORTTRANSFER_DEFAULT_H*/
88:                  
89:                  /******************************************************************************
90:                   End of File
91:                  */
92:                  
---  c:/microchip/harmony/v2_01b/framework/peripheral/devcon/templates/devcon_syslockunlock_default.h  --
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_SysLockUnlock_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : SysLockUnlock
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_SystemUnlock
16:                          PLIB_DEVCON_SystemLock
17:                          PLIB_DEVCON_ExistsSystemLockUnlock
18:                          PLIB_DEVCON_ExistsDeviceVerAndId
19:                  
20:                  *******************************************************************************/
21:                  
22:                  //DOM-IGNORE-BEGIN
23:                  /*******************************************************************************
24:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
25:                  
26:                  Microchip licenses to you the right to use, modify, copy and distribute
27:                  Software only when embedded on a Microchip microcontroller or digital signal
28:                  controller that is integrated into your product or third party product
29:                  (pursuant to the sublicense terms in the accompanying license agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software for
32:                  additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
35:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
36:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
37:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
38:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
39:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
40:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
41:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
42:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
43:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
44:                  *******************************************************************************/
45:                  
46:                  //DOM-IGNORE-END
47:                  
48:                  #ifndef _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
49:                  #define _DEVCON_SYSLOCKUNLOCK_DEFAULT_H
50:                  
51:                  //******************************************************************************
52:                  /* Function :  DEVCON_SystemUnlock_Default
53:                  
54:                    Summary:
55:                      Implements Default variant of PLIB_DEVCON_SystemUnlock 
56:                  
57:                    Description:
58:                      This template implements the Default variant of the PLIB_DEVCON_SystemUnlock function.
59:                  */
60:                  
61:                  PLIB_TEMPLATE void DEVCON_SystemUnlock_Default( DEVCON_MODULE_ID index )
62:                  {	
63:                  	SYSKEY = 0x00000000;
9D003390  3C02BF81   LUI V0, -16511
9D003394  AC40F230   SW ZERO, -3536(V0)
00000000  00000000   NOP
64:                  	SYSKEY = 0xAA996655;
9D003398  3C04AA99   LUI A0, -21863
9D00339C  24846655   ADDIU A0, A0, 26197
9D0033A0  AC44F230   SW A0, -3536(V0)
00000008  00000000   NOP
65:                  	SYSKEY = 0x556699AA;
9D0033A4  3C045566   LUI A0, 21862
9D0033A8  348499AA   ORI A0, A0, -26198
9D0033AC  AC44F230   SW A0, -3536(V0)
00000014  00000000   NOP
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  DEVCON_SystemLock_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_DEVCON_SystemLock 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_DEVCON_SystemLock function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void DEVCON_SystemLock_Default( DEVCON_MODULE_ID index )
80:                  {
81:                  	SYSKEY = 0x33333333;
9D00352C  3C043333   LUI A0, 13107
9D003530  24843333   ADDIU A0, A0, 13107
9D003534  3C03BF81   LUI V1, -16511
9D003538  AC64F230   SW A0, -3536(V1)
82:                  }
83:                  
84:                  
85:                  //******************************************************************************
86:                  /* Function :  DEVCON_ExistsSystemLockUnlock_Default
87:                  
88:                    Summary:
89:                      Implements Default variant of PLIB_DEVCON_ExistsSystemLockUnlock
90:                  
91:                    Description:
92:                      This template implements the Default variant of the PLIB_DEVCON_ExistsSystemLockUnlock function.
93:                  */
94:                  
95:                  #define PLIB_DEVCON_ExistsSystemLockUnlock PLIB_DEVCON_ExistsSystemLockUnlock
96:                  PLIB_TEMPLATE bool DEVCON_ExistsSystemLockUnlock_Default( DEVCON_MODULE_ID index )
97:                  {
98:                      return true;
99:                  }
100:                 
101:                 #endif /*_DEVCON_SYSLOCKUNLOCK_DEFAULT_H*/
102:                 
103:                 /******************************************************************************
104:                  End of File
105:                 */
106:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/devcon/templates/devcon_jtagenable_default.h  -----
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_JTAGEnable_Default.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : JTAGEnable
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_DEVCON_JTAGPortEnable
16:                          PLIB_DEVCON_JTAGPortDisable
17:                          PLIB_DEVCON_ExistsJTAGEnable
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_JTAGENABLE_DEFAULT_H
48:                  #define _DEVCON_JTAGENABLE_DEFAULT_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_JTAGPortEnable_Default
52:                  
53:                    Summary:
54:                      Implements Default variant of PLIB_DEVCON_JTAGPortEnable
55:                  
56:                    Description:
57:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortEnable function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_JTAGPortEnable_Default( DEVCON_MODULE_ID index )
61:                  {
62:                      *((SFR_TYPE *)(&CFGCON)) |=  1u<< _CFGCON_JTAGEN_POSITION;
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_JTAGPortDisable_Default
68:                  
69:                    Summary:
70:                      Implements Default variant of PLIB_DEVCON_JTAGPortDisable
71:                  
72:                    Description:
73:                      This template implements the Default variant of the PLIB_DEVCON_JTAGPortDisable function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_JTAGPortDisable_Default( DEVCON_MODULE_ID index )
77:                  {
78:                      *((SFR_TYPE *)(&CFGCON)) &= ~(1 << _CFGCON_JTAGEN_POSITION);
00000000  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsJTAGEnable_Default
84:                  
85:                    Summary:
86:                      Implements Default variant of PLIB_DEVCON_ExistsJTAGEnable
87:                  
88:                    Description:
89:                      This template implements the Default variant of the PLIB_DEVCON_ExistsJTAGEnable function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsJTAGEnable PLIB_DEVCON_ExistsJTAGEnable
93:                  PLIB_TEMPLATE bool DEVCON_ExistsJTAGEnable_Default( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_JTAGENABLE_DEFAULT_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/devcon/templates/devcon_deviceregslockunlock_pic32mx.h
1:                   /*******************************************************************************
2:                     DEVCON Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       devcon_DeviceRegsLockUnlock_PIC32MX.h
6:                   
7:                     Summary:
8:                       DEVCON PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DeviceRegsLockUnlock
13:                      and its Variant : PIC32MX
14:                      For following APIs :
15:                          PLIB_DEVCON_DeviceRegistersLock
16:                          PLIB_DEVCON_DeviceRegistersUnlock
17:                          PLIB_DEVCON_ExistsDeviceRegsLockUnlock
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MX_H
48:                  #define _DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MX_H
49:                  
50:                  //******************************************************************************
51:                  /* Function :  DEVCON_DeviceRegistersLock_PIC32MX
52:                  
53:                    Summary:
54:                      Implements PIC32MX variant of PLIB_DEVCON_DeviceRegistersLock 
55:                  
56:                    Description:
57:                      This template implements the PIC32MX variant of the PLIB_DEVCON_DeviceRegistersLock function.
58:                  */
59:                  
60:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersLock_PIC32MX( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
61:                  {
62:                      *((SFR_TYPE *)(&CFGCON)) |= ((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK) & (registersToLock << (_CFGCON_PMDLOCK_POSITION - 1u)));
63:                  }
64:                  
65:                  
66:                  //******************************************************************************
67:                  /* Function :  DEVCON_DeviceRegistersUnlock_PIC32MX
68:                  
69:                    Summary:
70:                      Implements PIC32MX variant of PLIB_DEVCON_DeviceRegistersUnlock 
71:                  
72:                    Description:
73:                      This template implements the PIC32MX variant of the PLIB_DEVCON_DeviceRegistersUnlock function.
74:                  */
75:                  
76:                  PLIB_TEMPLATE void DEVCON_DeviceRegistersUnlock_PIC32MX( DEVCON_MODULE_ID index , DEVCON_REGISTER_SET registersToLock )
77:                  {
78:                      *((SFR_TYPE *)(&CFGCON)) &= ~((_CFGCON_IOLOCK_MASK | _CFGCON_PMDLOCK_MASK) & (registersToLock << (_CFGCON_PMDLOCK_POSITION - 1u)));
00000020  00000000   NOP
79:                  }
80:                  
81:                  
82:                  //******************************************************************************
83:                  /* Function :  DEVCON_ExistsDeviceRegsLockUnlock_PIC32MX
84:                  
85:                    Summary:
86:                      Implements PIC32MX variant of PLIB_DEVCON_ExistsDeviceRegsLockUnlock
87:                  
88:                    Description:
89:                      This template implements the PIC32MX variant of the PLIB_DEVCON_ExistsDeviceRegsLockUnlock function.
90:                  */
91:                  
92:                  #define PLIB_DEVCON_ExistsDeviceRegsLockUnlock PLIB_DEVCON_ExistsDeviceRegsLockUnlock
93:                  PLIB_TEMPLATE bool DEVCON_ExistsDeviceRegsLockUnlock_PIC32MX( DEVCON_MODULE_ID index )
94:                  {
95:                      return true;
96:                  }
97:                  
98:                  
99:                  #endif /*_DEVCON_DEVICEREGSLOCKUNLOCK_PIC32MX_H*/
100:                 
101:                 /******************************************************************************
102:                  End of File
103:                 */
104:                 
---  c:/microchip/harmony/v2_01b/framework/peripheral/bmx/templates/bmx_dataramwaitstate_default.h  -----
1:                   /*******************************************************************************
2:                     BMX Peripheral Library Template Implementation
3:                   
4:                     File Name:
5:                       bmx_DataRamWaitState_Default.h
6:                   
7:                     Summary:
8:                       BMX PLIB Template Implementation
9:                   
10:                    Description:
11:                      This header file contains template implementations
12:                      For Feature : DataRamWaitState
13:                      and its Variant : Default
14:                      For following APIs :
15:                          PLIB_BMX_ExistsDataRamWaitState
16:                          PLIB_BMX_DataRamWaitStateSet
17:                          PLIB_BMX_DataRamWaitStateGet
18:                  
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  
45:                  //DOM-IGNORE-END
46:                  
47:                  #ifndef _BMX_DATARAMWAITSTATE_DEFAULT_H
48:                  #define _BMX_DATARAMWAITSTATE_DEFAULT_H
49:                  
50:                  #include "bmx_registers.h"
51:                  
52:                  //******************************************************************************
53:                  /* Function :  BMX_ExistsDataRamWaitState_Default
54:                  
55:                    Summary:
56:                      Implements Default variant of PLIB_BMX_ExistsDataRamWaitState
57:                  
58:                    Description:
59:                      This template implements the Default variant of the PLIB_BMX_ExistsDataRamWaitState function.
60:                  */
61:                  
62:                  #define PLIB_BMX_ExistsDataRamWaitState PLIB_BMX_ExistsDataRamWaitState
63:                  PLIB_TEMPLATE bool BMX_ExistsDataRamWaitState_Default( BMX_MODULE_ID index )
64:                  {
65:                      return true;
66:                  }
67:                  
68:                  
69:                  //******************************************************************************
70:                  /* Function :  BMX_DataRamWaitStateSet_Default
71:                  
72:                    Summary:
73:                      Implements Default variant of PLIB_BMX_DataRamWaitStateSet 
74:                  
75:                    Description:
76:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateSet function.
77:                  */
78:                  
79:                  PLIB_TEMPLATE void BMX_DataRamWaitStateSet_Default( BMX_MODULE_ID index , PLIB_BMX_DATA_RAM_WAIT_STATES wait )
80:                  {
81:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
82:                  
83:                      bmx->BMXCON.BMXWSDRM = wait;
9D0032EC  3C02BF88   LUI V0, -16504
9D0032F0  8C432000   LW V1, 8192(V0)
9D0032F4  7C033184   INS V1, ZERO, 6, 1
9D0032F8  AC432000   SW V1, 8192(V0)
84:                  }
85:                  
86:                  
87:                  //******************************************************************************
88:                  /* Function :  BMX_DataRamWaitStateGet_Default
89:                  
90:                    Summary:
91:                      Implements Default variant of PLIB_BMX_DataRamWaitStateGet 
92:                  
93:                    Description:
94:                      This template implements the Default variant of the PLIB_BMX_DataRamWaitStateGet function.
95:                  */
96:                  
97:                  PLIB_TEMPLATE PLIB_BMX_DATA_RAM_WAIT_STATES BMX_DataRamWaitStateGet_Default( BMX_MODULE_ID index )
98:                  {
99:                      volatile bmx_register_t *bmx = (bmx_register_t *)index;
100:                 
101:                     return (PLIB_BMX_DATA_RAM_WAIT_STATES)bmx->BMXCON.BMXWSDRM;
102:                 }
103:                 
104:                 
105:                 #endif /*_BMX_DATARAMWAITSTATE_DEFAULT_H*/
106:                 
107:                 /******************************************************************************
108:                  End of File
109:                 */
110:                 
---  c:/microchip/harmony/v2_01b/framework/osal/src/osal_impl_basic.h  ----------------------------------
1:                   /*******************************************************************************
2:                     Operating System Abstraction Layer Basic Implementation
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       osal_impl_basic.h
9:                   
10:                    Summary:
11:                      Header file for the OSAL Basic implementation.
12:                  
13:                    Description:
14:                      This file defines the additions or variations to the OSAL base implementation.
15:                   Where it is logical or possible to implement an OSAL function in a simple form
16:                   without an RTOS being present then the function has been defined here and
17:                   implemented either here as an inline or #define. Longer functions that are part
18:                   of the basic implementation may also be found in the file osal.c
19:                   The best way to consider this file is detailing any deviations from the osal.h
20:                   definitions OR as the complete implementation of those functions when pretending
21:                   to support BASIC operations.
22:                   *******************************************************************************/
23:                  
24:                  // DOM-IGNORE-BEGIN
25:                  /*******************************************************************************
26:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
27:                  
28:                  Microchip licenses to you the right to use, modify, copy and distribute
29:                  Software only when embedded on a Microchip microcontroller or digital signal
30:                  controller that is integrated into your product or third party product
31:                  (pursuant to the sublicense terms in the accompanying license agreement).
32:                  
33:                  You should refer to the license agreement accompanying this Software for
34:                  additional information regarding your rights and obligations.
35:                  
36:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
37:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
38:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
39:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
40:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
41:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
42:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
43:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
44:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
45:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
46:                   *******************************************************************************/
47:                  // DOM-IGNORE-END
48:                  
49:                  #ifndef _OSAL_IMPL_BASIC_H
50:                  #define _OSAL_IMPL_BASIC_H
51:                  
52:                  #ifdef __cplusplus
53:                  extern "C" {
54:                  #endif
55:                  
56:                  // *****************************************************************************
57:                  // *****************************************************************************
58:                  // Section: Included Files
59:                  // *****************************************************************************
60:                  // *****************************************************************************
61:                  #include <stdint.h>
62:                  #include <stdbool.h>
63:                  
64:                  
65:                  typedef uint8_t                     OSAL_SEM_HANDLE_TYPE;
66:                  typedef uint8_t                     OSAL_MUTEX_HANDLE_TYPE;
67:                  typedef uint32_t                    OSAL_CRITSECT_DATA_TYPE;
68:                  #define OSAL_WAIT_FOREVER           (uint16_t) 0xFFFF
69:                  
70:                  #define OSAL_SEM_DECLARE(semID)         uint8_t    semID
71:                  #define OSAL_MUTEX_DECLARE(mutexID)     uint8_t    mutexID
72:                  
73:                  // *****************************************************************************
74:                  /* Macro: OSAL_ASSERT
75:                   */
76:                  
77:                  #define OSAL_ASSERT(test, message)      test
78:                  
79:                  // *****************************************************************************
80:                  /* OSAL Result type
81:                  
82:                    Summary:
83:                      Enumerated type representing the general return value from OSAL functions.
84:                  
85:                    Description:
86:                      This enum represents possible return types from OSAL functions.
87:                  
88:                    Remarks:
89:                      These enum values are the possible return values from OSAL functions
90:                      where a standard success/fail type response is required. The majority
91:                      of OSAL functions will return this type with a few exceptions.
92:                  */
93:                  
94:                  typedef enum OSAL_SEM_TYPE
95:                  {
96:                      OSAL_SEM_TYPE_BINARY,
97:                      OSAL_SEM_TYPE_COUNTING
98:                  } OSAL_SEM_TYPE;
99:                  
100:                 typedef enum OSAL_CRIT_TYPE
101:                 {
102:                     OSAL_CRIT_TYPE_LOW,
103:                     OSAL_CRIT_TYPE_HIGH
104:                 } OSAL_CRIT_TYPE;
105:                 
106:                 typedef enum OSAL_RESULT
107:                 {
108:                     OSAL_RESULT_NOT_IMPLEMENTED = -1,
109:                     OSAL_RESULT_FALSE = 0,
110:                     OSAL_RESULT_TRUE = 1
111:                 } OSAL_RESULT;
112:                 
113:                 // *****************************************************************************
114:                 // *****************************************************************************
115:                 // Section: Section: Interface Routines Group Declarations
116:                 // *****************************************************************************
117:                 // *****************************************************************************
118:                 static __inline__ OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type, uint8_t maxCount, uint8_t initialCount);
119:                 static __inline__ OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* semID);
120:                 static __inline__ OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS);
121:                 static __inline__ OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID);
122:                 static __inline__ OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID);
123:                 static __inline__ uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID);
124:                 
125:                 static __inline__ OSAL_CRITSECT_DATA_TYPE __attribute__((nomips16,nomicromips)) OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity);
126:                 static __inline__ void __attribute__((nomips16,nomicromips)) OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status);
127:                 
128:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID);
129:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID);
130:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS);
131:                 static __inline__ OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID);
132:                 
133:                 void* OSAL_Malloc(size_t size);
134:                 void OSAL_Free(void* pData);
135:                 
136:                 OSAL_RESULT OSAL_Initialize();
137:                 
138:                 static __inline__ const char* OSAL_Name(void);
139:                 
140:                 // *****************************************************************************
141:                 // *****************************************************************************
142:                 // Section: Interface Routines Group Defintions
143:                 // *****************************************************************************
144:                 // *****************************************************************************
145:                 
146:                 /* Critical Section group */
147:                 // *****************************************************************************
148:                 /* Function: OSAL_CRITSECT_DATA_TYPE OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
149:                  */
150:                 static OSAL_CRITSECT_DATA_TYPE __attribute__((nomips16,nomicromips,always_inline)) OSAL_CRIT_Enter(OSAL_CRIT_TYPE severity)
151:                 {
152:                    if(severity == OSAL_CRIT_TYPE_LOW)
153:                       return (0);
154:                    /*if priority is set to HIGH the user wants interrupts disabled*/
155:                    return (__builtin_disable_interrupts());
9D002264  41626000   DI V0
9D002268  000000C0   EHB
9D00227C  41626000   DI V0
9D002280  000000C0   EHB
156:                 }
157:                 
158:                 // *****************************************************************************
159:                 /* Function: void OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
160:                  */
161:                 static void __attribute__((nomips16,nomicromips,always_inline)) OSAL_CRIT_Leave(OSAL_CRIT_TYPE severity, OSAL_CRITSECT_DATA_TYPE status)
162:                 {
163:                    if(severity == OSAL_CRIT_TYPE_LOW)
164:                       return;
165:                    /*if priority is set to HIGH the user wants interrupts re-enabled to the state 
166:                    they were before disabling.*/
167:                    __builtin_mtc0(12,0,status);   
9D002274  40826000   MTC0 V0, Status
9D002278  000000C0   EHB
9D00228C  40826000   MTC0 V0, Status
9D002290  000000C0   EHB
168:                 }
169:                 
170:                 // *****************************************************************************
171:                 /* Function: OSAL_RESULT OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE semID, OSAL_SEM_TYPE type,
172:                                                 uint8_t maxCount, uint8_t initialCount)
173:                  */
174:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Create(OSAL_SEM_HANDLE_TYPE* semID, OSAL_SEM_TYPE type,
175:                                                 uint8_t maxCount, uint8_t initialCount)
176:                 {
177:                    OSAL_CRITSECT_DATA_TYPE IntState;
178:                    
179:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
180:                  
181:                    if (type == OSAL_SEM_TYPE_COUNTING)
182:                       *semID = initialCount;
9D00226C  3C03A000   LUI V1, -24576
9D002270  A06007A8   SB ZERO, 1960(V1)
9D002284  3C03A000   LUI V1, -24576
9D002288  A06007A9   SB ZERO, 1961(V1)
183:                    else
184:                       *semID = 1;
185:                  
186:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
187:                    
188:                    return OSAL_RESULT_TRUE;
189:                 }
190:                 
191:                 // *****************************************************************************
192:                 /* Function: OSAL_RESULT OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE semID)
193:                  */
194:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Delete(OSAL_SEM_HANDLE_TYPE* mutexID)
195:                 {
196:                    return (OSAL_RESULT_TRUE);
197:                 }
198:                 
199:                 // *****************************************************************************
200:                 /* Function: OSAL_RESULT OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE semID, uint16_t waitMS)
201:                  */
202:                 static  OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Pend(OSAL_SEM_HANDLE_TYPE* semID, uint16_t waitMS)
203:                 {
204:                    OSAL_CRITSECT_DATA_TYPE IntState;
205:                    
206:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
207:                        
208:                    if (*semID > 0)
209:                    {
210:                       (*semID)--;
211:                       OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
212:                       
213:                       return OSAL_RESULT_TRUE;
214:                    }
215:                    
216:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
217:                       
218:                    return OSAL_RESULT_FALSE;
219:                 }
220:                 
221:                 // *****************************************************************************
222:                 /* Function: OSAL_RESULT OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE semID)
223:                  */
224:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_Post(OSAL_SEM_HANDLE_TYPE* semID)
225:                 {
226:                    OSAL_CRITSECT_DATA_TYPE IntState;
227:                    
228:                    IntState = OSAL_CRIT_Enter(OSAL_CRIT_TYPE_HIGH);
229:                    (*semID)++;
230:                    OSAL_CRIT_Leave(OSAL_CRIT_TYPE_HIGH,IntState);
231:                    
232:                    return OSAL_RESULT_TRUE;
233:                 }
234:                 
235:                 // *****************************************************************************
236:                 /* Function: OSAL_RESULT OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE semID)
237:                  */
238:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_SEM_PostISR(OSAL_SEM_HANDLE_TYPE* semID)
239:                 {
240:                     (*semID)++;
000000D8  00000000   NOP
0000013C  00000000   NOP
241:                     return OSAL_RESULT_TRUE;
242:                 }
243:                 
244:                 // *****************************************************************************
245:                 /* Function: uint8_t OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE semID)
246:                  */
247:                 static uint8_t __attribute__((always_inline)) OSAL_SEM_GetCount(OSAL_SEM_HANDLE_TYPE* semID)
248:                 {
249:                     return *semID;
250:                 }
251:                 
252:                 // *****************************************************************************
253:                 /* Function: OSAL_RESULT OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE mutexID)
254:                  */
255:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Create(OSAL_MUTEX_HANDLE_TYPE* mutexID)
256:                 {
257:                    *mutexID = 1;
9D000CCC  A0430060   SB V1, 96(V0)
9D000CDC  2782804C   ADDIU V0, GP, -32692
9D000CE0  A0430001   SB V1, 1(V0)
9D000CE4  A0430002   SB V1, 2(V0)
9D001834  A2220030   SB V0, 48(S1)
9D001844  27828050   ADDIU V0, GP, -32688
9D001848  24030001   ADDIU V1, ZERO, 1
9D00184C  A0430001   SB V1, 1(V0)
9D001850  A0430002   SB V1, 2(V0)
258:                    return OSAL_RESULT_TRUE;
259:                 }
260:                 
261:                 // *****************************************************************************
262:                 /* Function: OSAL_RESULT OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE mutexID)
263:                  */
264:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Delete(OSAL_MUTEX_HANDLE_TYPE* mutexID)
265:                 {
266:                    return (OSAL_RESULT_TRUE);
267:                    
268:                 }
269:                 // *****************************************************************************
270:                 /* Function: OSAL_RESULT OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE mutexID, uint16_t waitMS)
271:                  */
272:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Lock(OSAL_MUTEX_HANDLE_TYPE* mutexID, uint16_t waitMS)
273:                 {
274:                     if (*mutexID == 1)
9D00136C  90840060   LBU A0, 96(A0)
9D001370  24030001   ADDIU V1, ZERO, 1
9D001374  14830066   BNE A0, V1, 0x9D001510
9D001378  8FBF001C   LW RA, 28(SP)
9D0021F4  93868051   LBU A2, -32687(GP)
9D0021F8  24040001   ADDIU A0, ZERO, 1
9D0021FC  14C4002C   BNE A2, A0, 0x9D0022B0
9D002200  2402FFFF   ADDIU V0, ZERO, -1
9D002848  9384804D   LBU A0, -32691(GP)
9D00284C  24030001   ADDIU V1, ZERO, 1
9D002850  14830018   BNE A0, V1, 0x9D0028B4
9D002854  2402FFFF   ADDIU V0, ZERO, -1
9D00320C  90440030   LBU A0, 48(V0)
9D003210  1483000F   BNE A0, V1, 0x9D003250
9D003214  8FBF0014   LW RA, 20(SP)
9D00349C  90650030   LBU A1, 48(V1)
9D0034A0  14A40008   BNE A1, A0, 0x9D0034C4
9D0034A4  00001021   ADDU V0, ZERO, ZERO
00000018  00000000   NOP
00000024  00000000   NOP
275:                     {
276:                         *mutexID = 0;
9D00137C  A2000060   SB ZERO, 96(S0)
9D0034A8  A0600030   SB ZERO, 48(V1)
00000028  00000000   NOP
00000030  00000000   NOP
277:                         return OSAL_RESULT_TRUE;
278:                     }
279:                     return OSAL_RESULT_FALSE;
280:                 }
281:                 
282:                 // *****************************************************************************
283:                 /* Function: OSAL_RESULT OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE mutexID)
284:                  */
285:                 static OSAL_RESULT __attribute__((always_inline)) OSAL_MUTEX_Unlock(OSAL_MUTEX_HANDLE_TYPE* mutexID)
286:                 {
287:                     *mutexID = 1;
9D001458  24020001   ADDIU V0, ZERO, 1
9D00145C  A2020060   SB V0, 96(S0)
9D001500  24020001   ADDIU V0, ZERO, 1
9D001504  A2020060   SB V0, 96(S0)
9D002224  A3868051   SB A2, -32687(GP)
9D0022A8  A3828051   SB V0, -32687(GP)
9D002830  24030001   ADDIU V1, ZERO, 1
9D002844  A043876C   SB V1, -30868(V0)
9D002894  A384804D   SB A0, -32691(GP)
9D0028AC  A382804D   SB V0, -32691(GP)
9D003248  A0430030   SB V1, 48(V0)
9D0034B4  A0640030   SB A0, 48(V1)
00000060  00000000   NOP
000000D4  00000000   NOP
000001F0  00000000   NOP
288:                     return OSAL_RESULT_TRUE;
289:                 }
290:                 
291:                 // Miscellaneous functions
292:                 // *****************************************************************************
293:                 /* Function: void* OSAL_Malloc(size_t size)
294:                  */
295:                 #define OSAL_Malloc(size)                               (malloc(size))
296:                 
297:                 // *****************************************************************************
298:                 /* Function: void OSAL_Free(void* pData)
299:                  */
300:                 #define OSAL_Free(pData)                                (free(pData))
301:                 
302:                 // Initialization and Diagnostics
303:                 // *****************************************************************************
304:                 /* Function: OSAL_RESULT OSAL_Initialize()
305:                  */
306:                 #define OSAL_Initialize()
307:                 
308:                 
309:                 // *****************************************************************************
310:                 /* Function: const char* OSAL_Name()
311:                  */
312:                 static const char* __attribute__((always_inline)) OSAL_Name(void)
313:                 {
314:                    return((const char*) "BASIC");
315:                 }
316:                 
317:                 
318:                 #ifdef __cplusplus
319:                 }
320:                 #endif
321:                 
322:                 #endif // _OSAL_IMPL_BASIC_H
323:                 
324:                 /*******************************************************************************
325:                  End of File
326:                  */
327:                 
328:                 
329:                 
330:                 
---  c:/microchip/harmony/v2_01b/framework/driver/usart/src/dynamic/drv_usart_byte_model.c  -------------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart_byte_model.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver's byte model functionality.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #include "driver/usart/src/drv_usart_local.h"
44:                  
45:                  // *****************************************************************************
46:                  /* Function:
47:                      void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
48:                  
49:                    Summary:
50:                      Dynamic implementation of DRV_USART_WriteByte client interface function.
51:                  
52:                    Description:
53:                      This is the dynamic implementation of DRV_USART_WriteByte client
54:                      interface function.
55:                  
56:                    Remarks:
57:                      See drv_usart.h for usage information.
58:                  */
59:                  
60:                  void DRV_USART_WriteByte( const DRV_HANDLE handle, const uint8_t byte)
61:                  {
9D0031EC  27BDFFE8   ADDIU SP, SP, -24
9D0031F0  AFBF0014   SW RA, 20(SP)
9D0031F4  AFB00010   SW S0, 16(SP)
62:                      DRV_USART_CLIENT_OBJ * client;
63:                      DRV_USART_OBJ * hDriver;
64:                  
65:                      /* Validate the client handle */
66:                      client = _DRV_USART_DriverHandleValidate(handle);
9D0031F8  0F400DE6   JAL _DRV_USART_DriverHandleValidate
9D0031FC  30B000FF   ANDI S0, A1, 255
67:                  
68:                      if(client == NULL)
9D003200  10400012   BEQ V0, ZERO, 0x9D00324C
9D003204  24030001   ADDIU V1, ZERO, 1
69:                      {
70:                          SYS_DEBUG(0, "Invalid Driver Handle");
71:                          return;
72:                      }
73:                  
74:                      hDriver = client->hDriver;
9D003208  8C420000   LW V0, 0(V0)
75:                  
76:                      /* This function needs to be thread safe */
77:                  
78:                      if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
79:                      {
80:                          /* Send one byte */
81:                          PLIB_USART_TransmitterByteSend(hDriver->moduleId, byte);
82:                          _DRV_USART_InterruptSourceEnable(hDriver->txInterruptSource);
9D003224  8C440024   LW A0, 36(V0)
83:                          OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
84:                      }
85:                      else
86:                      {
87:                          SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_WriteByte() function");
88:                      }
89:                  }
9D00324C  8FBF0014   LW RA, 20(SP)
9D003250  8FB00010   LW S0, 16(SP)
9D003254  03E00008   JR RA
9D003258  27BD0018   ADDIU SP, SP, 24
90:                  
91:                  // *****************************************************************************
92:                  /* Function:
93:                      void DRV_USART_ReadByte( const DRV_HANDLE handle)
94:                  
95:                    Summary:
96:                      Dynamic implementation of DRV_USART_ReadByte client interface function.
97:                  
98:                    Description:
99:                      This is the dynamic implementation of DRV_USART_ReadByte client
100:                     interface function.
101:                 
102:                   Remarks:
103:                     See drv_usart.h for usage information.
104:                 */
105:                 
106:                 uint8_t DRV_USART_ReadByte( const DRV_HANDLE handle )
107:                 {
9D003480  27BDFFE8   ADDIU SP, SP, -24
9D003484  AFBF0014   SW RA, 20(SP)
108:                     DRV_USART_CLIENT_OBJ * client;
109:                     DRV_USART_OBJ * hDriver;
110:                     uint8_t readValue;
111:                 
112:                     /* Validate the client handle */
113:                     client = _DRV_USART_DriverHandleValidate(handle);
9D003488  0F400DE6   JAL _DRV_USART_DriverHandleValidate
9D00348C  00000000   NOP
114:                 
115:                     if(client == NULL)
9D003490  1040000B   BEQ V0, ZERO, 0x9D0034C0
9D003494  24040001   ADDIU A0, ZERO, 1
116:                     {
117:                         SYS_DEBUG(0, "Invalid Driver Handle");
118:                         return 0;
9D0034C0  00001021   ADDU V0, ZERO, ZERO
119:                     }
120:                 
121:                     hDriver = client->hDriver;
9D003498  8C430000   LW V1, 0(V0)
122:                 
123:                     /* This function needs to be thread safe */
124:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
125:                     {
126:                         /* Read one byte */
127:                         readValue = PLIB_USART_ReceiverByteReceive(hDriver->moduleId);
128:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
129:                     }
130:                     else
131:                     {
132:                         SYS_DEBUG(0, "Hardware Instance Mutex Time out in DRV_USART_ReadByte() function");
133:                         return 0;
134:                     }
135:                 	return readValue;
9D0034B8  0B400D31   J 0x9D0034C4
9D0034BC  304200FF   ANDI V0, V0, 255
136:                 }
9D0034C4  8FBF0014   LW RA, 20(SP)
9D0034C8  03E00008   JR RA
9D0034CC  27BD0018   ADDIU SP, SP, 24
137:                 
138:                 // *****************************************************************************
139:                 /* Function:
140:                     void DRV_USART_ReceiverBufferSizeGet( const DRV_HANDLE handle)
141:                 
142:                   Summary:
143:                     Dynamic implementation of DRV_USART_ReceiverBufferSizeGet client interface
144:                     function.
145:                 
146:                   Description:
147:                     This is the dynamic implementation of DRV_USART_ReceiverBufferSizeGet client
148:                     interface function.
149:                 
150:                   Remarks:
151:                     See drv_usart.h for usage information.
152:                 */
153:                 
154:                 unsigned int DRV_USART_ReceiverBufferSizeGet (const DRV_HANDLE handle )
155:                 {
00000000  00000000   NOP
156:                     DRV_USART_CLIENT_OBJ * client;
157:                 
158:                     /* Validate the client handle */
159:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
160:                 
161:                     if(client == NULL)
162:                     {
163:                         SYS_DEBUG(0, "Invalid Driver Handle");
164:                         return 0;
165:                     }
166:                 
167:                     return 8;
168:                 
169:                 }
00000010  00000000   NOP
170:                 
171:                 // *****************************************************************************
172:                 /* Function:
173:                     void DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle)
174:                 
175:                   Summary:
176:                     Dynamic implementation of DRV_USART_TransmitBufferSizeGet client interface
177:                     function.
178:                 
179:                   Description:
180:                     This is the dynamic implementation of DRV_USART_TransmitBufferSizeGet client
181:                     interface function.
182:                 
183:                   Remarks:
184:                     See drv_usart.h for usage information.
185:                 */
186:                 
187:                 unsigned int DRV_USART_TransmitBufferSizeGet( const DRV_HANDLE handle )
188:                 {
00000000  00000000   NOP
189:                     DRV_USART_CLIENT_OBJ * client;
190:                 
191:                     /* Validate the client handle */
192:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
193:                 
194:                     if(client == NULL)
195:                     {
196:                         SYS_DEBUG(0, "Invalid Driver Handle");
197:                         return 0;
198:                     }
199:                 
200:                     return 8;
201:                 
202:                 }
00000010  00000000   NOP
203:                 
204:                 // *****************************************************************************
205:                 /* Function:
206:                     void DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle)
207:                 
208:                   Summary:
209:                     Dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client interface
210:                     function.
211:                 
212:                   Description:
213:                     This is the dynamic implementation of DRV_USART_ReceiverBufferIsEmpty client
214:                     interface function.
215:                 
216:                   Remarks:
217:                     See drv_usart.h for usage information.
218:                 */
219:                 
220:                 bool DRV_USART_ReceiverBufferIsEmpty( const DRV_HANDLE handle )
221:                 {
9D0036FC  27BDFFE8   ADDIU SP, SP, -24
9D003700  AFBF0014   SW RA, 20(SP)
222:                     DRV_USART_CLIENT_OBJ * client;
223:                     DRV_USART_OBJ * hDriver;
224:                 
225:                     /* Validate the client handle */
226:                     client = _DRV_USART_DriverHandleValidate(handle);
9D003704  0F400DE6   JAL _DRV_USART_DriverHandleValidate
9D003708  00000000   NOP
227:                 
228:                     if(client == NULL)
9D00370C  50400006   BEQL V0, ZERO, 0x9D003728
9D003710  00001021   ADDU V0, ZERO, ZERO
229:                     {
230:                         SYS_DEBUG(0, "Invalid Driver Handle");
231:                         return false;
232:                     }
233:                 
234:                     hDriver = client->hDriver;
235:                 
236:                     /* If there is data available in the receiver, then this function
237:                        buffer is not empty and this function returns false. */
238:                 
239:                     return(PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId) ? false : true);
9D003714  8C420000   LW V0, 0(V0)
240:                 }
9D003728  8FBF0014   LW RA, 20(SP)
9D00372C  03E00008   JR RA
9D003730  27BD0018   ADDIU SP, SP, 24
241:                 
242:                 // *****************************************************************************
243:                 /* Function:
244:                     void DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle)
245:                 
246:                   Summary:
247:                     Dynamic implementation of DRV_USART_TransmitBufferIsFull client interface
248:                     function.
249:                 
250:                   Description:
251:                     This is the dynamic implementation of DRV_USART_TransmitBufferIsFull client
252:                     interface function.
253:                 
254:                   Remarks:
255:                     See drv_usart.h for usage information.
256:                 */
257:                 
258:                 bool DRV_USART_TransmitBufferIsFull( const DRV_HANDLE handle )
259:                 {
9D003734  27BDFFE8   ADDIU SP, SP, -24
9D003738  AFBF0014   SW RA, 20(SP)
260:                     DRV_USART_CLIENT_OBJ * client;
261:                     DRV_USART_OBJ * hDriver;
262:                 
263:                     /* Validate the client handle */
264:                     client = _DRV_USART_DriverHandleValidate(handle);
9D00373C  0F400DE6   JAL _DRV_USART_DriverHandleValidate
9D003740  00000000   NOP
265:                 
266:                     if(client == NULL)
9D003744  50400005   BEQL V0, ZERO, 0x9D00375C
9D003748  00001021   ADDU V0, ZERO, ZERO
267:                     {
268:                         SYS_DEBUG(0, "Invalid Driver Handle");
269:                         return false;
270:                     }
271:                 
272:                     hDriver = client->hDriver;
273:                 
274:                     /* If there is data available in the receiver, then this function
275:                        buffer is not empty and this function returns false. */
276:                 
277:                     return(PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId));
9D00374C  8C420000   LW V0, 0(V0)
278:                 }
9D00375C  8FBF0014   LW RA, 20(SP)
9D003760  03E00008   JR RA
9D003764  27BD0018   ADDIU SP, SP, 24
279:                 
---  c:/microchip/harmony/v2_01b/framework/driver/usart/src/dynamic/drv_usart.c  ------------------------
1:                   /********************************************************************************
2:                     USART Driver Dynamic implementation.
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_usart.c
9:                   
10:                    Summary:
11:                      Source code for the USART driver dynamic implementation.
12:                  
13:                    Description:
14:                      This file contains the source code for the dynamic implementation of the
15:                      USART driver.
16:                  *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) 2013 released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute Software
23:                  only when embedded on a Microchip microcontroller or digital  signal  controller
24:                  that is integrated into your product or third party  product  (pursuant  to  the
25:                  sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS  WITHOUT  WARRANTY  OF  ANY  KIND,
31:                  EITHER EXPRESS  OR  IMPLIED,  INCLUDING  WITHOUT  LIMITATION,  ANY  WARRANTY  OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A  PARTICULAR  PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR  ITS  LICENSORS  BE  LIABLE  OR  OBLIGATED  UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,  BREACH  OF  WARRANTY,  OR
35:                  OTHER LEGAL  EQUITABLE  THEORY  ANY  DIRECT  OR  INDIRECT  DAMAGES  OR  EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY  INCIDENTAL,  SPECIAL,  INDIRECT,  PUNITIVE  OR
37:                  CONSEQUENTIAL DAMAGES, LOST  PROFITS  OR  LOST  DATA,  COST  OF  PROCUREMENT  OF
38:                  SUBSTITUTE  GOODS,  TECHNOLOGY,  SERVICES,  OR  ANY  CLAIMS  BY  THIRD   PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE  THEREOF),  OR  OTHER  SIMILAR  COSTS.
40:                  *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  // *****************************************************************************
44:                  // *****************************************************************************
45:                  // Section: Included Files
46:                  // *****************************************************************************
47:                  // *****************************************************************************
48:                  
49:                  #include "driver/usart/src/drv_usart_local.h"
50:                  
51:                  // *****************************************************************************
52:                  // *****************************************************************************
53:                  // Section: Global Data
54:                  // *****************************************************************************
55:                  // *****************************************************************************
56:                  
57:                  /* This is the driver instance object array. */
58:                  DRV_USART_OBJ gDrvUSARTObj[DRV_USART_INSTANCES_NUMBER] ;
59:                  
60:                  /* This is the client object array. */
61:                  DRV_USART_CLIENT_OBJ gDrvUSARTClientObj[DRV_USART_CLIENTS_NUMBER];
62:                  
63:                  /* This object maintains data that is required by all USART
64:                     driver instances. */
65:                  DRV_USART_COMMON_DATA_OBJ gDrvUSARTCommonDataObj;
66:                  
67:                  // *****************************************************************************
68:                  // *****************************************************************************
69:                  // Section: USART Driver Interface Implementations
70:                  // *****************************************************************************
71:                  // *****************************************************************************
72:                  
73:                  // *****************************************************************************
74:                  /* Function:
75:                      SYS_MODULE_OBJ DRV_USART_Initialize
76:                      (
77:                          const SYS_MODULE_INDEX drvIndex,
78:                          const SYS_MODULE_INIT * const init
79:                      )
80:                  
81:                    Summary:
82:                      Dynamic implementation of DRV_USART_Initialize system interface function.
83:                  
84:                    Description:
85:                      This is the dynamic implementation of DRV_USART_Initialize system interface
86:                      function.
87:                  
88:                    Remarks:
89:                      See drv_usart.h for usage information.
90:                  */
91:                  
92:                  SYS_MODULE_OBJ DRV_USART_Initialize
93:                  (
94:                      const SYS_MODULE_INDEX drvIndex,
95:                      const SYS_MODULE_INIT * const init
96:                  )
97:                  {
9D0016EC  3084FFFF   ANDI A0, A0, -1
9D001708  27BDFFE0   ADDIU SP, SP, -32
9D00170C  AFBF001C   SW RA, 28(SP)
9D001710  AFB10018   SW S1, 24(SP)
9D001714  AFB00014   SW S0, 20(SP)
9D001718  00A08021   ADDU S0, A1, ZERO
98:                      DRV_USART_OBJ *dObj = (DRV_USART_OBJ*)NULL;
99:                      DRV_USART_INIT *usartInit = NULL ;
100:                 
101:                     /* Check if the specified driver index is in valid range */
102:                     if(drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D0016F0  14800064   BNE A0, ZERO, 0x9D001884
9D0016F4  2402FFFF   ADDIU V0, ZERO, -1
103:                     {
104:                         SYS_DEBUG(0, "Invalid driver index");
105:                         return SYS_MODULE_OBJ_INVALID;
106:                     }
107:                 
108:                     /* Check if this hardware instance was already initialized */
109:                     if(gDrvUSARTObj[drvIndex].inUse != false)
9D0016F8  3C02A000   LUI V0, -24576
9D0016FC  904307C0   LBU V1, 1984(V0)
9D001700  14600060   BNE V1, ZERO, 0x9D001884
9D001704  2402FFFF   ADDIU V0, ZERO, -1
110:                     {
111:                         SYS_DEBUG(0, "Instance already in use");
112:                         return SYS_MODULE_OBJ_INVALID;
113:                     }
114:                 
115:                     /* Assign to the local pointer the init data passed */
116:                     usartInit = ( DRV_USART_INIT * ) init ;
117:                 
118:                     /* Disable the USART module */
119:                     PLIB_USART_Disable (usartInit->usartID) ;
120:                 
121:                     /* Allocate the driver object and set the operation flag to be in use */
122:                     dObj = &gDrvUSARTObj[drvIndex];
123:                     dObj->inUse = true;
9D001728  3C02A000   LUI V0, -24576
9D00172C  245107AC   ADDIU S1, V0, 1964
9D001730  24030001   ADDIU V1, ZERO, 1
9D001734  A2230014   SB V1, 20(S1)
124:                 
125:                     /* Update the USART PLIB Id and other parameters. */
126:                 
127:                     dObj->nClients              = 0;
9D001738  AE200018   SW ZERO, 24(S1)
128:                     dObj->moduleId              = usartInit->usartID;
9D00173C  8CA30004   LW V1, 4(A1)
9D001740  AC4307AC   SW V1, 1964(V0)
129:                     dObj->brgClock              = usartInit->brgClock;
9D001744  8CA20014   LW V0, 20(A1)
9D001748  AE22001C   SW V0, 28(S1)
130:                     dObj->isExclusive           = false;
9D00174C  A2200015   SB ZERO, 21(S1)
131:                     dObj->queueSizeRead         = usartInit->queueSizeReceive;
9D001750  8CA20030   LW V0, 48(A1)
9D001754  AE220034   SW V0, 52(S1)
132:                     dObj->queueSizeWrite        = usartInit->queueSizeTransmit;
9D001758  8CA20034   LW V0, 52(A1)
9D00175C  AE220038   SW V0, 56(S1)
133:                     dObj->dmaChannelRead        = usartInit->dmaChannelReceive;
9D001760  8CA2003C   LW V0, 60(A1)
9D001764  AE220044   SW V0, 68(S1)
134:                     dObj->dmaChannelWrite       = usartInit->dmaChannelTransmit;
9D001768  8CA20038   LW V0, 56(A1)
9D00176C  AE220048   SW V0, 72(S1)
135:                     dObj->txInterruptSource     = usartInit->interruptTransmit;
9D001770  8CA20024   LW V0, 36(A1)
9D001774  AE220024   SW V0, 36(S1)
136:                     dObj->rxInterruptSource     = usartInit->interruptReceive;
9D001778  8CA20028   LW V0, 40(A1)
9D00177C  AE220028   SW V0, 40(S1)
137:                     dObj->errorInterruptSource  = usartInit->interruptError;
9D001780  8CA2002C   LW V0, 44(A1)
9D001784  AE22002C   SW V0, 44(S1)
138:                     dObj->dmaInterruptTransmit  = usartInit->dmaInterruptTransmit;
9D001788  8CA20040   LW V0, 64(A1)
9D00178C  AE22004C   SW V0, 76(S1)
139:                     dObj->dmaInterruptReceive   = usartInit->dmaInterruptReceive;
9D001790  8CA20044   LW V0, 68(A1)
9D001794  AE220050   SW V0, 80(S1)
140:                     dObj->interruptNestingCount = 0;
9D001798  AE200020   SW ZERO, 32(S1)
141:                     dObj->queueSizeCurrentRead  = 0;
9D00179C  AE20003C   SW ZERO, 60(S1)
142:                     dObj->queueSizeCurrentWrite = 0;
9D0017A0  AE200040   SW ZERO, 64(S1)
143:                     dObj->queueRead             = NULL;
9D0017A4  AE200008   SW ZERO, 8(S1)
144:                     dObj->queueWrite            = NULL;
9D0017A8  AE200004   SW ZERO, 4(S1)
145:                     dObj->transmitCallback      = NULL;
9D0017AC  AE200054   SW ZERO, 84(S1)
146:                     dObj->receiveCallback       = NULL;
9D0017B0  AE200058   SW ZERO, 88(S1)
147:                     dObj->errorCallback         = NULL;
9D0017B4  AE20005C   SW ZERO, 92(S1)
148:                     dObj->operationMode         = usartInit->mode;
9D0017B8  8CA20008   LW V0, 8(A1)
9D0017BC  AE220010   SW V0, 16(S1)
149:                 
150:                     /* Setup the Hardware */
151:                     _DRV_USART_HardwareSetup(usartInit->usartID, usartInit ) ;
9D0017C0  0F400548   JAL _DRV_USART_HardwareSetup
9D0017C4  8CA40004   LW A0, 4(A1)
152:                 
153:                     /* Clear the interrupts */
154:                     SYS_INT_SourceStatusClear(dObj->txInterruptSource);
9D0017C8  8E240024   LW A0, 36(S1)
155:                     SYS_INT_SourceStatusClear(dObj->rxInterruptSource);
9D0017EC  8E240028   LW A0, 40(S1)
156:                     SYS_INT_SourceStatusClear(dObj->errorInterruptSource);
9D001804  8E26002C   LW A2, 44(S1)
157:                 
158:                     /* Enable the interrupt source in case of interrupt mode */
159:                     _DRV_USART_InterruptSourceEnable(dObj->errorInterruptSource);
160:                 
161:                     _DRV_USART_ByteModelInterruptSourceEnable(dObj->rxInterruptSource);
162:                 
163:                     /* TODO: Enable DMA interrupts if the DMA channel is selected */
164:                 
165:                     /* Create the hardware instance mutex. */
166:                      if(OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
167:                      {
168:                                  return SYS_MODULE_OBJ_INVALID;
169:                      }
170:                 
171:                     /* Check if the global mutexes have been created. If not
172:                        then create these. */
173:                 
174:                      if(!gDrvUSARTCommonDataObj.membersAreInitialized)
9D001838  93828050   LBU V0, -32688(GP)
9D00183C  54400007   BNEL V0, ZERO, 0x9D00185C
9D001840  8E020004   LW V0, 4(S0)
175:                      {
176:                          /* This means that mutexes where not created. Create them. */
177:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
178:                         {
179:                                  return SYS_MODULE_OBJ_INVALID;
180:                         }
181:                         if(OSAL_MUTEX_Create(&(gDrvUSARTCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
182:                         {
183:                                  return SYS_MODULE_OBJ_INVALID;
184:                         }
185:                          /* Set this flag so that global mutexes get allocated only once */
186:                          gDrvUSARTCommonDataObj.membersAreInitialized = true;
9D001854  A0430000   SB V1, 0(V0)
187:                      }
188:                 
189:                     /* Enable the USART module */
190:                     PLIB_USART_Enable(usartInit->usartID) ;
191:                 
192:                     /* Update the status */
193:                     dObj->status = SYS_STATUS_READY;
9D001864  24030002   ADDIU V1, ZERO, 2
9D001868  3C02A000   LUI V0, -24576
9D00186C  AC4307B8   SW V1, 1976(V0)
194:                 
195:                     /* Return the object structure */
196:                     return ( (SYS_MODULE_OBJ)drvIndex );
9D001870  00001021   ADDU V0, ZERO, ZERO
197:                 }
9D001874  8FBF001C   LW RA, 28(SP)
9D001878  8FB10018   LW S1, 24(SP)
9D00187C  8FB00014   LW S0, 20(SP)
9D001880  27BD0020   ADDIU SP, SP, 32
9D001884  03E00008   JR RA
9D001888  00000000   NOP
198:                 
199:                 // *****************************************************************************
200:                 /* Function:
201:                     void DRV_USART_Deinitialize( SYS_MODULE_OBJ object )
202:                 
203:                   Summary:
204:                     Dynamic implementation of DRV_USART_Deinitialize system interface function.
205:                 
206:                   Description:
207:                     This is the dynamic implementation of DRV_USART_Deinitialize system interface
208:                     function.
209:                 
210:                   Remarks:
211:                     See drv_usart.h for usage information.
212:                 */
213:                 
214:                 void  DRV_USART_Deinitialize(SYS_MODULE_OBJ object)
215:                 {
00000018  00000000   NOP
216:                     DRV_USART_OBJ * dObj;
217:                     DRV_USART_BUFFER_OBJ * iterator;
218:                 
219:                     bool status;
220:                 
221:                     /* Check that the object is valid */
222:                 
223:                     if(object == SYS_MODULE_OBJ_INVALID)
224:                     {
225:                         SYS_DEBUG(0, "Invalid system object handle" );
226:                         return;
227:                     }
228:                 
229:                     if(object >= DRV_USART_INSTANCES_NUMBER)
00000000  00000000   NOP
230:                     {
231:                         SYS_DEBUG(0, "Invalid system object handle" );
232:                         return;
233:                     }
234:                 
235:                     dObj = (DRV_USART_OBJ*) &gDrvUSARTObj[object];
236:                 
237:                     if(!dObj->inUse)
00000008  00000000   NOP
238:                     {
239:                         SYS_DEBUG(0, "Invalid system object handle");
240:                         return;
241:                     }
242:                 
243:                     /* The driver will not have clients when it is
244:                        being deinitialized. So the order in which
245:                        we do the following steps is not that important */
246:                 
247:                     /* Indicate that this object is not is use */
248:                     dObj->inUse = false;
00000028  00000000   NOP
249:                 
250:                     /* Deinitialize the USART status */
251:                     dObj->status =  SYS_STATUS_UNINITIALIZED ;
00000034  00000000   NOP
252:                 
253:                     /* Disable the interrupt */
254:                     status = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource) ;
00000038  00000000   NOP
255:                     status = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource) ;
00000040  00000000   NOP
256:                     status = _DRV_USART_InterruptSourceDisable(dObj->errorInterruptSource);
00000048  00000000   NOP
257:                 
258:                     /* Ignore the warning */
259:                     (void)status;
260:                 
261:                     /* Disable USART module */
262:                     PLIB_USART_Disable (dObj->moduleId);
263:                 
264:                     /* Deallocate all mutexes */
265:                     if(OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
266:                     {
267:                         SYS_DEBUG(0, "Mutex Delete Failed");
268:                         return;
269:                     }
270:                 
271:                     /* TODO: Disable all DMA interrupts */
272:                 
273:                     /* Remove all objects from the read and write queue */
274:                 
275:                     iterator = dObj->queueWrite;
0000005C  00000000   NOP
276:                     while(iterator != NULL)
00000060  00000000   NOP
00000070  00000000   NOP
277:                     {
278:                         /* Return the buffer object to the pool */
279:                         iterator->inUse = false;
00000068  00000000   NOP
280:                         iterator = iterator->next;
0000006C  00000000   NOP
281:                     }
282:                 
283:                     iterator = dObj->queueRead;
00000078  00000000   NOP
284:                     while(iterator != NULL)
00000080  00000000   NOP
00000090  00000000   NOP
285:                     {
286:                         /* Return the buffer object to the pool */
287:                         iterator->inUse = false;
00000088  00000000   NOP
288:                         iterator = iterator->next;
0000008C  00000000   NOP
289:                     }
290:                 }
00000098  00000000   NOP
291:                 
292:                 // *****************************************************************************
293:                 /* Function:
294:                     SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object )
295:                 
296:                   Summary:
297:                     Dynamic implementation of DRV_USART_Status system interface function.
298:                 
299:                   Description:
300:                     This is the dynamic implementation of DRV_USART_Status system interface
301:                     function.
302:                 
303:                   Remarks:
304:                     See drv_usart.h for usage information.
305:                 */
306:                 
307:                 SYS_STATUS DRV_USART_Status( SYS_MODULE_OBJ object)
308:                 {
309:                     /* Check if we have a valid object */
310:                     if(object == SYS_MODULE_OBJ_INVALID)
311:                     {
312:                         SYS_DEBUG(0, "Invalid system object handle");
313:                         return(SYS_STATUS_UNINITIALIZED);
314:                     }
315:                 
316:                     if(object > DRV_USART_INSTANCES_NUMBER)
00000000  00000000   NOP
317:                     {
318:                         SYS_DEBUG(0, "Invalid system object handle");
319:                         return(SYS_STATUS_UNINITIALIZED);
320:                     }
321:                 
322:                     /* Return the system status of the hardware instance object */
323:                     return (gDrvUSARTObj[object].status);
0000000C  00000000   NOP
324:                 }
00000028  00000000   NOP
325:                 
326:                 // *****************************************************************************
327:                 /* Function:
328:                     DRV_HANDLE DRV_USART_Open( const SYS_MODULE_INDEX index,
329:                                                const DRV_IO_INTENT    ioIntent )
330:                 
331:                   Summary:
332:                     Dynamic implementation of DRV_USART_Open client interface function.
333:                 
334:                   Description:
335:                     This is the dynamic implementation of DRV_USART_Open client interface
336:                     function.
337:                 
338:                   Remarks:
339:                     See drv_usart.h for usage information.
340:                 */
341:                 
342:                 DRV_HANDLE DRV_USART_Open
343:                 (
344:                     const SYS_MODULE_INDEX drvIndex,
345:                     const DRV_IO_INTENT ioIntent
346:                 )
347:                 {
9D002190  27BDFFF8   ADDIU SP, SP, -8
9D002194  AFBF0004   SW RA, 4(SP)
9D002198  3084FFFF   ANDI A0, A0, -1
348:                     DRV_USART_CLIENT_OBJ *clientObj;
349:                     DRV_USART_OBJ *dObj;
350:                     unsigned int iClient;
351:                 
352:                     if (drvIndex >= DRV_USART_INSTANCES_NUMBER)
9D00219C  14800044   BNE A0, ZERO, 0x9D0022B0
9D0021A0  2402FFFF   ADDIU V0, ZERO, -1
353:                     {
354:                         /* Invalid driver index */
355:                         SYS_DEBUG(0, "Invalid Driver Instance");
356:                         return (DRV_HANDLE_INVALID);
357:                     }
358:                 
359:                     dObj = &gDrvUSARTObj[drvIndex];
360:                 
361:                     if((dObj->status != SYS_STATUS_READY) || (dObj->inUse == false))
9D0021A4  3C02A000   LUI V0, -24576
9D0021A8  8C4407B8   LW A0, 1976(V0)
9D0021AC  24030002   ADDIU V1, ZERO, 2
9D0021B0  1483003F   BNE A0, V1, 0x9D0022B0
9D0021B4  2402FFFF   ADDIU V0, ZERO, -1
9D0021B8  3C02A000   LUI V0, -24576
9D0021BC  904307C0   LBU V1, 1984(V0)
9D0021C0  1060003B   BEQ V1, ZERO, 0x9D0022B0
9D0021C4  2402FFFF   ADDIU V0, ZERO, -1
362:                     {
363:                         /* The USART module should be ready */
364:                 
365:                         SYS_DEBUG(0, "Was the driver initialized?");
366:                         return DRV_HANDLE_INVALID;
367:                     }
368:                 
369:                     if(dObj->isExclusive)
9D0021C8  3C02A000   LUI V0, -24576
9D0021CC  904307C1   LBU V1, 1985(V0)
9D0021D0  14600037   BNE V1, ZERO, 0x9D0022B0
9D0021D4  2402FFFF   ADDIU V0, ZERO, -1
370:                     {
371:                         /* This means the another client has opened the driver in exclusive
372:                            mode. The driver cannot be opened again */
373:                 
374:                         SYS_DEBUG(0, "Driver already opened exclusively");
375:                         return ( DRV_HANDLE_INVALID ) ;
376:                     }
377:                 
378:                     if((dObj->nClients > 0) && (ioIntent & DRV_IO_INTENT_EXCLUSIVE))
9D0021D8  3C02A000   LUI V0, -24576
9D0021DC  8C4307C4   LW V1, 1988(V0)
9D0021E0  10600005   BEQ V1, ZERO, 0x9D0021F8
9D0021E4  93868051   LBU A2, -32687(GP)
9D0021E8  30A40008   ANDI A0, A1, 8
9D0021EC  14800030   BNE A0, ZERO, 0x9D0022B0
9D0021F0  2402FFFF   ADDIU V0, ZERO, -1
379:                     {
380:                         /* This means the driver was already opened and another driver was
381:                            trying to open it exclusively.  We cannot give exclusive access in
382:                            this case */
383:                 
384:                         SYS_DEBUG(0, "Driver already opened. Cannot be opened exclusively");
385:                         return(DRV_HANDLE_INVALID);
386:                     }
387:                 
388:                     /* Grab client object mutex here */
389:                 
390:                     if(OSAL_MUTEX_Lock(&(gDrvUSARTCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
391:                     {
392:                         /* Enter here only if the lock was obtained (applicable in
393:                            RTOS only). If the mutex lock fails due to time out then
394:                            this code does not get executed */
395:                 
396:                         for(iClient = 0; iClient != DRV_USART_CLIENTS_NUMBER; iClient ++)
397:                         {
398:                             if(!gDrvUSARTClientObj[iClient].inUse)
9D002204  3C02A000   LUI V0, -24576
9D002208  90420768   LBU V0, 1896(V0)
9D00220C  14400026   BNE V0, ZERO, DRV_USART_Open::OSAL_MUTEX_Unlock
9D002210  24020001   ADDIU V0, ZERO, 1
399:                             {
400:                                 /* This means we have a free client object to use */
401:                                 clientObj = &gDrvUSARTClientObj[iClient];
402:                                 clientObj->inUse        = true;
9D002214  3C04A000   LUI A0, -24576
9D002218  24820760   ADDIU V0, A0, 1888
9D00221C  24060001   ADDIU A2, ZERO, 1
9D002220  A0460008   SB A2, 8(V0)
403:                 
404:                                 /* We have found a client object. Release the mutex */
405:                 
406:                                 OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
407:                 
408:                                 clientObj->hDriver      = dObj;
9D002228  3C06A000   LUI A2, -24576
9D00222C  24C607AC   ADDIU A2, A2, 1964
9D002230  AC860760   SW A2, 1888(A0)
409:                 
410:                                 /* In a case where the driver is configured for polled
411:                                    and bare metal operation, it will not support blocking operation */
412:                 
413:                                 clientObj->ioIntent     = (ioIntent | _DRV_USART_ALWAYS_NON_BLOCKING);
9D002234  AC450004   SW A1, 4(V0)
414:                                 clientObj->eventHandler = NULL;
9D002238  AC400038   SW ZERO, 56(V0)
415:                                 clientObj->context      = (uintptr_t)NULL;
9D00223C  AC400044   SW ZERO, 68(V0)
416:                                 clientObj->error        = DRV_USART_ERROR_NONE;
417:                 
418:                                 if(ioIntent & DRV_IO_INTENT_EXCLUSIVE)
9D002240  30A50008   ANDI A1, A1, 8
9D002244  10A00004   BEQ A1, ZERO, 0x9D002258
9D002248  AC40003C   SW ZERO, 60(V0)
419:                                 {
420:                                     /* Set the driver exclusive flag */
421:                                     dObj->isExclusive = true;
9D00224C  24040001   ADDIU A0, ZERO, 1
9D002250  3C02A000   LUI V0, -24576
9D002254  A04407C1   SB A0, 1985(V0)
422:                                 }
423:                 
424:                                 dObj->nClients ++;
9D002258  24630001   ADDIU V1, V1, 1
9D00225C  3C02A000   LUI V0, -24576
9D002260  AC4307C4   SW V1, 1988(V0)
425:                 
426:                                 /* Create the semaphores */
427:                                 if(OSAL_SEM_Create(&(clientObj->semReadDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
428:                                 {
429:                                         SYS_DEBUG(0, "Semaphore creation failed");
430:                                         return(DRV_HANDLE_INVALID);
431:                                 }
432:                                 if(OSAL_SEM_Create(&(clientObj->semWriteDone), OSAL_SEM_TYPE_COUNTING, 1, 0) != OSAL_RESULT_TRUE)
433:                                 {
434:                                         SYS_DEBUG(0, "Semaphore creation failed");
435:                                         return(DRV_HANDLE_INVALID);
436:                                 }
437:                                 /* Update the client status */
438:                                 clientObj->status = DRV_USART_CLIENT_STATUS_READY;
9D002294  3C02A000   LUI V0, -24576
9D002298  24420760   ADDIU V0, V0, 1888
9D00229C  24030002   ADDIU V1, ZERO, 2
439:                                 return ((DRV_HANDLE) clientObj );
9D0022A0  0B4008AC   J 0x9D0022B0
9D0022A4  AC430040   SW V1, 64(V0)
440:                             }
441:                         }
442:                 
443:                         /* Could not find a client object. Release the mutex and
444:                            return with an invalid handle. */
445:                         OSAL_MUTEX_Unlock(&(gDrvUSARTCommonDataObj.mutexClientObjects));
446:                     }
447:                 
448:                     /* If we have reached here, it means either we could not find a spare
449:                        client object or the mutex timed out in a RTOS environment. */
450:                 
451:                     return DRV_HANDLE_INVALID;
9D0022AC  2402FFFF   ADDIU V0, ZERO, -1
452:                 }
9D0022B0  8FBF0004   LW RA, 4(SP)
9D0022B4  03E00008   JR RA
9D0022B8  27BD0008   ADDIU SP, SP, 8
453:                 
454:                 // *****************************************************************************
455:                 /* Function:
456:                     DRV_CLIENT_STATUS DRV_USART_Close ( DRV_HANDLE handle)
457:                 
458:                   Summary:
459:                     Dynamic implementation of DRV_USART_Close client interface function.
460:                 
461:                   Description:
462:                     This is the dynamic implementation of DRV_USART_Close client interface
463:                     function.
464:                 
465:                   Remarks:
466:                     See drv_usart.h for usage information.
467:                 */
468:                 
469:                 void DRV_USART_Close ( DRV_HANDLE handle)
470:                 {
00000000  00000000   NOP
471:                     /* This function closes the client, The client
472:                        object is deallocated and returned to the
473:                        pool. */
474:                 
475:                     DRV_USART_CLIENT_OBJ * clientObj;
476:                     DRV_USART_OBJ * dObj;
477:                 
478:                     /* Validate the handle */
479:                     clientObj = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
480:                 
481:                     if(clientObj == NULL)
00000010  00000000   NOP
482:                     {
483:                         /* Driver handle is not valid */
484:                         SYS_DEBUG(0, "Invalid Driver Handle");
485:                         return;
486:                     }
487:                 
488:                     dObj = (DRV_USART_OBJ *)clientObj->hDriver;
00000018  00000000   NOP
489:                 
490:                     /* Remove all buffers that this client owns from the driver queue. This
491:                        function will map to _DRV_USART_ClientBufferQueueObjectsRemove() if the
492:                        driver was built for buffer queue support. Else this condition always
493:                        maps to true. */
494:                 
495:                     if(!_DRV_USART_CLIENT_BUFFER_QUEUE_OBJECTS_REMOVE(clientObj))
496:                     {
497:                         /* The function could fail if the mutex time out occurred */
498:                         SYS_DEBUG(0, "Could not remove client buffer objects");
499:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
500:                         return;
501:                     }
502:                 
503:                     /* Deallocate all semaphores */
504:                     if(OSAL_SEM_Delete(&(clientObj->semWriteDone)) != OSAL_RESULT_TRUE)
505:                     {
506:                         SYS_DEBUG(0, "Unable to delete client write done semaphore");
507:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
508:                         return;
509:                     }
510:                     if(OSAL_SEM_Delete(&(clientObj->semReadDone)) != OSAL_RESULT_TRUE)
511:                     {
512:                         SYS_DEBUG(0, "Unable to delete client read done semaphore");
513:                         clientObj->status = DRV_USART_CLIENT_STATUS_ERROR;
514:                         return;
515:                     }
516:                     /* Reduce the number of clients */
517:                     dObj->nClients --;
0000001C  00000000   NOP
518:                 
519:                     /* Reset the exclusive flag */
520:                     dObj->isExclusive = false;
00000028  00000000   NOP
521:                 
522:                     /* De-allocate the object */
523:                     clientObj->status = DRV_USART_CLIENT_STATUS_CLOSED;
0000002C  00000000   NOP
524:                     clientObj->inUse = false;
00000030  00000000   NOP
525:                 
526:                     return;
527:                 }
00000034  00000000   NOP
528:                 
529:                 // *****************************************************************************
530:                 /* Function:
531:                     void DRV_USART_ByteTransmitCallbackSet
532:                     (
533:                         const SYS_MODULE_INDEX index,
534:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
535:                     )
536:                 
537:                   Summary:
538:                     Registers transmit callback function.
539:                 
540:                   Description:
541:                     This function is used to register the callback function to be invoked
542:                     upon transmission of a byte.
543:                 
544:                   Remarks:
545:                     See drv_usart.h for usage information.
546:                 */
547:                 
548:                 void DRV_USART_ByteTransmitCallbackSet
549:                 (
550:                     const SYS_MODULE_INDEX index,
551:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
552:                 )
553:                 {
00000000  00000000   NOP
554:                     if (index >= DRV_USART_INSTANCES_NUMBER)
00000004  00000000   NOP
555:                     {
556:                         /* Invalid driver index */
557:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
558:                     }
559:                     else
560:                     {
561:                         gDrvUSARTObj[index].transmitCallback = eventHandler;
0000000C  00000000   NOP
562:                     }
563:                 }
564:                 
565:                 // *****************************************************************************
566:                 /* Function:
567:                     void DRV_USART_ByteReceiveCallbackSet
568:                     (
569:                         const SYS_MODULE_INDEX index,
570:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
571:                     )
572:                 
573:                   Summary:
574:                     Registers receive callback function.
575:                 
576:                   Description:
577:                     This function is used to register the callback function to be invoked
578:                     upon reception of a byte.
579:                 
580:                   Remarks:
581:                     See drv_usart.h for usage information.
582:                 */
583:                 
584:                 void DRV_USART_ByteReceiveCallbackSet
585:                 (
586:                     const SYS_MODULE_INDEX index,
587:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
588:                 )
589:                 {
00000000  00000000   NOP
590:                     if (index >= DRV_USART_INSTANCES_NUMBER)
00000004  00000000   NOP
591:                     {
592:                         /* Invalid driver index */
593:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
594:                     }
595:                     else
596:                     {
597:                         gDrvUSARTObj[index].receiveCallback = eventHandler;
0000000C  00000000   NOP
598:                     }
599:                 }
600:                 
601:                 // *****************************************************************************
602:                 /* Function:
603:                     void DRV_USART_ByteErrorCallbackSet
604:                     (
605:                         const SYS_MODULE_INDEX index,
606:                         const DRV_USART_BYTE_EVENT_HANDLER eventHandler
607:                     )
608:                 
609:                   Summary:
610:                     Registers error notification callback function.
611:                 
612:                   Description:
613:                     This function is used to register the callback function to be invoked
614:                     to notify error on the tx or the rx path in byte model of operation.
615:                 
616:                   Remarks:
617:                     See drv_usart.h for usage information.
618:                 */
619:                 
620:                 void DRV_USART_ByteErrorCallbackSet
621:                 (
622:                     const SYS_MODULE_INDEX index,
623:                     const DRV_USART_BYTE_EVENT_HANDLER eventHandler
624:                 )
625:                 {
00000000  00000000   NOP
626:                     if (index >= DRV_USART_INSTANCES_NUMBER)
00000004  00000000   NOP
627:                     {
628:                         /* Invalid driver index */
629:                         SYS_DEBUG(0, "\r\nUSART Driver: Invalid Driver Instance");
630:                     }
631:                     else
632:                     {
633:                         gDrvUSARTObj[index].errorCallback = eventHandler;
0000000C  00000000   NOP
634:                     }
635:                 }
636:                 
637:                 
638:                 // *****************************************************************************
639:                 /* Function:
640:                     DRV_USART_ERROR DRV_USART_ErrorGet( DRV_HANDLE hClient )
641:                 
642:                   Summary:
643:                     Dynamic implementation of DRV_USART_ErrorGet client interface function.
644:                 
645:                   Description:
646:                     This is the dynamic implementation of DRV_USART_ErrorGet client interface
647:                     function.
648:                 
649:                   Remarks:
650:                     See drv_usart.h for usage information.
651:                 */
652:                 
653:                 DRV_USART_ERROR DRV_USART_ErrorGet(DRV_HANDLE hClient)
654:                 {
00000000  00000000   NOP
655:                     DRV_USART_CLIENT_OBJ * clientObj;
656:                     DRV_USART_ERROR error;
657:                 
658:                     /* Validate the handle */
659:                     clientObj = _DRV_USART_DriverHandleValidate(hClient);
00000008  00000000   NOP
660:                 
661:                     if(clientObj == NULL)
00000010  00000000   NOP
662:                     {
663:                         /* Driver handle is not valid. Return error */
664:                         SYS_DEBUG(0, "Invalid client handle");
665:                         return DRV_USART_BAUD_SET_ERROR;
666:                     }
667:                 
668:                     /* Return the error. Clear the error before
669:                        returning. */
670:                 
671:                     error = clientObj->error;
00000018  00000000   NOP
672:                     clientObj->error = DRV_USART_ERROR_NONE;
0000001C  00000000   NOP
673:                     return(error);
674:                 }
00000024  00000000   NOP
675:                 
676:                 // *****************************************************************************
677:                 /* Function:
678:                     DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
679:                 
680:                   Summary:
681:                     Dynamic implementation of DRV_USART_BaudSet client interface function.
682:                 
683:                   Description:
684:                     This is the dynamic implementation of DRV_USART_BaudSet client interface
685:                     function.
686:                 
687:                   Remarks:
688:                     See drv_usart.h for usage information.
689:                 */
690:                 
691:                 DRV_USART_BAUD_SET_RESULT DRV_USART_BaudSet(DRV_HANDLE handle, uint32_t baud)
692:                 {
00000000  00000000   NOP
693:                     DRV_USART_OBJ * hDriver;
694:                     DRV_USART_CLIENT_OBJ * client;
695:                     USART_MODULE_ID plibID;
696:                     DRV_USART_BAUD_SET_RESULT retVal = DRV_USART_BAUD_SET_SUCCESS;
00000088  00000000   NOP
000000D0  00000000   NOP
697:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
698:                     bool isEnabled = false;
699:                 #endif
700:                 
701:                     /* Validate the handle */
702:                     client = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
703:                 
704:                     if(client == NULL)
00000014  00000000   NOP
705:                     {
706:                         /* Driver handle is not valid. Return error */
707:                         SYS_DEBUG(0, "Invalid client handle");
708:                         return DRV_USART_BAUD_SET_ERROR;
000000E0  00000000   NOP
709:                     }
710:                 
711:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
0000001C  00000000   NOP
712:                     plibID = hDriver->moduleId;
00000020  00000000   NOP
713:                 
714:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
715:                     {
716:                         int32_t brgValueLow=0;
717:                         int32_t brgValueHigh=0;
718:                 
719:                         brgValueLow  = ( (hDriver->brgClock/baud) >> 4 ) - 1;
00000034  00000000   NOP
00000090  00000000   NOP
720:                         brgValueHigh = ( (hDriver->brgClock/baud) >> 2 ) - 1;
00000044  00000000   NOP
721:                 
722:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
723:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
724:                         if (isEnabled)
725:                         {
726:                             PLIB_USART_Disable (plibID);
727:                             while (PLIB_USART_ModuleIsBusy (plibID));
728:                         }
729:                 #endif
730:                         /* Check if the baud value can be set with high baud settings */
731:                         if ((brgValueHigh >= 0) && (brgValueHigh <= UINT16_MAX))
0000004C  00000000   NOP
732:                         {
733:                             PLIB_USART_BaudRateHighEnable(plibID);
734:                             PLIB_USART_BaudRateHighSet(plibID, hDriver->brgClock, baud);
735:                         }
736:                         /* Check if the baud value can be set with low baud settings */
737:                         else if ((brgValueLow >= 0) && (brgValueLow <= UINT16_MAX))
00000094  00000000   NOP
738:                         {
739:                             PLIB_USART_BaudRateHighDisable(plibID);
740:                             PLIB_USART_BaudRateSet(plibID, hDriver->brgClock, baud);
741:                         }
742:                         else
743:                         {
744:                             retVal = DRV_USART_BAUD_SET_ERROR;
745:                         }
746:                 
747:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
748:                         if (isEnabled)
749:                         {
750:                             PLIB_USART_Enable (plibID);
751:                         }
752:                 #endif
753:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
754:                     }
755:                     else
756:                     {
757:                         /* The mutex timed out */
758:                         SYS_DEBUG(0, "Hardware instance mutex time out in DRV_USART_BaudSet() function");
759:                         retVal = DRV_USART_BAUD_SET_ERROR;
760:                     }
761:                 
762:                     return retVal;
763:                 }
000000E4  00000000   NOP
764:                 
765:                 // *****************************************************************************
766:                 /* Function:
767:                     DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
768:                     (
769:                         DRV_HANDLE handle,
770:                         DRV_USART_LINE_CONTROL lineControlMode
771:                     )
772:                 
773:                   Summary:
774:                     Dynamic implementation of DRV_USART_LineControlSet client interface function.
775:                 
776:                   Description:
777:                     This is the dynamic implementation of DRV_USART_LineControlSet client
778:                     interface function.
779:                 
780:                   Remarks:
781:                     See drv_usart.h for usage information.
782:                 */
783:                 
784:                 DRV_USART_LINE_CONTROL_SET_RESULT DRV_USART_LineControlSet
785:                 (
786:                     DRV_HANDLE handle,
787:                     DRV_USART_LINE_CONTROL lineControlMode
788:                 )
789:                 {
00000000  00000000   NOP
790:                     DRV_USART_OBJ * hDriver;
791:                     DRV_USART_CLIENT_OBJ * client;
792:                     USART_MODULE_ID plibID;
793:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
794:                     bool isEnabled = false;
795:                 #endif
796:                 
797:                     /* Validate the driver handle */
798:                     client = _DRV_USART_DriverHandleValidate(handle);
0000000C  00000000   NOP
799:                 
800:                     if(client == NULL)
00000014  00000000   NOP
801:                     {
802:                         /* Driver handle is not valid. Return error */
803:                 
804:                         SYS_DEBUG(0, "Invalid driver handle");
805:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
00000070  00000000   NOP
806:                     }
807:                 
808:                     hDriver = (DRV_USART_OBJ*)client->hDriver;
0000001C  00000000   NOP
809:                     plibID = hDriver->moduleId;
00000020  00000000   NOP
810:                 
811:                     if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
812:                     {
813:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
814:                         isEnabled = PLIB_USART_ModuleIsBusy (plibID);
815:                         if (isEnabled)
816:                         {
817:                             PLIB_USART_Disable (plibID);
818:                             while (PLIB_USART_ModuleIsBusy (plibID));
819:                         }
820:                 #endif
821:                         /* Set the Line Control Mode */
822:                         PLIB_USART_LineControlModeSelect(plibID, lineControlMode);
823:                 #if defined (PLIB_USART_ExistsModuleBusyStatus)
824:                         if (isEnabled)
825:                         {
826:                             PLIB_USART_Enable (plibID);
827:                         }
828:                 #endif
829:                         OSAL_MUTEX_Unlock(&(hDriver->mutexDriverInstance));
830:                     }
831:                     else
832:                     {
833:                         SYS_DEBUG(0, "Hardware Instance Mutex time out in DRV_USART_LineControlSet() function");
834:                         return DRV_USART_LINE_CONTROL_SET_ERROR;
835:                     }
836:                 
837:                     /* Return success */
838:                     return(DRV_USART_LINE_CONTROL_SET_SUCCESS);
00000068  00000000   NOP
839:                 }
00000074  00000000   NOP
840:                 
841:                 // *****************************************************************************
842:                 /* Function:
843:                     void DRV_USART_TasksTransmit (SYS_MODULE_OBJ object )
844:                 
845:                   Summary:
846:                     Dynamic implementation of DRV_USART_TasksTransmit system interface function.
847:                 
848:                   Description:
849:                     This is the dynamic implementation of DRV_USART_TasksTransmit system interface
850:                     function.
851:                 
852:                   Remarks:
853:                     See drv_usart.h for usage information.
854:                 */
855:                 
856:                 void DRV_USART_TasksTransmit(SYS_MODULE_OBJ object)
857:                 {
9D002C4C  27BDFFE8   ADDIU SP, SP, -24
9D002C50  AFBF0014   SW RA, 20(SP)
9D002C54  AFB00010   SW S0, 16(SP)
858:                     /* This is the USART Driver Transmit tasks routine.
859:                        In this function, the driver checks if a transmit
860:                        interrupt is active and if there are any buffers in
861:                        queue. If so the buffer is serviced. A buffer that
862:                        is serviced completely is removed from the queue.
863:                      */
864:                 
865:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D002C58  00041140   SLL V0, A0, 5
9D002C5C  000481C0   SLL S0, A0, 7
9D002C60  02021023   SUBU V0, S0, V0
9D002C64  3C10A000   LUI S0, -24576
9D002C68  261007AC   ADDIU S0, S0, 1964
9D002C6C  02028021   ADDU S0, S0, V0
866:                 
867:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D002C70  92020014   LBU V0, 20(S0)
9D002C74  1040001A   BEQ V0, ZERO, 0x9D002CE0
9D002C78  24020002   ADDIU V0, ZERO, 2
9D002C7C  8E03000C   LW V1, 12(S0)
9D002C80  14620018   BNE V1, V0, 0x9D002CE4
9D002C84  8FBF0014   LW RA, 20(SP)
868:                     {
869:                         /* This instance of the driver is not initialized. Don't
870:                          * do anything */
871:                         return;
872:                     }
873:                 
874:                     if(SYS_INT_SourceStatusGet(hDriver->txInterruptSource))
9D002C88  8E020024   LW V0, 36(S0)
9D002CAC  5040000E   BEQL V0, ZERO, 0x9D002CE8
9D002CB0  8FB00010   LW S0, 16(SP)
875:                     {
876:                         /* The USART driver is configured to generate an
877:                            interrupt when the FIFO is empty. Additionally
878:                            the queue is not empty. Which means there is
879:                            work to done in this routine. */
880:                 
881:                         _DRV_USART_TRANSMIT_BUFFER_QUEUE_TASKS(object);
9D002CB4  0F400BFF   JAL _DRV_USART_ByteTransmitTasks
9D002CB8  00000000   NOP
882:                 
883:                         /* Clear up the interrupt flag */
884:                         SYS_INT_SourceStatusClear(hDriver->txInterruptSource);
9D002CBC  8E020024   LW V0, 36(S0)
885:                     }
886:                 }
9D002CE0  8FBF0014   LW RA, 20(SP)
9D002CE4  8FB00010   LW S0, 16(SP)
9D002CE8  03E00008   JR RA
9D002CEC  27BD0018   ADDIU SP, SP, 24
887:                 
888:                 
889:                 // *****************************************************************************
890:                 /* Function:
891:                     void DRV_USART_TasksError (SYS_MODULE_OBJ object );
892:                 
893:                   Summary:
894:                     Maintains the driver's error state machine and implements its ISR
895:                 
896:                   Description:
897:                     This routine is used to maintain the driver's internal error state machine
898:                     and implement its error ISR for interrupt-driven implementations.  In
899:                     polling mode, this function should be called from the SYS_Tasks function.
900:                     In interrupt mode, this function should be called in the error interrupt
901:                     service routine of the USART that is associated with this USART driver
902:                     hardware instance.
903:                 
904:                   Remarks:
905:                     Refer to drv_usart.h for usage information.
906:                 */
907:                 
908:                 void DRV_USART_TasksError(SYS_MODULE_OBJ object)
909:                 {
9D002A38  27BDFFE8   ADDIU SP, SP, -24
9D002A3C  AFBF0014   SW RA, 20(SP)
9D002A40  AFB00010   SW S0, 16(SP)
910:                     /* This is the USART Driver Error tasks routine. In this function, the
911:                      * driver checks if an error interrupt has occurred. If so the error
912:                      * condition is cleared.  */
913:                 
914:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D002A44  00041140   SLL V0, A0, 5
9D002A48  000481C0   SLL S0, A0, 7
9D002A4C  02021023   SUBU V0, S0, V0
9D002A50  3C10A000   LUI S0, -24576
9D002A54  261007AC   ADDIU S0, S0, 1964
9D002A58  02028021   ADDU S0, S0, V0
915:                 
916:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D002A5C  92020014   LBU V0, 20(S0)
9D002A60  10400020   BEQ V0, ZERO, 0x9D002AE4
9D002A64  24020002   ADDIU V0, ZERO, 2
9D002A68  8E03000C   LW V1, 12(S0)
9D002A6C  5462001E   BNEL V1, V0, 0x9D002AE8
9D002A70  8FBF0014   LW RA, 20(SP)
917:                     {
918:                         /* This instance of the driver is not initialized. Don't
919:                          * do anything */
920:                         return;
921:                     }
922:                 
923:                     if(SYS_INT_SourceStatusGet(hDriver->errorInterruptSource))
9D002A74  8E02002C   LW V0, 44(S0)
9D002A98  10400013   BEQ V0, ZERO, 0x9D002AE8
9D002A9C  8FBF0014   LW RA, 20(SP)
924:                     {
925:                         /* This means an error has occurred */
926:                 
927:                         if(PLIB_USART_ReceiverOverrunHasOccurred(hDriver->moduleId))
9D002AAC  10600002   BEQ V1, ZERO, 0x9D002AB8
9D002AB0  24030002   ADDIU V1, ZERO, 2
928:                         {
929:                             PLIB_USART_ReceiverOverrunErrorClear(hDriver->moduleId);
930:                         }
931:                 
932:                         _DRV_USART_ERROR_TASKS(object);
9D002AB8  0F400C5F   JAL _DRV_USART_ByteErrorTasks
9D002ABC  00000000   NOP
933:                 
934:                         /* Clear up the error interrupt flag */
935:                         SYS_INT_SourceStatusClear(hDriver->errorInterruptSource);
9D002AC0  8E02002C   LW V0, 44(S0)
936:                     }
937:                 }
9D002AE4  8FBF0014   LW RA, 20(SP)
9D002AE8  8FB00010   LW S0, 16(SP)
9D002AEC  03E00008   JR RA
9D002AF0  27BD0018   ADDIU SP, SP, 24
938:                 
939:                 // *****************************************************************************
940:                 /* Function:
941:                     DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus (DRV_HANDLE handle )
942:                 
943:                   Summary:
944:                     Dynamic implementation of DRV_USART_ClientStatus client interface function.
945:                 
946:                   Description:
947:                     This is the dynamic implementation of DRV_USART_ClientStatus client interface
948:                     function.
949:                 
950:                   Remarks:
951:                     See drv_usart.h for usage information.
952:                 */
953:                 
954:                 DRV_USART_CLIENT_STATUS DRV_USART_ClientStatus(DRV_HANDLE handle)
955:                 {
00000000  00000000   NOP
956:                     DRV_USART_CLIENT_OBJ * client;
957:                 
958:                     /* Validate the driver handle */
959:                     client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
960:                 
961:                     if(client == NULL)
00000010  00000000   NOP
962:                     {
963:                         /* Driver handle is not valid */
964:                 
965:                         SYS_DEBUG(0, "Invalid driver handle");
966:                         return DRV_USART_CLIENT_STATUS_CLOSED;
967:                     }
968:                 
969:                     /* Return the client status */
970:                     return(client->status);
971:                 }
0000001C  00000000   NOP
972:                 
973:                 // *****************************************************************************
974:                 /* Function:
975:                     void DRV_USART_TasksReceive (SYS_MODULE_OBJ object )
976:                 
977:                   Summary:
978:                     Dynamic implementation of DRV_USART_Initialize system interface function.
979:                 
980:                   Description:
981:                     This is the dynamic implementation of DRV_USART_Initialize system interface
982:                     function.
983:                 
984:                   Remarks:
985:                     See drv_usart.h for usage information.
986:                 */
987:                 
988:                 void DRV_USART_TasksReceive(SYS_MODULE_OBJ object)
989:                 {
9D002CF0  27BDFFE8   ADDIU SP, SP, -24
9D002CF4  AFBF0014   SW RA, 20(SP)
9D002CF8  AFB00010   SW S0, 16(SP)
990:                     /* This is the USART Driver Receive tasks routine. If the receive
991:                        interrupt flag is set, the tasks routines are executed.
992:                      */
993:                 
994:                     DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D002CFC  00041140   SLL V0, A0, 5
9D002D00  000481C0   SLL S0, A0, 7
9D002D04  02021023   SUBU V0, S0, V0
9D002D08  3C10A000   LUI S0, -24576
9D002D0C  261007AC   ADDIU S0, S0, 1964
9D002D10  02028021   ADDU S0, S0, V0
995:                 
996:                     if((!hDriver->inUse) || (hDriver->status != SYS_STATUS_READY))
9D002D14  92020014   LBU V0, 20(S0)
9D002D18  1040001A   BEQ V0, ZERO, 0x9D002D84
9D002D1C  24020002   ADDIU V0, ZERO, 2
9D002D20  8E03000C   LW V1, 12(S0)
9D002D24  14620018   BNE V1, V0, 0x9D002D88
9D002D28  8FBF0014   LW RA, 20(SP)
997:                     {
998:                         /* This instance of the driver is not initialized. Dont
999:                            do anything */
1000:                
1001:                        return;
1002:                    }
1003:                
1004:                    if(SYS_INT_SourceStatusGet(hDriver->rxInterruptSource))
9D002D2C  8E020028   LW V0, 40(S0)
9D002D50  5040000E   BEQL V0, ZERO, 0x9D002D8C
9D002D54  8FB00010   LW S0, 16(SP)
1005:                    {
1006:                        _DRV_USART_RECEIVE_BUFFER_QUEUE_TASKS(object);
9D002D58  0F400C43   JAL _DRV_USART_ByteReceiveTasks
9D002D5C  00000000   NOP
1007:                
1008:                        /* Clear up the interrupt flag */
1009:                        SYS_INT_SourceStatusClear(hDriver->rxInterruptSource);
9D002D60  8E020028   LW V0, 40(S0)
1010:                    }
1011:                }
9D002D84  8FBF0014   LW RA, 20(SP)
9D002D88  8FB00010   LW S0, 16(SP)
9D002D8C  03E00008   JR RA
9D002D90  27BD0018   ADDIU SP, SP, 24
1012:                
1013:                // *****************************************************************************
1014:                /* Function:
1015:                    DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1016:                
1017:                  Summary:
1018:                    Dynamic implementation of DRV_USART_TransferStatus client interface function.
1019:                
1020:                  Description:
1021:                    This is the dynamic implementation of DRV_USART_TransferStatus client
1022:                    interface function.
1023:                
1024:                  Remarks:
1025:                    See drv_usart.h for usage information.
1026:                */
1027:                
1028:                DRV_USART_TRANSFER_STATUS DRV_USART_TransferStatus(const DRV_HANDLE handle)
1029:                {
00000000  00000000   NOP
1030:                    DRV_USART_CLIENT_OBJ * client;
1031:                    DRV_USART_OBJ * hDriver;
1032:                    DRV_USART_TRANSFER_STATUS result = 0;
1033:                
1034:                    client = _DRV_USART_DriverHandleValidate(handle);
00000008  00000000   NOP
1035:                
1036:                    /* Validate the handle */
1037:                    if(client == NULL)
00000010  00000000   NOP
1038:                    {
1039:                        SYS_DEBUG(0, "Invalid Driver handle");
1040:                        return 0;
1041:                    }
1042:                
1043:                    hDriver = client->hDriver;
1044:                
1045:                    /* If the Rx interrupt flag is set then there is data available
1046:                       else there isn't */
1047:                    result |= (PLIB_USART_ReceiverDataIsAvailable(hDriver->moduleId)) ?
00000018  00000000   NOP
00000028  00000000   NOP
1048:                        DRV_USART_TRANSFER_STATUS_RECEIVER_DATA_PRESENT : DRV_USART_TRANSFER_STATUS_RECEIVER_EMPTY;
1049:                
1050:                    /* If the TX interrupt flag is set, then the Tx Buffer is empty */
1051:                    result |= (PLIB_USART_TransmitterIsEmpty(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_EMPTY : 0;
00000040  00000000   NOP
1052:                
1053:                    /* Check if the TX buffer is full */
1054:                    result |= (PLIB_USART_TransmitterBufferIsFull(hDriver->moduleId)) ? DRV_USART_TRANSFER_STATUS_TRANSMIT_FULL : 0;
00000054  00000000   NOP
1055:                
1056:                    return(result);
1057:                }
00000060  00000000   NOP
1058:                
1059:                // *****************************************************************************
1060:                // *****************************************************************************
1061:                // Section: File scope functions
1062:                // *****************************************************************************
1063:                // *****************************************************************************
1064:                
1065:                // *****************************************************************************
1066:                /* void _DRV_USART_HardwareSetup
1067:                   (
1068:                        USART_MODULE_ID  plibID,
1069:                        DRV_USART_INIT * init
1070:                   )
1071:                
1072:                  Summary:
1073:                    Initializes the USART module based on the init data structure.
1074:                
1075:                  Description:
1076:                    This function initializes the USART module based on the init data structure.
1077:                
1078:                  Remarks:
1079:                    This is a private function and should not be called directly by the
1080:                    application.
1081:                */
1082:                
1083:                void _DRV_USART_HardwareSetup(USART_MODULE_ID plibID, DRV_USART_INIT * init)
1084:                {
1085:                    bool loopbackMode   = false;
9D001598  0B40056B   J 0x9D0015AC
9D00159C  00001021   ADDU V0, ZERO, ZERO
1086:                    bool irdaMode       = false;
9D001594  00004021   ADDU T0, ZERO, ZERO
9D0015A4  00004021   ADDU T0, ZERO, ZERO
1087:                    bool wakeFromSleep  = false;
1088:                    bool stopInIdle     = false;
1089:                    bool autoBaud       = false;
1090:                
1091:                    /* Default is to use UxTX and UxRX only */
1092:                    USART_OPERATION_MODE handshakeLines = USART_ENABLE_TX_RX_USED;
9D001538  0002380B   MOVN A3, ZERO, V0
9D00153C  2C480001   SLTIU T0, V0, 1
9D001540  00001821   ADDU V1, ZERO, ZERO
9D001544  0002180A   MOVZ V1, ZERO, V0
9D001548  0B40056B   J 0x9D0015AC
9D00154C  00601021   ADDU V0, V1, ZERO
9D001590  00003821   ADDU A3, ZERO, ZERO
9D0015A0  00003821   ADDU A3, ZERO, ZERO
1093:                
1094:                    /* Check the operational mode and update the relevant flags */
1095:                    switch(init->mode)
9D001520  8CA20008   LW V0, 8(A1)
9D001524  24030002   ADDIU V1, ZERO, 2
9D001528  10430009   BEQ V0, V1, _DRV_USART_HardwareSetup::PLIB_USART_ReceiverAddressDetectEnable
9D00152C  24030003   ADDIU V1, ZERO, 3
9D001530  1043001B   BEQ V0, V1, 0x9D0015A0
9D001534  24070003   ADDIU A3, ZERO, 3
1096:                    {
1097:                        case DRV_USART_OPERATION_MODE_ADDRESSED:
1098:                        {
1099:                            PLIB_USART_ReceiverAddressDetectEnable(plibID);
1100:                            PLIB_USART_AddressSet(plibID, init->modeData.AddressedModeInit.address);
9D001558  90A3000C   LBU V1, 12(A1)
1101:                #if defined (PLIB_USART_ExistsReceiverAddressAutoDetect)
1102:                            PLIB_USART_ReceiverAddressAutoDetectEnable(plibID, PLIB_USART_AddressGet(plibID));
1103:                #endif
1104:                        }
1105:                        break;
1106:                        case DRV_USART_OPERATION_MODE_IRDA:
1107:                            irdaMode = true;
1108:                            handshakeLines = USART_ENABLE_TX_RX_BCLK_USED;
1109:                            break;
1110:                        case DRV_USART_OPERATION_MODE_LOOPBACK:
1111:                            loopbackMode = true;
9D0015A8  24020001   ADDIU V0, ZERO, 1
1112:                            break;
1113:                        default:
1114:                            break;
1115:                    }
1116:                
1117:                    /* Handshaking */
1118:                    if(init->handshake != DRV_USART_HANDSHAKE_NONE)
9D0015AC  8CA30020   LW V1, 32(A1)
9D0015B0  24060002   ADDIU A2, ZERO, 2
9D0015B4  50660006   BEQL V1, A2, 0x9D0015D0
9D0015B8  8CA30010   LW V1, 16(A1)
1119:                    {
1120:                        /* Note that this mode is exclusive of DRV_USART_OPERATION_MODE_IRDA.
1121:                           In that if the driver must be set up to use DRV_USART_OPERATION_MODE_IRDA
1122:                           then handshake parameter of the init data structure must be
1123:                           DRV_USART_HANDSHAKE_NONE. Setting up the driver to use Simplex or
1124:                           flow control will over ride the requirements of the IRDA mode.*/
1125:                
1126:                        handshakeLines = USART_ENABLE_TX_RX_CTS_RTS_USED;
9D0015C8  24070002   ADDIU A3, ZERO, 2
1127:                
1128:                        /* Set the handshake mode to either simplex or flow control */
1129:                
1130:                        PLIB_USART_HandshakeModeSelect(plibID, init->handshake);
1131:                    }
1132:                
1133:                
1134:                    /* Wake up the part from sleep on any activity on the RX Line */
1135:                    wakeFromSleep = (init->flags & DRV_USART_INIT_FLAG_WAKE_ON_START);
9D0015CC  8CA30010   LW V1, 16(A1)
1136:                
1137:                    /* When the CPU enters IDLE mode, stop the USART */
1138:                    stopInIdle = (init->flags & DRV_USART_INIT_FLAG_STOP_IN_IDLE);
9D0015D0  7C690080   EXT T1, V1, 2, 1
1139:                
1140:                    /* When the CPU enters IDLE mode, stop the USART */
1141:                    autoBaud = (init->flags & DRV_USART_INIT_FLAG_AUTO_BAUD);
9D0015D4  7C6A0040   EXT T2, V1, 1, 1
1142:                
1143:                    /* Initialize the USART based on initialization data structure */
1144:                    PLIB_USART_InitializeModeGeneral(plibID, autoBaud, loopbackMode,
1145:                            wakeFromSleep, irdaMode, stopInIdle);
1146:                
1147:                    /* Set the line control mode */
1148:                    PLIB_USART_LineControlModeSelect(plibID, init->lineControl);
9D001614  8CA20018   LW V0, 24(A1)
1149:                
1150:                    /* We set the receive interrupt mode to receive an interrupt whenever FIFO
1151:                       is not empty */
1152:                    PLIB_USART_InitializeOperation(plibID, USART_RECEIVE_FIFO_ONE_CHAR,
1153:                            USART_TRANSMIT_FIFO_IDLE, handshakeLines);
1154:                
1155:                    /* Set the baud rate and enable the USART */
1156:                    PLIB_USART_BaudSetAndEnable(plibID, init->brgClock, init->baud);
9D00166C  8CA60014   LW A2, 20(A1)
9D001670  8CA2001C   LW V0, 28(A1)
9D001674  24031400   ADDIU V1, ZERO, 5120
9D001678  AC830018   SW V1, 24(A0)
9D00167C  00022842   SRL A1, V0, 1
9D001680  00061882   SRL V1, A2, 2
9D001684  00651821   ADDU V1, V1, A1
9D001688  0062001B   DIVU V1, V0
9D00168C  004001F4   TEQ V0, ZERO
9D001690  00001812   MFLO V1
9D001694  2463FFFF   ADDIU V1, V1, -1
9D001698  3C070001   LUI A3, 1
9D00169C  0067382B   SLTU A3, V1, A3
9D0016A0  50E00006   BEQL A3, ZERO, _DRV_USART_HardwareSetup::PLIB_USART_BaudSetAndEnable
9D0016A4  24030008   ADDIU V1, ZERO, 8
9D0016A8  24020008   ADDIU V0, ZERO, 8
9D0016AC  AC820008   SW V0, 8(A0)
9D0016B0  AC830040   SW V1, 64(A0)
9D0016B4  0B4005B8   J 0x9D0016E0
9D0016B8  34028000   ORI V0, ZERO, -32768
9D0016BC  AC830004   SW V1, 4(A0)
9D0016C0  00063102   SRL A2, A2, 4
9D0016C4  00A62821   ADDU A1, A1, A2
9D0016C8  00A2001B   DIVU A1, V0
9D0016CC  004001F4   TEQ V0, ZERO
9D0016D0  00002812   MFLO A1
9D0016D4  24A5FFFF   ADDIU A1, A1, -1
9D0016D8  AC850040   SW A1, 64(A0)
9D0016DC  34028000   ORI V0, ZERO, -32768
9D0016E0  AC820008   SW V0, 8(A0)
9D0016E4  03E00008   JR RA
9D0016E8  00000000   NOP
1157:                }
1158:                
1159:                // *****************************************************************************
1160:                /* Function:
1161:                    DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1162:                
1163:                  Summary:
1164:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1165:                
1166:                  Description:
1167:                    Dynamic implementation of the _DRV_USART_DriverHandleValidate() function.
1168:                    This function return NULL if the handle is invalid else it return a pointer
1169:                    to the USART Driver Client Object associated with this handle.
1170:                
1171:                  Remarks:
1172:                    This is a private function and should not be called directly by an
1173:                    application.
1174:                */
1175:                
1176:                DRV_USART_CLIENT_OBJ * _DRV_USART_DriverHandleValidate(DRV_HANDLE handle)
1177:                {
1178:                    /* This function returns the pointer to the client object that is
1179:                       associated with this handle if the handle is valid. Returns NULL
1180:                       otherwise. */
1181:                
1182:                    DRV_USART_CLIENT_OBJ * client;
1183:                
1184:                    if((DRV_HANDLE_INVALID == handle) ||
9D003798  2482FFFF   ADDIU V0, A0, -1
9D00379C  2C42FFFE   SLTIU V0, V0, -2
9D0037A0  10400005   BEQ V0, ZERO, 0x9D0037B8
9D0037A4  00000000   NOP
1185:                            (0 == handle))
1186:                    {
1187:                        return(NULL);
1188:                    }
1189:                
1190:                    client = (DRV_USART_CLIENT_OBJ *)handle;
1191:                
1192:                    if(!client->inUse)
9D0037A8  90820008   LBU V0, 8(A0)
1193:                    {
1194:                        return(NULL);
9D0037AC  0002200A   MOVZ A0, ZERO, V0
9D0037B0  03E00008   JR RA
9D0037B4  00801021   ADDU V0, A0, ZERO
1195:                    }
1196:                
1197:                    return(client);
1198:                }
9D0037B8  03E00008   JR RA
9D0037BC  00001021   ADDU V0, ZERO, ZERO
1199:                
1200:                // *****************************************************************************
1201:                // *****************************************************************************
1202:                // Section: File scope functions
1203:                // *****************************************************************************
1204:                // *****************************************************************************
1205:                
1206:                bool _DRV_USART_ClientBufferQueueObjectsRemove(DRV_USART_CLIENT_OBJ * clientObj)
1207:                {
00000000  00000000   NOP
1208:                    DRV_USART_OBJ * dObj = clientObj->hDriver;
00000014  00000000   NOP
1209:                    bool interruptWasEnabled = false;
1210:                    DRV_USART_BUFFER_OBJ * iterator = NULL;
1211:                
1212:                    if(OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1213:                    {
1214:                        /* Disable the transmit interrupt */
1215:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->txInterruptSource);
0000002C  00000000   NOP
1216:                        iterator = dObj->queueWrite;
00000034  00000000   NOP
1217:                        while(iterator != NULL)
00000038  00000000   NOP
00000088  00000000   NOP
1218:                        {
1219:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
00000040  00000000   NOP
1220:                            {
1221:                                /* That means this buffer object is owned
1222:                                   by this client. This buffer object should
1223:                                   be removed. The following code removes
1224:                                   the object from a doubly linked list queue. */
1225:                
1226:                                iterator->inUse = false;
0000004C  00000000   NOP
1227:                                if(iterator->previous != NULL)
00000050  00000000   NOP
1228:                                {
1229:                                    iterator->previous->next = iterator->next;
0000005C  00000000   NOP
1230:                                }
1231:                                if(iterator->next != NULL)
00000064  00000000   NOP
1232:                                {
1233:                                    iterator->next->previous = iterator->previous;
00000070  00000000   NOP
1234:                                }
1235:                                /* Decrementing Current queue size */
1236:                                dObj->queueSizeCurrentWrite --;
00000078  00000000   NOP
1237:                
1238:                            }
1239:                            iterator = iterator->next;
00000084  00000000   NOP
1240:                        }
1241:                        /* If there are no buffers in the write queue.
1242:                         * Make the head pointer point to NULL */
1243:                        if(dObj->queueSizeCurrentWrite == 0)
00000090  00000000   NOP
1244:                        {
1245:                            dObj->queueWrite = NULL;
1246:                        }
1247:                        else
1248:                        {
1249:                            /* Iterate to update the head pointer to point
1250:                             * the first valid buffer object in the queue */
1251:                            iterator = dObj->queueWrite;
1252:                            while(iterator != NULL)
000000A4  00000000   NOP
000000DC  00000000   NOP
1253:                            {
1254:                                if(iterator->inUse == true)
000000AC  00000000   NOP
000000C4  00000000   NOP
1255:                                {
1256:                                    dObj->queueWrite = iterator;
000000BC  00000000   NOP
1257:                                    break;
000000D4  00000000   NOP
1258:                                }
1259:                                iterator = iterator->next;
1260:                            }
1261:                        }
1262:                
1263:                
1264:                        /* Re-enable the interrupt if it was enabled */
1265:                        if(interruptWasEnabled)
000000E4  00000000   NOP
1266:                        {
1267:                            _DRV_USART_InterruptSourceEnable(dObj->txInterruptSource);
000000EC  00000000   NOP
1268:                        }
1269:                
1270:                        /* Now check the receive buffer queue. Start by disabling the
1271:                           receive interrupt */
1272:                
1273:                        interruptWasEnabled = _DRV_USART_InterruptSourceDisable(dObj->rxInterruptSource);
0000010C  00000000   NOP
1274:                        iterator = dObj->queueRead;
00000114  00000000   NOP
1275:                        while(iterator != NULL)
00000118  00000000   NOP
00000168  00000000   NOP
1276:                        {
1277:                            if(clientObj == (DRV_USART_CLIENT_OBJ *)iterator->hClient)
00000120  00000000   NOP
1278:                            {
1279:                                /* That means this buffer object is owned
1280:                                   by this client. This buffer object should
1281:                                   be removed. The following code removed
1282:                                   the object from a doubly linked list queue. */
1283:                
1284:                                iterator->inUse = false;
0000012C  00000000   NOP
1285:                                if(iterator->previous != NULL)
00000130  00000000   NOP
1286:                                {
1287:                                    iterator->previous->next = iterator->next;
0000013C  00000000   NOP
1288:                                }
1289:                                if(iterator->next != NULL)
00000144  00000000   NOP
1290:                                {
1291:                                    iterator->next->previous = iterator->previous;
00000150  00000000   NOP
1292:                                }
1293:                                /* Decrementing Current queue size */
1294:                                dObj->queueSizeCurrentRead --;
00000158  00000000   NOP
1295:                            }
1296:                            iterator = iterator->next;
00000164  00000000   NOP
1297:                        }
1298:                        /* If there are no buffers in the read queue.
1299:                         * Make the head pointer point to NULL */
1300:                        if(dObj->queueSizeCurrentRead == 0)
00000170  00000000   NOP
1301:                        {
1302:                            dObj->queueRead = NULL;
1303:                        }
1304:                        else
1305:                        {
1306:                            /* Iterate to update the head pointer to point
1307:                             * the first valid buffer object in the queue */
1308:                            iterator = dObj->queueRead;
1309:                            while(iterator != NULL)
00000184  00000000   NOP
000001BC  00000000   NOP
1310:                            {
1311:                                if(iterator->inUse == true)
0000018C  00000000   NOP
000001A4  00000000   NOP
1312:                                {
1313:                                    dObj->queueRead = iterator;
0000019C  00000000   NOP
1314:                                    break;
000001B4  00000000   NOP
1315:                                }
1316:                                iterator = iterator->next;
1317:                            }
1318:                        }
1319:                
1320:                        if(interruptWasEnabled)
000001C4  00000000   NOP
1321:                        {
1322:                            _DRV_USART_InterruptSourceEnable(dObj->rxInterruptSource);
000001CC  00000000   NOP
1323:                        }
1324:                
1325:                        /* Unlock the mutex */
1326:                
1327:                        OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
1328:                    }
1329:                    else
1330:                    {
1331:                        /* The case where the mutex lock timed out and the
1332:                           client buffer objects could not be removed from
1333:                           the driver queue, the close function should fail. */
1334:                
1335:                        return false;
1336:                    }
1337:                
1338:                    return true;
000001F8  00000000   NOP
1339:                }
000001FC  00000000   NOP
1340:                
1341:                void _DRV_USART_BufferQueueRxTasks(SYS_MODULE_OBJ object)
1342:                {
00000000  00000000   NOP
1343:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
00000014  00000000   NOP
1344:                    DRV_USART_BUFFER_OBJ * bufferObj;
1345:                    DRV_USART_CLIENT_OBJ * client;
1346:                    USART_MODULE_ID plibID;
1347:                
1348:                    bool status;
1349:                
1350:                    plibID = hDriver->moduleId;
1351:                
1352:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1353:                       routine would be called from another thread. We need to get the driver
1354:                       instance mutex before updating the queue. If the driver is configured for
1355:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1356:                
1357:                    if(DRV_USART_INTERRUPT_MODE == false)
1358:                    {
1359:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1360:                        {
1361:                            /* We were able to take the mutex */
1362:                        }
1363:                        else
1364:                        {
1365:                            /* The mutex acquisition timed out. Return with an
1366:                               invalid handle. This code will not execute
1367:                               if there is no RTOS. */
1368:                            return;
1369:                        }
1370:                    }
1371:                
1372:                    /* In this function, the driver checks if there are any buffers in queue. If
1373:                       so the buffer is serviced. A buffer that is serviced completely is
1374:                       removed from the queue. Start by getting the buffer at the head of the
1375:                       queue */
1376:                
1377:                    bufferObj = hDriver->queueRead;
0000002C  00000000   NOP
1378:                
1379:                    if(bufferObj != NULL)
00000030  00000000   NOP
1380:                    {
1381:                        /* The USART driver is configured to generate an interrupt when the FIFO
1382:                           is not empty. Additionally the queue is not empty. Which means there
1383:                           is work to done in this routine. Read data from the FIFO until either
1384:                           the FIFO is empty or until we have read the requested number of bytes.
1385:                        */
1386:                        while((PLIB_USART_ReceiverDataIsAvailable(plibID))
00000044  00000000   NOP
00000084  00000000   NOP
1387:                            && (bufferObj->nCurrentBytes < bufferObj->size ))
0000004C  00000000   NOP
0000008C  00000000   NOP
1388:                        {
1389:                            bufferObj->buffer[bufferObj->nCurrentBytes] = PLIB_USART_ReceiverByteReceive(plibID);
00000064  00000000   NOP
1390:                            bufferObj->nCurrentBytes ++;
00000070  00000000   NOP
1391:                        }
1392:                
1393:                        /* Check if this buffer is done */
1394:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
000000A4  00000000   NOP
1395:                        {
1396:                            /* This means the buffer is completed. If there
1397:                               is a callback registered with client, then
1398:                               call it */
1399:                
1400:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
000000B4  00000000   NOP
1401:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
000000B8  00000000   NOP
1402:                            {
1403:                                /* Call the event handler. We additionally increment the
1404:                                   interrupt nesting count which lets the driver functions
1405:                                   that are called from the event handler know that an
1406:                                   interrupt context is active.
1407:                                   */
1408:                
1409:                                hDriver->interruptNestingCount ++;
000000D4  00000000   NOP
1410:                
1411:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
000000E0  00000000   NOP
1412:                                        bufferObj->bufferHandle,
1413:                                        client->context);
1414:                
1415:                                hDriver->interruptNestingCount --;
000000F4  00000000   NOP
1416:                            }
1417:                
1418:                            /* Get the next buffer in the queue and deallocate
1419:                               this buffer */
1420:                
1421:                            hDriver->queueRead = bufferObj->next;
00000100  00000000   NOP
1422:                            bufferObj->inUse = false;
00000108  00000000   NOP
1423:                            hDriver->queueSizeCurrentRead --;
0000010C  00000000   NOP
1424:                
1425:                            /* Reset the next and previous pointers */
1426:                            bufferObj->next = NULL;
00000118  00000000   NOP
1427:                            bufferObj->previous = NULL;
0000011C  00000000   NOP
1428:                
1429:                            /* Reset the current head's previous pointer */
1430:                            if (hDriver->queueRead != NULL)
00000120  00000000   NOP
1431:                            {
1432:                                hDriver->queueRead->previous = NULL;
1433:                            }
1434:                
1435:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
0000012C  00000000   NOP
1436:                            {
1437:                                /* This means we should post the semaphore */
1438:                                _DRV_USART_SEM_POST(&(client->semReadDone));
1439:                            }
1440:                        }
1441:                    }
1442:                
1443:                    if(hDriver->queueRead == NULL)
00000148  00000000   NOP
1444:                    {
1445:                        /* The queue is empty. We can disable the interrupt */
1446:                        status = _DRV_USART_InterruptSourceDisable(hDriver->rxInterruptSource);
00000154  00000000   NOP
1447:                        /* Ignore the warning */
1448:                        (void)status;
1449:                    }
1450:                
1451:                    /* Release the mutex */
1452:                
1453:                   _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1454:                }
0000015C  00000000   NOP
1455:                
1456:                void _DRV_USART_BufferQueueTxTasks(SYS_MODULE_OBJ object)
1457:                {
00000000  00000000   NOP
1458:                    /* Start by getting the buffer at the head of queue. */
1459:                
1460:                    DRV_USART_OBJ *hDriver = &gDrvUSARTObj[object];
00000018  00000000   NOP
1461:                    DRV_USART_BUFFER_OBJ * bufferObj;
1462:                    DRV_USART_CLIENT_OBJ * client;
1463:                    USART_MODULE_ID plibID;
1464:                
1465:                    bool status;
1466:                
1467:                    bufferObj = hDriver->queueWrite;
00000030  00000000   NOP
1468:                    plibID = hDriver->moduleId;
1469:                
1470:                    /* If this driver is configured for polled mode in an RTOS, the tasks
1471:                       routine would be called from another thread. We need to get the driver
1472:                       instance mutex before updating the queue. If the driver is configured for
1473:                       interrupt mode, then _DRV_USART_TAKE_MUTEX will compile to true */
1474:                
1475:                    if(DRV_USART_INTERRUPT_MODE == false)
1476:                    {
1477:                        if(OSAL_MUTEX_Lock(&(hDriver->mutexDriverInstance), OSAL_WAIT_FOREVER))
1478:                        {
1479:                            /* We were able to take the mutex */
1480:                        }
1481:                        else
1482:                        {
1483:                            /* The mutex acquisition timed out. Return with an
1484:                               invalid handle. This code will not execute
1485:                               if there is no RTOS. */
1486:                            return;
1487:                        }
1488:                    }
1489:                
1490:                    if(bufferObj != NULL)
00000034  00000000   NOP
1491:                    {
1492:                        /* This means the queue is not empty. Check if this buffer is done */
1493:                        if(bufferObj->nCurrentBytes >= bufferObj->size)
0000003C  00000000   NOP
1494:                        {
1495:                            /* This means the buffer is completed. If there
1496:                               is a callback registered with client, then
1497:                               call it */
1498:                
1499:                            client = (DRV_USART_CLIENT_OBJ *)bufferObj->hClient;
00000050  00000000   NOP
1500:                            if((client->eventHandler != NULL) && (bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_BUFFER_ADD))
00000054  00000000   NOP
1501:                            {
1502:                                /* Before calling the event handler, the interrupt nesting
1503:                                   counter is incremented. This will allow driver routine that
1504:                                   are called from the event handler to know the interrupt
1505:                                   nesting level. Events are only generated for buffers that
1506:                                   were submitted using the buffer add routine */
1507:                
1508:                                hDriver->interruptNestingCount ++;
00000070  00000000   NOP
1509:                
1510:                                client->eventHandler(DRV_USART_BUFFER_EVENT_COMPLETE,
0000007C  00000000   NOP
1511:                                        bufferObj->bufferHandle,
1512:                                        client->context);
1513:                
1514:                                /* Decrement the nesting count */
1515:                                hDriver->interruptNestingCount -- ;
00000090  00000000   NOP
1516:                            }
1517:                
1518:                            /* Get the next buffer in the queue and deallocate
1519:                             * this buffer */
1520:                
1521:                            hDriver->queueWrite = bufferObj->next;
0000009C  00000000   NOP
1522:                            bufferObj->inUse = false;
000000A4  00000000   NOP
1523:                            hDriver->queueSizeCurrentWrite --;
000000A8  00000000   NOP
1524:                
1525:                            /* Reset the next and previous pointers */
1526:                            bufferObj->next = NULL;
000000B4  00000000   NOP
1527:                            bufferObj->previous = NULL;
000000B8  00000000   NOP
1528:                
1529:                            /* Reset the current head's previous pointer */
1530:                            if (hDriver->queueWrite != NULL)
000000BC  00000000   NOP
1531:                            {
1532:                                hDriver->queueWrite->previous = NULL;
1533:                            }
1534:                
1535:                            if(bufferObj->flags & DRV_USART_BUFFER_OBJ_FLAG_READ_WRITE)
000000C8  00000000   NOP
1536:                            {
1537:                                /* This means we should post the semaphore */
1538:                                _DRV_USART_SEM_POST(&(client->semWriteDone));
1539:                
1540:                            }
1541:                        }
1542:                    }
1543:                
1544:                    /* Check if the queue is still not empty and process
1545:                       the buffer */
1546:                
1547:                    if(hDriver->queueWrite != NULL)
000000E4  00000000   NOP
1548:                    {
1549:                        bufferObj = hDriver->queueWrite;
1550:                        if(hDriver->operationMode == DRV_USART_OPERATION_MODE_ADDRESSED)
000000F8  00000000   NOP
1551:                        {
1552:                			uint16_t *buf_ptr;
1553:                            buf_ptr = (uint16_t *) bufferObj->buffer;
00000134  00000000   NOP
1554:                
1555:                            /* Fill up the FIFO with data until the FIFO is full
1556:                               and we have data to send */
1557:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
00000138  00000000   NOP
00000188  00000000   NOP
1558:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
00000190  00000000   NOP
1559:                            {
1560:                                if((bufferObj->nCurrentBytes == 0) && (false == bufferObj->isAddressSent))
00000140  00000000   NOP
1561:                                {
1562:                                    /* Send Address */
1563:                                    PLIB_USART_Transmitter9BitsSend(plibID, bufferObj->address, true);
1564:                                    bufferObj->isAddressSent = true;
00000160  00000000   NOP
1565:                                }
1566:                                else
1567:                                {
1568:                                    /* Send data */
1569:                                    PLIB_USART_Transmitter9BitsSend(plibID, buf_ptr[bufferObj->nCurrentBytes], false);
00000168  00000000   NOP
1570:                                    bufferObj->nCurrentBytes ++; // Here it is incrementing the 16-bit words number.
00000174  00000000   NOP
1571:                                }
1572:                            }
1573:                        }
1574:                        else
1575:                        {
1576:                            /* Fill up the FIFO with data until the FIFO is full
1577:                               and we have data to send */
1578:                            while((!PLIB_USART_TransmitterBufferIsFull(plibID))
00000110  00000000   NOP
000001CC  00000000   NOP
1579:                                    && (bufferObj->nCurrentBytes < bufferObj->size ))
00000118  00000000   NOP
000001D4  00000000   NOP
1580:                            {
1581:                                /* Send data */
1582:                                PLIB_USART_TransmitterByteSend(plibID, bufferObj->buffer[bufferObj->nCurrentBytes]);
000001AC  00000000   NOP
1583:                                bufferObj->nCurrentBytes ++;
000001B8  00000000   NOP
1584:                            }
1585:                        }
1586:                    }
1587:                    else
1588:                    {
1589:                        /* If the queue is empty, then disable the TX interrupt */
1590:                        status = _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
000001EC  00000000   NOP
1591:                        /* Ignore the warning */
1592:                        (void)status;
1593:                    }
1594:                
1595:                    /* Release the mutex */
1596:                    _DRV_USART_RELEASE_MUTEX(&(hDriver->mutexDriverInstance));
1597:                }
0000012C  00000000   NOP
000001F4  00000000   NOP
1598:                
1599:                void _DRV_USART_ByteTransmitTasks (SYS_MODULE_OBJ object)
1600:                {
9D002FFC  27BDFFE0   ADDIU SP, SP, -32
9D003000  AFBF001C   SW RA, 28(SP)
9D003004  AFB10018   SW S1, 24(SP)
9D003008  AFB00014   SW S0, 20(SP)
9D00300C  00808021   ADDU S0, A0, ZERO
1601:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D003010  00041140   SLL V0, A0, 5
9D003014  000489C0   SLL S1, A0, 7
9D003018  02221023   SUBU V0, S1, V0
9D00301C  3C11A000   LUI S1, -24576
9D003020  263107AC   ADDIU S1, S1, 1964
9D003024  02228821   ADDU S1, S1, V0
1602:                
1603:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->txInterruptSource))
9D003028  8E220024   LW V0, 36(S1)
9D00304C  10600009   BEQ V1, ZERO, 0x9D003074
9D003050  8FBF001C   LW RA, 28(SP)
1604:                    {
1605:                        /* Disable the interrupt, to avoid calling ISR continuously*/
1606:                        _DRV_USART_InterruptSourceDisable(hDriver->txInterruptSource);
9D003054  0F400D0B   JAL SYS_INT_SourceDisable
9D003058  00402021   ADDU A0, V0, ZERO
1607:                
1608:                        if (hDriver->transmitCallback != NULL)
9D00305C  8E220054   LW V0, 84(S1)
9D003060  10400004   BEQ V0, ZERO, 0x9D003074
9D003064  8FBF001C   LW RA, 28(SP)
1609:                        {
1610:                            hDriver->transmitCallback (object);
9D003068  0040F809   JALR V0
9D00306C  3204FFFF   ANDI A0, S0, -1
1611:                        }
1612:                    }
1613:                
1614:                }
9D003070  8FBF001C   LW RA, 28(SP)
9D003074  8FB10018   LW S1, 24(SP)
9D003078  8FB00014   LW S0, 20(SP)
9D00307C  03E00008   JR RA
9D003080  27BD0020   ADDIU SP, SP, 32
1615:                
1616:                void _DRV_USART_ByteReceiveTasks (SYS_MODULE_OBJ object)
1617:                {
9D00315C  27BDFFE8   ADDIU SP, SP, -24
9D003160  AFBF0014   SW RA, 20(SP)
1618:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00310C  00041140   SLL V0, A0, 5
9D003110  000419C0   SLL V1, A0, 7
9D003114  00621023   SUBU V0, V1, V0
9D003118  3C03A000   LUI V1, -24576
9D00311C  246307AC   ADDIU V1, V1, 1964
9D003120  00621821   ADDU V1, V1, V0
1619:                
1620:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->rxInterruptSource))
9D003124  8C620028   LW V0, 40(V1)
9D003148  1040000A   BEQ V0, ZERO, 0x9D003174
9D00314C  00000000   NOP
1621:                    {
1622:                        if (hDriver->receiveCallback != NULL)
9D003150  8C620058   LW V0, 88(V1)
9D003154  10400007   BEQ V0, ZERO, 0x9D003174
9D003158  00000000   NOP
1623:                        {
1624:                            hDriver->receiveCallback (object);
9D003164  0040F809   JALR V0
9D003168  3084FFFF   ANDI A0, A0, -1
1625:                        }
1626:                    }
1627:                }
9D00316C  8FBF0014   LW RA, 20(SP)
9D003170  27BD0018   ADDIU SP, SP, 24
9D003174  03E00008   JR RA
9D003178  00000000   NOP
1628:                
1629:                void _DRV_USART_ByteErrorTasks (SYS_MODULE_OBJ object)
1630:                {
9D0031CC  27BDFFE8   ADDIU SP, SP, -24
9D0031D0  AFBF0014   SW RA, 20(SP)
1631:                    DRV_USART_OBJ * hDriver = &gDrvUSARTObj[object];
9D00317C  00041140   SLL V0, A0, 5
9D003180  000419C0   SLL V1, A0, 7
9D003184  00621023   SUBU V0, V1, V0
9D003188  3C03A000   LUI V1, -24576
9D00318C  246307AC   ADDIU V1, V1, 1964
9D003190  00621821   ADDU V1, V1, V0
1632:                
1633:                    if (_DRV_USART_InterruptSourceIsEnabled(hDriver->errorInterruptSource))
9D003194  8C62002C   LW V0, 44(V1)
9D0031B8  1040000A   BEQ V0, ZERO, 0x9D0031E4
9D0031BC  00000000   NOP
1634:                    {
1635:                        if (hDriver->errorCallback != NULL)
9D0031C0  8C62005C   LW V0, 92(V1)
9D0031C4  10400007   BEQ V0, ZERO, 0x9D0031E4
9D0031C8  00000000   NOP
1636:                        {
1637:                            hDriver->errorCallback (object);
9D0031D4  0040F809   JALR V0
9D0031D8  3084FFFF   ANDI A0, A0, -1
1638:                        }
1639:                    }
1640:                }
9D0031DC  8FBF0014   LW RA, 20(SP)
9D0031E0  27BD0018   ADDIU SP, SP, 24
9D0031E4  03E00008   JR RA
9D0031E8  00000000   NOP
1641:                
1642:                /*******************************************************************************
1643:                 End of File
1644:                */
1645:                
---  c:/microchip/harmony/v2_01b/framework/driver/i2c/src/dynamic/drv_i2c.c  ----------------------------
1:                   /*******************************************************************************
2:                     I2C Device Driver Definition
3:                   
4:                     Company:
5:                       Microchip Technology Inc.
6:                   
7:                     File Name:
8:                       drv_i2c.c
9:                   
10:                    Summary:
11:                      I2C Device Driver Dynamic Multiple Client Implementation
12:                  
13:                    Description:
14:                      The I2C device driver provides a simple interface to manage the I2C
15:                      modules on Microchip microcontrollers.  This file Implements the core
16:                      interface routines for the I2C driver.
17:                  
18:                      While building the driver from source, ALWAYS use this file in the build.
19:                  *******************************************************************************/
20:                  
21:                  //DOM-IGNORE-BEGIN
22:                  /*******************************************************************************
23:                  Copyright (c) 2012 released Microchip Technology Inc.  All rights reserved.
24:                  
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital signal
27:                  controller that is integrated into your product or third party product
28:                  (pursuant to the sublicense terms in the accompanying license agreement).
29:                  
30:                  You should refer to the license agreement accompanying this Software for
31:                  additional information regarding your rights and obligations.
32:                  
33:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND,
34:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
35:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
36:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
37:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
38:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
39:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
40:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
41:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
42:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
43:                  *******************************************************************************/
44:                  //DOM-IGNORE-END
45:                  
46:                  
47:                  // *****************************************************************************
48:                  // *****************************************************************************
49:                  // Section: Include Files
50:                  // *****************************************************************************
51:                  // *****************************************************************************
52:                  
53:                  #include "driver/i2c/src/drv_i2c_local.h"
54:                  #include "osal/osal.h"
55:                  
56:                  bool _DRV_I2C_IsQueueEmpty(DRV_I2C_OBJ *dObj);
57:                  DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj );
58:                  
59:                  
60:                  /* this code is included for generating STOP condition using BIT-BANG method */
61:                  
62:                  #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
63:                      #ifdef MZ_EC_ERRATA_25_BB_STOP                
64:                          static uint32_t ReadCoreTimer(void);
65:                  
66:                          static uint32_t ReadCoreTimer()
67:                          {
68:                              volatile uint32_t timer;
69:                  
70:                              // get the count reg
71:                              asm volatile("mfc0   %0, $9" : "=r"(timer));
72:                  
73:                              return(timer);
74:                          }
75:                  
76:                          uint32_t    starttime;
77:                  
78:                          #define BAUD_RATE_0         50000
79:                          #define BRG_1_TIME_0        SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_2)/(2*BAUD_RATE_0)
80:                      #endif
81:                  #endif
82:                  
83:                  // *****************************************************************************
84:                  // *****************************************************************************
85:                  // Section: File Scope Variables
86:                  // *****************************************************************************
87:                  // *****************************************************************************
88:                  
89:                  // *****************************************************************************
90:                  /* Driver Hardware instance objects.
91:                  
92:                    Summary:
93:                      Defines the hardware instances objects that are available on the part
94:                  
95:                    Description:
96:                      This data type defines the hardware instance objects that are available on
97:                      the part, so as to capture the hardware state of the instance.
98:                  
99:                    Remarks:
100:                     Not all modes are available on all micro-controllers.
101:                 */
102:                 
103:                 static DRV_I2C_OBJ             gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER] ;
104:                 
105:                 // *****************************************************************************
106:                 /* Driver Client instance objects.
107:                 
108:                   Summary:
109:                     Defines the Client instances objects that are available on the part
110:                 
111:                   Description:
112:                     This data type defines the Client instance objects that are available on
113:                     the part, so as to capture the Client state of the instance.
114:                 
115:                   Remarks:
116:                     None
117:                 */
118:                 
119:                 static DRV_I2C_CLIENT_OBJ      gDrvI2CClientObj [ DRV_I2C_CLIENTS_NUMBER ] ;
120:                 
121:                 
122:                 // *****************************************************************************
123:                 /* Driver data objects.
124:                 
125:                   Summary:
126:                     Defines the data object.
127:                 
128:                   Description:
129:                     This data type defines the data objects. This is used to queue the user
130:                     requests for different operations.
131:                 
132:                   Remarks:
133:                     None
134:                 */
135:                 
136:                 static DRV_I2C_BUFFER_OBJECT	gDrvI2CBufferObj [ DRV_I2C_INSTANCES_NUMBER ][ DRV_I2C_NUM_OF_BUFFER_OBJECTS ];
137:                 
138:                 
139:                 /* This object maintains data that is required by all USART
140:                    driver instances. */
141:                 DRV_I2C_COMMON_DATA_OBJ gDrvI2CCommonDataObj;
142:                 
143:                 // *****************************************************************************
144:                 /* Driver Shared Object protection
145:                  */
146:                 static uint32_t i2cNumInited = 0;
147:                 
148:                 //static OSAL_MUTEX_DECLARE(i2cClientMutex);
149:                 
150:                 // *****************************************************************************
151:                 /* Macro: _DRV_I2C_CLIENT_OBJ(obj,mem)
152:                 
153:                   Summary:
154:                     Returns the appropriate client member
155:                 
156:                   Description:
157:                     Either return the static object or returns the indexed dynamic object.
158:                     This macro has variations for dynamic or static driver.
159:                 */
160:                 
161:                 #define _DRV_I2C_CLIENT_OBJ(obj,mem)    obj->mem
162:                 
163:                 
164:                 // *****************************************************************************
165:                 /* Macro: _DRV_I2C_CLIENT_OBJ_GET(obj)
166:                 
167:                   Summary:
168:                     Returns the appropriate client instance
169:                 
170:                   Description:
171:                     Either return the static object or returns the indexed dynamic object.
172:                     This macro has variations for dynamic or static driver.
173:                 */
174:                 
175:                 #define _DRV_I2C_CLIENT_OBJ_GET(obj)    &gDrvI2CClientObj[obj]
176:                 
177:                 // *****************************************************************************
178:                 /* Macro: _DRV_I2C_DATA_OBJ(obj,mem)
179:                 
180:                   Summary:
181:                     Returns the appropriate client member
182:                 
183:                   Description:
184:                     Either return the static object or returns the indexed dynamic object.
185:                     This macro has variations for dynamic or static driver.
186:                 */
187:                 
188:                 #define _DRV_I2C_DATA_OBJ(obj,mem)    ((DRV_I2C_BUFFER_OBJECT*)(obj))->mem
189:                 
190:                 // *****************************************************************************
191:                 /*
192:                  Upper address limit for a 7-bit address 
193:                  */
194:                 
195:                 #define ADDRESS_7BIT_UPPER_LIMIT                    0xFF
196:                 
197:                 // *****************************************************************************
198:                 // *****************************************************************************
199:                 // Section: File Scope Functions
200:                 // *****************************************************************************
201:                 // *****************************************************************************
202:                 
203:                 static void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj);
204:                 static void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj);
205:                 static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID plibId,
206:                                                      DRV_I2C_OBJ *dObj,
207:                                                      DRV_I2C_INIT * i2cInit );
208:                 
209:                 // *****************************************************************************
210:                 /* Function:
211:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj )
212:                 
213:                   Summary:
214:                     Adds an element to the queue.
215:                 
216:                   Description:
217:                     This API adds an element to the queue.
218:                 
219:                   Parameters:
220:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
221:                     				added to the queue.
222:                 
223:                   Returns:
224:                     DRV_I2C_BUFFER_HANDLE - Handle, a pointer to the allocated element in the
225:                     						queue.
226:                 */
227:                 DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueSlotGet ( DRV_I2C_OBJ *dObj )
228:                 {
9D001348  27BDFFE0   ADDIU SP, SP, -32
9D00134C  AFBF001C   SW RA, 28(SP)
9D001350  AFB10018   SW S1, 24(SP)
9D001354  AFB00014   SW S0, 20(SP)
9D001358  00808021   ADDU S0, A0, ZERO
229:                     uint8_t numOfFreeQueueSlots;
230:                     DRV_I2C_BUFFER_OBJECT *lQueueObj;
231:                     bool interruptEnableState = false;
9D0013AC  00001021   ADDU V0, ZERO, ZERO
232:                     
233:                     SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
234:                     
235:                     if (dObj->interruptNestingCount == 0)
9D00135C  8C820068   LW V0, 104(A0)
9D001360  14400012   BNE V0, ZERO, 0x9D0013AC
9D001364  94910018   LHU S1, 24(A0)
236:                     {
237:                         Nop();
9D001368  00000040   SSNOP
238:                         if (OSAL_MUTEX_Lock(&(dObj->mutexDriverInstance), OSAL_WAIT_FOREVER)  == OSAL_RESULT_TRUE) 
239:                         {
240:                             /* We will disable interrupts so that the queue
241:                                status does not get updated asynchronously.
242:                                This code will always execute. */
243:                             
244:                             if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D001380  8E020020   LW V0, 32(S0)
9D001384  14400005   BNE V0, ZERO, 0x9D00139C
9D001388  00000000   NOP
245:                             {
246:                                 interruptEnableState = _DRV_I2C_InterruptSourceDisable(dObj->mstrInterruptSource);
9D00138C  0F400D0B   JAL SYS_INT_SourceDisable
9D001390  8E040030   LW A0, 48(S0)
9D001394  0B4004ED   J 0x9D0013B4
9D001398  8E030050   LW V1, 80(S0)
247:                             }
248:                             else
249:                             {
250:                                 interruptEnableState = _DRV_I2C_InterruptSourceDisable(dObj->slaveInterruptSource);
9D00139C  0F400D0B   JAL SYS_INT_SourceDisable
9D0013A0  8E040034   LW A0, 52(S0)
251:                             }
252:                         }
253:                         else
254:                         {
255:                             /* The mutex acquisition timed out. Return with an
256:                                invalid handle. This code will not execute
257:                                if there is no RTOS. */
258:                             return (DRV_I2C_BUFFER_OBJECT*)NULL;;
259:                             
260:                         }
261:                     }
262:                     
263:                 //    _DRV_I2C_LockMutex(dObj);
264:                     
265:                     /* if position of item populated in the queue (Queue-In pointer) is greater 
266:                      * than the position where the item is to be taken out of the queue,
267:                      * (Queue-Out pointer) then the number of free slots is the remainder of the 
268:                      * slots excluding the slot index where Queue Out pointer resides to the 
269:                      * slot index where Queue-In pointer resides.
270:                      * Ex: # of Queue Slots = 6, Queue-In = 5 and Queue-Out = 2
271:                      * Number of free queue available  = 6 -(5-2) - 1 = 2 (free slots - 6 & 1)
272:                      * 
273:                      * if Queue-Out pointer is greater than Queue-In pointer but the Queue Out 
274:                      * pointer is adjacent to Queue-In pointer (Queue-Out - Queue-In == 1) 
275:                      * then buffer is full. Return 0 slots available if it's the case.      
276:                      * If Queue-Out pointer is greater than Queue-In pointer then slots starting
277:                      * from Queue-In pointer to Queue-Out pointer is number of available queue
278:                      * slots 
279:                      * Ex: # of Queue Slots = 6, Queue-Out = 4 and Queue-In = 2
280:                      * Number of free queue slots available  = 4-2-1 (free slots - 3)
281:                      */
282:                     
283:                     if (dObj->queueIn >= dObj->queueOut)
9D0013A4  0B4004ED   J 0x9D0013B4
9D0013A8  8E030050   LW V1, 80(S0)
9D0013B0  8E030050   LW V1, 80(S0)
9D0013B4  8E040054   LW A0, 84(S0)
9D0013B8  0064282B   SLTU A1, V1, A0
9D0013BC  54A00005   BNEL A1, ZERO, 0x9D0013D4
9D0013C0  2484FFFF   ADDIU A0, A0, -1
284:                     {
285:                         numOfFreeQueueSlots =  (DRV_I2C_NUM_OF_BUFFER_OBJECTS - (dObj->queueIn - dObj->queueOut) -1);
9D0013C4  24840006   ADDIU A0, A0, 6
9D0013C8  00832023   SUBU A0, A0, V1
9D0013CC  0B4004F7   J 0x9D0013DC
9D0013D0  308400FF   ANDI A0, A0, 255
286:                     }
287:                     else 
288:                     {
289:                         numOfFreeQueueSlots = ((dObj->queueOut - dObj->queueIn) -1);   
9D0013D4  00832023   SUBU A0, A0, V1
9D0013D8  308400FF   ANDI A0, A0, 255
290:                     }
291:                     
292:                     if (numOfFreeQueueSlots > 0)
9D0013DC  1080002D   BEQ A0, ZERO, 0x9D001494
9D0013E0  24640001   ADDIU A0, V1, 1
293:                     {
294:                         lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ dObj->queueIn ];
295:                         
296:                         dObj->queueIn++;
9D0013E8  0005200A   MOVZ A0, ZERO, A1
297:                         
298:                         if ( dObj->queueIn >= DRV_I2C_NUM_OF_BUFFER_OBJECTS )
9D0013E4  2C850007   SLTIU A1, A0, 7
299:                         {
300:                             dObj->queueIn = 0;
301:                         }
302:                         
303:                         /* We are done. Restore the interrupt enable status
304:                            and return. */
305:                 
306:                         if(interruptEnableState)
9D0013EC  10400017   BEQ V0, ZERO, 0x9D00144C
9D0013F0  AE040050   SW A0, 80(S0)
307:                         {
308:                             if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D0013F4  8E020020   LW V0, 32(S0)
9D0013F8  5440000C   BNEL V0, ZERO, _DRV_I2C_QueueSlotGet::PLIB_INT_SourceEnable
9D0013FC  8E020034   LW V0, 52(S0)
309:                             {
310:                                 _DRV_I2C_InterruptSourceEnable(dObj->mstrInterruptSource);
9D001400  8E020030   LW V0, 48(S0)
311:                             }
312:                             else
313:                             {
314:                                  _DRV_I2C_InterruptSourceEnable(dObj->slaveInterruptSource);
315:                             }
316:                         }
317:                         
318:                         if(dObj->interruptNestingCount == 0)
9D001424  0B400514   J 0x9D001450
9D001428  8E020068   LW V0, 104(S0)
9D00144C  8E020068   LW V0, 104(S0)
9D001450  54400004   BNEL V0, ZERO, 0x9D001464
9D001454  000310C0   SLL V0, V1, 3
319:                         {
320:                             /* Release mutex */
321:                             OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
322:                         }
323:                                 
324:                 //        _DRV_I2C_UnlockMutex(dObj);
325:                         return lQueueObj;
9D001460  000310C0   SLL V0, V1, 3
9D001464  00031980   SLL V1, V1, 6
9D001468  00621823   SUBU V1, V1, V0
9D00146C  001110C0   SLL V0, S1, 3
9D001470  00118980   SLL S1, S1, 6
9D001474  02228823   SUBU S1, S1, V0
9D001478  001110C0   SLL V0, S1, 3
9D00147C  00518823   SUBU S1, V0, S1
9D001480  00718821   ADDU S1, V1, S1
9D001484  3C02A001   LUI V0, -24575
9D001488  24428560   ADDIU V0, V0, -31392
9D00148C  0B400543   J 0x9D00150C
9D001490  00511021   ADDU V0, V0, S1
326:                     }
327:                     
328:                     if(interruptEnableState)
9D001494  50400018   BEQL V0, ZERO, 0x9D0014F8
9D001498  8E030068   LW V1, 104(S0)
329:                     {
330:                         if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D00149C  8E020020   LW V0, 32(S0)
9D0014A0  5440000C   BNEL V0, ZERO, _DRV_I2C_QueueSlotGet::PLIB_INT_SourceEnable
9D0014A4  8E020034   LW V0, 52(S0)
331:                         {
332:                             _DRV_I2C_InterruptSourceEnable(dObj->mstrInterruptSource);
9D0014A8  8E020030   LW V0, 48(S0)
333:                         }
334:                         else
335:                         {
336:                              _DRV_I2C_InterruptSourceEnable(dObj->slaveInterruptSource);
337:                         }
338:                     }
339:                 
340:                     if(dObj->interruptNestingCount == 0)
9D0014CC  0B40053E   J 0x9D0014F8
9D0014D0  8E030068   LW V1, 104(S0)
9D0014F4  8E030068   LW V1, 104(S0)
9D0014F8  14600004   BNE V1, ZERO, 0x9D00150C
9D0014FC  00001021   ADDU V0, ZERO, ZERO
341:                     {
342:                         /* Release mutex */
343:                         OSAL_MUTEX_Unlock(&(dObj->mutexDriverInstance));
344:                     }       
345:                 
346:                    return (DRV_I2C_BUFFER_OBJECT*)NULL;
9D001508  00001021   ADDU V0, ZERO, ZERO
347:                 }
9D00150C  8FBF001C   LW RA, 28(SP)
9D001510  8FB10018   LW S1, 24(SP)
9D001514  8FB00014   LW S0, 20(SP)
9D001518  03E00008   JR RA
9D00151C  27BD0020   ADDIU SP, SP, 32
348:                 
349:                 DRV_I2C_BUFFER_OBJECT* _DRV_I2C_QueueTailReset ( SYS_MODULE_INDEX drvIndex )
350:                 {
00000000  00000000   NOP
351:                     
352:                     DRV_I2C_BUFFER_OBJECT *lQueueObj;
353:                     
354:                     lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ 0 ];
355:                     
356:                     return lQueueObj;
00000004  00000000   NOP
357:                 }
00000018  00000000   NOP
358:                 
359:                 
360:                 // *****************************************************************************
361:                 /* Function:
362:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueuePop ( DRV_I2C_OBJ *dObj )
363:                 
364:                   Summary:
365:                     Removes a element from the queue
366:                 
367:                   Description:
368:                     This API removes an element from the queue
369:                 
370:                   Parameters:
371:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
372:                 
373:                   Returns:
374:                     DRV_I2C_BUFFER_HANDLE - Handle, a pointer to the next allocated element in the
375:                     						queue.
376:                 */
377:                 
378:                 DRV_I2C_BUFFER_OBJECT * _DRV_I2C_QueuePop( DRV_I2C_OBJ *dObj)
379:                 {
380:                     SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
381:                     
382:                     // Make sure that the pointer is valid inside out allocated space.
383:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D002E34  3C03A001   LUI V1, -24575
9D002E38  2463870C   ADDIU V1, V1, -30964
9D002E3C  14830020   BNE A0, V1, 0x9D002EC0
9D002E40  94820018   LHU V0, 24(A0)
384:                     {
385:                             return NULL;
9D002EC0  03E00008   JR RA
9D002EC4  00001021   ADDU V0, ZERO, ZERO
386:                     }
387:                     // Make sure that this driver instance is actually in use.
388:                     if (dObj->inUse != true)
9D002E44  3C03A001   LUI V1, -24575
9D002E48  90638726   LBU V1, -30938(V1)
9D002E4C  1060001E   BEQ V1, ZERO, 0x9D002EC8
9D002E50  3C04A001   LUI A0, -24575
389:                     {
390:                             return NULL;
391:                     }
392:                         
393:                     DRV_I2C_BUFFER_OBJECT * ret = &gDrvI2CBufferObj [ drvIndex ][ dObj->queueOut ];
9D002E54  2484870C   ADDIU A0, A0, -30964
9D002E58  8C830054   LW V1, 84(A0)
394:                     
395:                     if (dObj->i2cMode == DRV_I2C_MODE_SLAVE )
9D002E5C  8C850020   LW A1, 32(A0)
9D002E60  24040001   ADDIU A0, ZERO, 1
9D002E64  14A4000A   BNE A1, A0, 0x9D002E90
9D002E68  000320C0   SLL A0, V1, 3
396:                     {
397:                         if ( dObj->queueOut >= (DRV_I2C_NUM_OF_BUFFER_OBJECTS-1) )
9D002E6C  2C640006   SLTIU A0, V1, 6
9D002E70  14800004   BNE A0, ZERO, 0x9D002E84
9D002E74  24650001   ADDIU A1, V1, 1
398:                         {
399:                             dObj->queueOut = 0;
9D002E78  3C04A001   LUI A0, -24575
9D002E7C  0B400BA3   J 0x9D002E8C
9D002E80  AC808760   SW ZERO, -30880(A0)
400:                         }
401:                         else
402:                         {
403:                             dObj->queueOut++;
9D002E84  3C04A001   LUI A0, -24575
9D002E88  AC858760   SW A1, -30880(A0)
404:                         }
405:                     }
406:                            
407:                     return ret;
9D002E8C  000320C0   SLL A0, V1, 3
9D002E90  00031980   SLL V1, V1, 6
9D002E94  00641823   SUBU V1, V1, A0
9D002E98  000220C0   SLL A0, V0, 3
9D002E9C  00021180   SLL V0, V0, 6
9D002EA0  00441023   SUBU V0, V0, A0
9D002EA4  000220C0   SLL A0, V0, 3
9D002EA8  00821023   SUBU V0, A0, V0
9D002EAC  00621021   ADDU V0, V1, V0
9D002EB0  3C03A001   LUI V1, -24575
9D002EB4  24638560   ADDIU V1, V1, -31392
9D002EB8  03E00008   JR RA
9D002EBC  00621021   ADDU V0, V1, V0
408:                 }
9D002EC8  03E00008   JR RA
9D002ECC  00001021   ADDU V0, ZERO, ZERO
409:                 
410:                 
411:                 void _DRV_I2C_Advance_Queue( DRV_I2C_OBJ *dObj )
412:                 {
413:                     
414:                     if (dObj->i2cMode == DRV_I2C_MODE_MASTER)
9D003768  8C820020   LW V0, 32(A0)
9D00376C  14400008   BNE V0, ZERO, 0x9D003790
9D003770  00000000   NOP
415:                     {
416:                         if ( dObj->queueOut >= (DRV_I2C_NUM_OF_BUFFER_OBJECTS-1) )
9D003774  8C820054   LW V0, 84(A0)
9D003778  2C430006   SLTIU V1, V0, 6
9D00377C  14600003   BNE V1, ZERO, 0x9D00378C
9D003780  24420001   ADDIU V0, V0, 1
9D003784  03E00008   JR RA
9D003788  AC800054   SW ZERO, 84(A0)
417:                         {
418:                             dObj->queueOut = 0;
419:                         }
420:                         else
421:                         {
422:                             dObj->queueOut++;
9D00378C  AC820054   SW V0, 84(A0)
9D003790  03E00008   JR RA
9D003794  00000000   NOP
423:                         }
424:                     }
425:                 }
426:                 
427:                 // *****************************************************************************
428:                 /* Function:
429:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_IsQueueEmpty (DRV_I2C_OBJ *dObj)
430:                 
431:                   Summary:
432:                     Checks if the queue is empty
433:                 
434:                   Description:
435:                     This API checks if the end of queue has been reached or if the tail pointer
436:                     is at the same location as the head pointer. If the tail pointer and head
437:                     pointer coincide, it implies that the queue is empty
438:                 
439:                   Parameters:
440:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
441:                     i2cbufferObj - Pointer to buffer where i2c objects are stored
442:                   Returns:
443:                     None
444:                 */
445:                 
446:                 bool _DRV_I2C_IsQueueEmpty(DRV_I2C_OBJ *dObj)
447:                 {
448:                     
449:                 //    DRV_I2C_BUFFER_OBJECT * temp;
450:                     // Make sure that the pointer is valid inside out allocated space.
451:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D0036C0  3C03A001   LUI V1, -24575
9D0036C4  2463870C   ADDIU V1, V1, -30964
9D0036C8  1464000A   BNE V1, A0, 0x9D0036F4
9D0036CC  00001021   ADDU V0, ZERO, ZERO
452:                     {
453:                         return false;
454:                     }
455:                     // Make sure that this driver instance is actually in use.
456:                     if (dObj->inUse != true)
9D0036D0  3C02A001   LUI V0, -24575
9D0036D4  90428726   LBU V0, -30938(V0)
9D0036D8  10400006   BEQ V0, ZERO, 0x9D0036F4
9D0036DC  3C03A001   LUI V1, -24575
457:                     {
458:                         return false;
459:                     }
460:                     
461:                     
462:                     if (dObj->queueOut == dObj->queueIn)
9D0036E0  2463870C   ADDIU V1, V1, -30964
9D0036E4  8C640054   LW A0, 84(V1)
9D0036E8  8C620050   LW V0, 80(V1)
9D0036EC  00821026   XOR V0, A0, V0
9D0036F0  2C420001   SLTIU V0, V0, 1
463:                         return true;
464:                     
465:                     return false;
466:                     
467:                 
468:                 }
9D0036F4  03E00008   JR RA
9D0036F8  00000000   NOP
469:                 
470:                 // *****************************************************************************
471:                 /* Function:
472:                     DRV_I2C_BUFFER_OBJ* _DRV_I2C_QueuePush (DRV_I2C_OBJ *dObj, DRV_I2C_BUFFER_OBJECT *buf)
473:                 
474:                   Summary:
475:                  Adds a DRV_I2C_OBJ into a I2C Buffer Object
476:                 
477:                   Description:
478:                     This API adds an DRV_I2C_OBJ into a buffer containing I2C objects
479:                 
480:                   Parameters:
481:                     i2cDataObj   - Pointer to the data structure to be removed from the queue
482:                     i2cbufferObj - Pointer to buffer where i2c objects are stored
483:                   Returns:
484:                     None
485:                 */
486:                 
487:                 void _DRV_I2C_QueuePush(DRV_I2C_OBJ *dObj, DRV_I2C_BUFFER_OBJECT *buf)
488:                 {
489:                     
490:                     SYS_MODULE_INDEX drvIndex=(SYS_MODULE_INDEX)0;
491:                     
492:                     // Make sure that the pointer is valid inside out allocated space.
493:                     if (dObj < &gDrvI2CObj[0] || dObj > &gDrvI2CObj[DRV_I2C_INSTANCES_NUMBER-1])
9D00297C  3C02A001   LUI V0, -24575
9D002980  2442870C   ADDIU V0, V0, -30964
9D002984  1444002A   BNE V0, A0, 0x9D002A30
9D002988  3C02A001   LUI V0, -24575
494:                     {
495:                 	return;
496:                     }
497:                     // Make sure that this driver instance is actually in use.
498:                     if (dObj->inUse != true)
9D00298C  90428726   LBU V0, -30938(V0)
9D002990  10400027   BEQ V0, ZERO, 0x9D002A30
9D002994  3C02A001   LUI V0, -24575
499:                     {
500:                     	return;
501:                     }
502:                 
503:                     drvIndex = dObj->drvIndex;
504:                     if (buf < &gDrvI2CBufferObj[drvIndex][0] || buf > &gDrvI2CBufferObj[drvIndex][DRV_I2C_NUM_OF_BUFFER_OBJECTS])
9D002998  94428724   LHU V0, -30940(V0)
9D00299C  000218C0   SLL V1, V0, 3
9D0029A0  00022180   SLL A0, V0, 6
9D0029A4  00831823   SUBU V1, A0, V1
9D0029A8  000320C0   SLL A0, V1, 3
9D0029AC  00831823   SUBU V1, A0, V1
9D0029B0  3C04A001   LUI A0, -24575
9D0029B4  24848560   ADDIU A0, A0, -31392
9D0029B8  00831821   ADDU V1, A0, V1
9D0029BC  00A3182B   SLTU V1, A1, V1
9D0029C0  1460001B   BNE V1, ZERO, 0x9D002A30
9D0029C4  24440001   ADDIU A0, V0, 1
9D0029C8  000430C0   SLL A2, A0, 3
9D0029CC  00041980   SLL V1, A0, 6
9D0029D0  00661823   SUBU V1, V1, A2
9D0029D4  000320C0   SLL A0, V1, 3
9D0029D8  00831823   SUBU V1, A0, V1
9D0029DC  3C04A001   LUI A0, -24575
9D0029E0  24848560   ADDIU A0, A0, -31392
9D0029E4  00831821   ADDU V1, A0, V1
9D0029E8  0065282B   SLTU A1, V1, A1
9D0029EC  14A00010   BNE A1, ZERO, 0x9D002A30
9D0029F0  3C03A001   LUI V1, -24575
505:                     {
506:                     	return;
507:                     }
508:                 
509:                     dObj->queueHead = &gDrvI2CBufferObj[drvIndex][dObj->queueIn];
9D0029F4  2463870C   ADDIU V1, V1, -30964
9D0029F8  8C640050   LW A0, 80(V1)
9D0029FC  000428C0   SLL A1, A0, 3
9D002A00  00042180   SLL A0, A0, 6
9D002A04  00852023   SUBU A0, A0, A1
9D002A08  000228C0   SLL A1, V0, 3
9D002A0C  00021180   SLL V0, V0, 6
9D002A10  00451023   SUBU V0, V0, A1
9D002A14  000228C0   SLL A1, V0, 3
9D002A18  00A21023   SUBU V0, A1, V0
9D002A1C  00821021   ADDU V0, A0, V0
9D002A20  3C04A001   LUI A0, -24575
9D002A24  24848560   ADDIU A0, A0, -31392
9D002A28  00821021   ADDU V0, A0, V0
9D002A2C  AC620048   SW V0, 72(V1)
9D002A30  03E00008   JR RA
9D002A34  00000000   NOP
510:                     return;
511:                 }
512:                 
513:                 
514:                 //******************************************************************************
515:                 /* Function:
516:                     static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID   plibId,
517:                                                         DRV_I2C_OBJ_HANDLE     dObj,
518:                                                         DRV_I2C_INIT         * i2cInit )
519:                 
520:                   Summary:
521:                     Sets up the hardware from the initialization structure
522:                 
523:                   Description:
524:                     This routine sets up the hardware from the initialization structure.
525:                 
526:                   Remarks:
527:                     None.
528:                 */
529:                 
530:                 static void _DRV_I2C_SetupHardware ( const I2C_MODULE_ID plibId,
531:                                                      DRV_I2C_OBJ *dObj,
532:                                                      DRV_I2C_INIT * i2cInit )
533:                 {
534:                     /* Initialize the Interrupt Sources */
535:                     dObj->mstrInterruptSource   = i2cInit->mstrInterruptSource;
9D000A60  8E030034   LW V1, 52(S0)
9D000A64  AC430030   SW V1, 48(V0)
536:                     dObj->slaveInterruptSource  = i2cInit->slaveInterruptSource;
9D000A68  8E030038   LW V1, 56(S0)
9D000A6C  AC430034   SW V1, 52(V0)
537:                     dObj->errInterruptSource    = i2cInit->errInterruptSource;
9D000A70  8E03003C   LW V1, 60(S0)
9D000A74  AC430038   SW V1, 56(V0)
538:                 
539:                     /* Power state initialization */
540:                     if( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_IDLE_STOP )
9D000A78  92020000   LBU V0, 0(S0)
9D000A7C  24030002   ADDIU V1, ZERO, 2
9D000A80  54430005   BNEL V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D000A84  24030003   ADDIU V1, ZERO, 3
541:                     {
542:                         PLIB_I2C_StopInIdleEnable( plibId  );
543:                     }
544:                     else if( ( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_IDLE_RUN ) ||
9D000A98  50430005   BEQL V0, V1, 0x9D000AB0
9D000A9C  24022000   ADDIU V0, ZERO, 8192
9D000AA0  2403000F   ADDIU V1, ZERO, 15
9D000AA4  54430005   BNEL V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D000AA8  8E030000   LW V1, 0(S0)
545:                                 ( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.value ) == SYS_MODULE_POWER_RUN_FULL ) )
546:                     {
547:                         PLIB_I2C_StopInIdleDisable( plibId  );
548:                     }
549:                     else
550:                     {
551:                         if( _DRV_I2C_POWER_STATE_GET( i2cInit->moduleInit.sys.powerState ) == SYS_MODULE_POWER_IDLE_STOP )
9D000ABC  3063000F   ANDI V1, V1, 15
9D000AC0  24020002   ADDIU V0, ZERO, 2
9D000AC4  54620004   BNEL V1, V0, 0x9D000AD8
9D000AC8  8E030008   LW V1, 8(S0)
552:                         {
553:                             PLIB_I2C_StopInIdleEnable( plibId  );
554:                         }
555:                     }
556:                 
557:                      /* Set I2C operational mode -- Master or Slave */
558:                      dObj->i2cMode = _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode);
9D000A90  0B4002B6   J 0x9D000AD8
9D000A94  8E030008   LW V1, 8(S0)
9D000AB4  0B4002B6   J 0x9D000AD8
9D000AB8  8E030008   LW V1, 8(S0)
9D000AD4  8E030008   LW V1, 8(S0)
9D000AD8  3C02A001   LUI V0, -24575
9D000ADC  AC43872C   SW V1, -30932(V0)
559:                 
560:                      /* Set Baud Rate */
561:                      if ( DRV_I2C_MODE_MASTER == _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode))
9D000AE0  8E020008   LW V0, 8(S0)
9D000AE4  54400013   BNEL V0, ZERO, 0x9D000B34
9D000AE8  8E020028   LW V0, 40(S0)
562:                      {
563:                         PLIB_I2C_BaudRateSet ( plibId, SYS_CLK_PeripheralFrequencyGet(CLK_BUS_PERIPHERAL_1),
9D000AEC  0F400E46   JAL SYS_CLK_PeripheralFrequencyGet
9D000AF0  00002021   ADDU A0, ZERO, ZERO
564:                                                 _DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) );
565:                         dObj->modulemainstate = DRV_I2C_MODULE_IDLE;
9D000B28  3C02A001   LUI V0, -24575
9D000B2C  AC40874C   SW ZERO, -30900(V0)
566:                      }
567:                 
568:                      /* Set SLEW rate based on baud-rate; if baud-rate is either <= 100k
569:                         OR baud-rate = 1M; I2C2xCON.DISSLW = 1  */
570:                     if (_DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) <= 100000 ||
9D000B30  8E020028   LW V0, 40(S0)
9D000B34  3C030001   LUI V1, 1
9D000B38  346386A1   ORI V1, V1, -31071
9D000B3C  0043182B   SLTU V1, V0, V1
9D000B40  54600005   BNEL V1, ZERO, DRV_I2C_Initialize::_DRV_I2C_SetupHardware::PLIB_I2C_HighFrequencyEnable
9D000B44  24020200   ADDIU V0, ZERO, 512
9D000B48  3C03000F   LUI V1, 15
9D000B4C  24634240   ADDIU V1, V1, 16960
9D000B50  14430004   BNE V0, V1, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D000B54  24020200   ADDIU V0, ZERO, 512
571:                             _DRV_I2C_BAUD_RATE_VALUE_GET(i2cInit->baudRate) == 1000000 )
572:                     {
573:                         PLIB_I2C_HighFrequencyEnable(plibId);
574:                     }
575:                      else
576:                     {
577:                         PLIB_I2C_HighFrequencyDisable(plibId);
578:                     }
579:                 
580:                     /* SMBus Input Level */
581:                     dObj->buslevel = _DRV_I2C_SMBus_LEVEL_GET(i2cInit->buslevel);
9D000B5C  0B4002DB   J 0x9D000B6C
9D000B60  8E03002C   LW V1, 44(S0)
9D000B68  8E03002C   LW V1, 44(S0)
9D000B6C  3C02A001   LUI V0, -24575
9D000B70  AC438738   SW V1, -30920(V0)
582:                 
583:                     /* Slave Address width select */
584:                     if ( DRV_I2C_MODE_SLAVE == _DRV_I2C_OPERATION_MODE_GET(i2cInit->i2cMode))
9D000B74  8E030008   LW V1, 8(S0)
9D000B78  24020001   ADDIU V0, ZERO, 1
9D000B7C  54620029   BNEL V1, V0, 0x9D000C24
9D000B80  92030024   LBU V1, 36(S0)
585:                     {
586:                         dObj->modulemainstate = DRV_I2C_MODULE_IDLE;
9D000B84  3C02A001   LUI V0, -24575
9D000B88  AC40874C   SW ZERO, -30900(V0)
587:                 
588:                         if (DRV_I2C_7BIT_SLAVE == _DRV_I2C_ADDRESS_WIDTH_GET(i2cInit->addWidth))
9D000B8C  8E030020   LW V1, 32(S0)
9D000B90  24020001   ADDIU V0, ZERO, 1
9D000B94  14620007   BNE V1, V0, DRV_I2C_Initialize::_DRV_I2C_SetupHardware
9D000B98  96020026   LHU V0, 38(S0)
589:                             PLIB_I2C_SlaveAddress7BitSet(plibId, (I2C_SLAVE_ADDRESS_7bit)(i2cInit->slaveaddvalue>>1));
590:                         else
591:                             PLIB_I2C_SlaveAddress10BitSet (plibId,(i2cInit->slaveaddvalue>>1) );
592:                 
593:                         PLIB_I2C_SlaveClockStretchingEnable(plibId);
594:                         PLIB_I2C_ReservedAddressProtectEnable(plibId);
595:                         PLIB_I2C_GeneralCallDisable ( plibId );
596:                         PLIB_I2C_ReservedAddressProtectEnable(plibId);
597:                         PLIB_I2C_SlaveMask7BitSet ( plibId, i2cInit->maskslaveaddress );
598:                         _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
9D000BE8  3C02A001   LUI V0, -24575
9D000BEC  8C428740   LW V0, -30912(V0)
599:                         SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
600:                     }
601:                 
602:                     /* Allow reserved slave address */
603:                      dObj->reservedaddenable = _DRV_I2C_RESERVED_ADDRESS_EN_GET(i2cInit->reservedaddenable);
9D000C20  92030024   LBU V1, 36(S0)
9D000C24  3C02A001   LUI V0, -24575
9D000C28  2442870C   ADDIU V0, V0, -30964
9D000C2C  A0430028   SB V1, 40(V0)
604:                 
605:                 } /* _DRV_I2C_SetupHardware */
606:                 
607:                 //******************************************************************************
608:                 /* Function:
609:                     static void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj)
610:                 
611:                  Summary:
612:                     Invokes OSAL call
613:                 
614:                  Parameters:
615:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
616:                     				added to the queue.
617:                 
618:                   Remarks:
619:                     None.
620:                 */
621:                 
622:                 void _DRV_I2C_LockMutex(DRV_I2C_OBJ *dObj)
623:                 {
624:                     bool tmp = false;
625:                     tmp = tmp; // Remove compile warning 
626:                     Nop();
9D0027FC  00000040   SSNOP
627:                     if (OSAL_MUTEX_Lock(&dObj->mutexDriverInstance, OSAL_WAIT_FOREVER)  != OSAL_RESULT_TRUE) {/* Report error*/}
628:                 } /*    _DRV_I2C_LockMutex  */
629:                 
630:                 //******************************************************************************
631:                 /* Function:
632:                     static void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj)
633:                 
634:                  Summary:
635:                     Invokes OSAL call
636:                 
637:                  Parameters:
638:                     i2cDataObj   - Pointer to the structure which holds the data which is to be
639:                     				added to the queue.
640:                 
641:                   Remarks:
642:                     None.
643:                 */
644:                 
645:                 void _DRV_I2C_UnlockMutex(DRV_I2C_OBJ *dObj)
646:                 {
647:                     bool tmp = false;
648:                     tmp = tmp; // Remove compile warning
649:                     if (OSAL_MUTEX_Unlock(&dObj->mutexDriverInstance)  != OSAL_RESULT_TRUE) {/* Report error*/}
650:                 } /* _DRV_I2C_UnlockMutex */
651:                 
652:                 
653:                 // *****************************************************************************
654:                 // *****************************************************************************
655:                 // Section: Driver Interface Function Definitions
656:                 // *****************************************************************************
657:                 // *****************************************************************************
658:                 
659:                 //******************************************************************************
660:                 /* Function:
661:                     SYS_MODULE_OBJ DRV_I2C_Initialize ( const SYS_MODULE_INDEX  index,
662:                                                        const SYS_MODULE_INIT * const init )
663:                 
664:                   Summary:
665:                     Initializes hardware and data for the given instance of the I2C module
666:                 
667:                   Description:
668:                     This routine initializes hardware for the instance of the I2C module,
669:                     using the hardware initialization given data.  It also initializes all
670:                     necessary internal data.
671:                 
672:                   Parameters:
673:                     index           - Identifies the driver instance to be initialized
674:                 
675:                     init            - Pointer to the data structure containing all data
676:                                       necessary to initialize the hardware. This pointer may
677:                                       be null if no data is required and static initialization
678:                                       values are to be used.
679:                 
680:                   Returns:
681:                     If successful, returns a valid handle to a driver instance object.
682:                     Otherwise, it returns SYS_MODULE_OBJ_INVALID.
683:                 */
684:                 
685:                 SYS_MODULE_OBJ DRV_I2C_Initialize ( const SYS_MODULE_INDEX   drvIndex,
686:                                                    const SYS_MODULE_INIT    * const init )
687:                 {
9D0009C8  3084FFFF   ANDI A0, A0, -1
9D0009E4  27BDFFE0   ADDIU SP, SP, -32
9D0009E8  AFBF001C   SW RA, 28(SP)
9D0009EC  AFB10018   SW S1, 24(SP)
9D0009F0  AFB00014   SW S0, 20(SP)
688:                     DRV_I2C_INIT * i2cInit;
689:                     I2C_MODULE_ID i2cId;
690:                     
691:                     uint16_t index;
692:                     DRV_I2C_BUFFER_OBJECT   *lBufferObj;
693:                 
694:                     /* Validate the driver index */
695:                     if ( drvIndex >= DRV_I2C_INSTANCES_NUMBER )
9D0009CC  148000CF   BNE A0, ZERO, 0x9D000D0C
9D0009D0  2402FFFF   ADDIU V0, ZERO, -1
696:                     {
697:                         return SYS_MODULE_OBJ_INVALID;
698:                     }
699:                     DRV_I2C_OBJ *dObj = _DRV_I2C_INSTANCE_GET ( drvIndex );
700:                 
701:                     /* Cheap dead man's mutex during initialization to make sure two different
702:                        tasks don't try to initialize the same driver at the same time.*/
703:                 
704:                     if (dObj->inUse)
9D0009D4  3C02A001   LUI V0, -24575
9D0009D8  90438726   LBU V1, -30938(V0)
9D0009DC  146000CB   BNE V1, ZERO, 0x9D000D0C
9D0009E0  2402FFFF   ADDIU V0, ZERO, -1
705:                     {
706:                         return SYS_MODULE_OBJ_INVALID;
707:                     }
708:                 
709:                     if (i2cNumInited == 0)
9D0009F4  8F82802C   LW V0, -32724(GP)
9D0009F8  1440000C   BNE V0, ZERO, 0x9D000A2C
9D0009FC  00A08021   ADDU S0, A1, ZERO
710:                     {
711:                         memset(gDrvI2CClientObj, 0, sizeof(gDrvI2CClientObj));
9D000A00  3C03A001   LUI V1, -24575
9D000A04  AC6086E8   SW ZERO, -31000(V1)
9D000A08  246386E8   ADDIU V1, V1, -31000
9D000A0C  AC600004   SW ZERO, 4(V1)
9D000A10  AC600008   SW ZERO, 8(V1)
9D000A14  AC60000C   SW ZERO, 12(V1)
9D000A18  AC600010   SW ZERO, 16(V1)
9D000A1C  AC600014   SW ZERO, 20(V1)
9D000A20  AC600018   SW ZERO, 24(V1)
9D000A24  AC60001C   SW ZERO, 28(V1)
9D000A28  AC600020   SW ZERO, 32(V1)
712:                     }
713:                 
714:                     i2cNumInited++;
9D000A2C  24420001   ADDIU V0, V0, 1
9D000A30  AF82802C   SW V0, -32724(GP)
715:                 
716:                     /* Assign to the local pointer the init data passed */
717:                     i2cInit = ( DRV_I2C_INIT * ) init;
718:                 
719:                     /* Object is valid, set it in use */
720:                     dObj->inUse = true;
9D000A34  3C02A001   LUI V0, -24575
9D000A38  2442870C   ADDIU V0, V0, -30964
9D000A3C  24030001   ADDIU V1, ZERO, 1
9D000A40  A043001A   SB V1, 26(V0)
721:                 
722:                     /* Save the index of the driver. Important to know this
723:                     as we are using reference based accessing */
724:                     dObj->drvIndex = drvIndex;
9D000A44  A4400018   SH ZERO, 24(V0)
725:                 
726:                     /* Update the I2C Module Index */
727:                     dObj->i2cId = i2cInit->i2cId;
9D000A48  8E110004   LW S1, 4(S0)
9D000A4C  AC510004   SW S1, 4(V0)
728:                     
729:                     /* set QueueHead to NULL */
730:                     dObj->queueHead = NULL;
9D000A50  AC400048   SW ZERO, 72(V0)
731:                     
732:                     /* initialize QueueTail to NULL */
733:                     dObj->queueTail = NULL;
9D000A54  AC40004C   SW ZERO, 76(V0)
734:                     
735:                     dObj->queueIn = 0;
9D000A58  AC400050   SW ZERO, 80(V0)
736:                     
737:                     dObj->queueOut = 0;
9D000A5C  AC400054   SW ZERO, 84(V0)
738:                     
739:                     /* Speed up accessing, take it to a local variable */
740:                     i2cId = dObj->i2cId;
741:                 
742:                     /* Setup the Hardware */
743:                     _DRV_I2C_SetupHardware ( i2cId, dObj, i2cInit );
744:                 
745:                     /* Reset the number of clients */
746:                     dObj->numClients = 0;
9D000C30  A040001C   SB ZERO, 28(V0)
747:                 
748:                     /* Reset the locally used variables */
749:                     dObj->lastClientHandle  = DRV_I2C_CLIENTS_NUMBER+1;
9D000C34  24030002   ADDIU V1, ZERO, 2
9D000C38  AC430058   SW V1, 88(V0)
750:                 
751:                     dObj->operationStarting = i2cInit->operationStarting;
9D000C3C  8E030044   LW V1, 68(S0)
9D000C40  AC430064   SW V1, 100(V0)
9D000C44  3C02A001   LUI V0, -24575
9D000C48  24428560   ADDIU V0, V0, -31392
9D000C4C  24430188   ADDIU V1, V0, 392
752:                     
753:                     
754:                     for ( index=0; index<DRV_I2C_NUM_OF_BUFFER_OBJECTS; index++ )
9D000C5C  5443FFFD   BNEL V0, V1, 0x9D000C54
9D000C60  A0400000   SB ZERO, 0(V0)
755:                     {
756:                         lBufferObj = &gDrvI2CBufferObj [ drvIndex ][ index ];
757:                 
758:                         lBufferObj->inUse   = false;
9D000C50  A0400000   SB ZERO, 0(V0)
759:                         lBufferObj->next    = NULL;
9D000C54  AC400030   SW ZERO, 48(V0)
9D000C58  24420038   ADDIU V0, V0, 56
760:                     }
761:                 
762:                     /* Interrupt flag cleared on the safer side */
763:                 
764:                     _DRV_I2C_InterruptSourceClear( dObj->mstrInterruptSource );
9D000C64  3C05A001   LUI A1, -24575
9D000C68  24A2870C   ADDIU V0, A1, -30964
9D000C6C  8C460030   LW A2, 48(V0)
765:                     _DRV_I2C_InterruptSourceClear( dObj->slaveInterruptSource );
9D000C90  8C460034   LW A2, 52(V0)
766:                     _DRV_I2C_InterruptSourceClear( dObj->errInterruptSource );
9D000CA8  8C460038   LW A2, 56(V0)
767:                 
768:                     /* Set the current driver state */
769:                     dObj->status = SYS_STATUS_READY;
9D000CC0  24040002   ADDIU A0, ZERO, 2
9D000CC4  ACA4870C   SW A0, -30964(A1)
770:                     
771:                     dObj->interruptNestingCount = 0;
9D000CC8  AC400068   SW ZERO, 104(V0)
772:                 
773:                         /* Create the hardware instance mutex. */
774:                     if(OSAL_MUTEX_Create(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
775:                     {
776:                        return SYS_MODULE_OBJ_INVALID;
777:                     }
778:                     
779:                         /* Check if the global mutexes have been created. If not
780:                        then create these. */
781:                 
782:                     if(!gDrvI2CCommonDataObj.membersAreInitialized)
9D000CD0  9382804C   LBU V0, -32692(GP)
9D000CD4  14400006   BNE V0, ZERO, 0x9D000CF0
9D000CD8  34028000   ORI V0, ZERO, -32768
783:                     {
784:                         /* This means that mutexes where not created. Create them. */
785:                         if(OSAL_MUTEX_Create(&(gDrvI2CCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
786:                         {
787:                                  return SYS_MODULE_OBJ_INVALID;
788:                         }
789:                         if(OSAL_MUTEX_Create(&(gDrvI2CCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
790:                         {
791:                                  return SYS_MODULE_OBJ_INVALID;
792:                         }
793:                         /* Set this flag so that global mutexes get allocated only once */
794:                         gDrvI2CCommonDataObj.membersAreInitialized = true;
9D000CE8  A0430000   SB V1, 0(V0)
795:                     }
796:                         
797:                     /* Enable the I2C module */
798:                     PLIB_I2C_Enable( i2cId ) ;
799:                     
800:                     
801:                         /* if device used is PIC32MZ-EC*/
802:                     #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
803:                     /*   Errata for PIC32MZ where STOP condition is Bit-banged */
804:                         #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
805:                             if (i2cInit->i2cMode == DRV_I2C_MODE_MASTER)
806:                             {
807:                                 /* assign SCL and SDA ports for bit banging purposes*/
808:                                 dObj->portSCL   = i2cInit->portSCL;
809:                                 dObj->pinSCL    = i2cInit->pinSCL;
810:                                 dObj->portSDA   = i2cInit->portSDA;
811:                                 dObj->pinSDA    = i2cInit->pinSDA;
812:                                 
813:                                 /* set SDA to 0 */
814:                                 PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
815:                                 /* set SCL to 1 */
816:                                 PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
817:                                 /* set SDA to O/P */
818:                                 PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
819:                                 /* set SCL to I/P */
820:                                 PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
821:                             }
822:                         #endif
823:                     #endif
824:                 
825:                     /* Return the driver handle */
826:                     return( (SYS_MODULE_OBJ) dObj );
9D000CF4  3C02A001   LUI V0, -24575
9D000CF8  2442870C   ADDIU V0, V0, -30964
827:                 } /* DRV_I2C_Initialize */
9D000CFC  8FBF001C   LW RA, 28(SP)
9D000D00  8FB10018   LW S1, 24(SP)
9D000D04  8FB00014   LW S0, 20(SP)
9D000D08  27BD0020   ADDIU SP, SP, 32
9D000D0C  03E00008   JR RA
9D000D10  00000000   NOP
828:                 
829:                 
830:                 //******************************************************************************
831:                 /* Function:
832:                     void DRV_I2C_Deinitialize ( SYS_MODULE_OBJ object )
833:                 
834:                   Summary:
835:                     De-initializes the specific module instance of the I2C module
836:                 
837:                   Description:
838:                     De-initializes the specific module instance disabling its operation (and any
839:                     hardware for driver modules).  Resets all the internal data structures and
840:                     fields for the specified instance to the default settings.
841:                 
842:                   Parameters:
843:                     object          - Identifies the Driver Object returned by the Initialize
844:                                       interface
845:                 
846:                   Returns:
847:                     None
848:                 */
849:                 
850:                 void DRV_I2C_Deinitialize ( SYS_MODULE_OBJ object )
851:                 {
00000000  00000000   NOP
852:                 	DRV_I2C_OBJ *dObj = (DRV_I2C_OBJ*) object;
853:                 	I2C_MODULE_ID i2cId = dObj->i2cId;
854:                 	size_t iClient;
855:                 	uint8_t iDriver;
856:                 	if (dObj->inUse == false)
00000018  00000000   NOP
857:                 	{
858:                 		return;
859:                 	}
860:                 
861:                 	/* Interrupt De-Registration */
862:                 #if defined (DRV_I2C_INTERRUPT_MODE) && (DRV_I2C_INTERRUPT_MODE == true)
863:                      if (dObj->mstrInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->mstrInterruptSource);
00000024  00000000   NOP
864:                      if (dObj->slaveInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->slaveInterruptSource);
00000038  00000000   NOP
865:                      if (dObj->errInterruptEnabled) _DRV_I2C_InterruptSourceDisable(dObj->errInterruptSource);
0000004C  00000000   NOP
866:                 #endif
867:                 
868:                     PLIB_I2C_Disable(i2cId);
869:                     /* Delete the hardware instance mutex. */
870:                     if(OSAL_MUTEX_Delete(&(dObj->mutexDriverInstance)) != OSAL_RESULT_TRUE)
871:                     {
872:                        return;
873:                     }
874:                     
875:                     /* Check if the global mutexes have been created. If so
876:                        then delete these. */
877:                     if(gDrvI2CCommonDataObj.membersAreInitialized)
00000068  00000000   NOP
878:                     {
879:                         /* This means that mutexes where created. Delete them. */
880:                         if(OSAL_MUTEX_Delete(&(gDrvI2CCommonDataObj.mutexClientObjects)) != OSAL_RESULT_TRUE)
881:                         {
882:                                  return;
883:                         }
884:                         if(OSAL_MUTEX_Delete(&(gDrvI2CCommonDataObj.mutexBufferQueueObjects)) != OSAL_RESULT_TRUE)
885:                         {
886:                                  return;
887:                         }
888:                         /* Set this flag so that global mutexes get allocated only once */
889:                         gDrvI2CCommonDataObj.membersAreInitialized = false;
890:                     }
891:                         
892:                 
893:                 	for (iClient = 0; iClient < DRV_I2C_CLIENTS_NUMBER; iClient++)
894:                 	{
895:                         if (gDrvI2CClientObj[iClient].driverObject == dObj)
00000074  00000000   NOP
000000C4  00000000   NOP
896:                         {
897:                                 gDrvI2CClientObj[iClient].driverObject = NULL;
0000007C  00000000   NOP
898:                         }
899:                 	}
900:                 
901:                 	dObj->numClients = 0;
00000080  00000000   NOP
902:                 	dObj->isExclusive = false;
903:                 	/* Clear all the pending requests */
904:                         //while (_DRV_I2C_QueuePop(dObj) != NULL);
905:                     while ((_DRV_I2C_IsQueueEmpty(dObj) == false))        
00000084  00000000   NOP
00000094  00000000   NOP
906:                     {
907:                         _DRV_I2C_Advance_Queue(dObj);
0000008C  00000000   NOP
908:                     }
909:                     
910:                 	dObj->queueHead = NULL;
000000A4  00000000   NOP
911:                 	/* Set the Device Status */
912:                 	dObj->status = SYS_STATUS_UNINITIALIZED;
000000A8  00000000   NOP
913:                 
914:                 	/* Remove the driver usage */
915:                 	dObj->inUse = false;
000000AC  00000000   NOP
916:                 
917:                 	for (iDriver = 0; iDriver < DRV_I2C_INSTANCES_NUMBER; iDriver++)
918:                 	{
919:                         DRV_I2C_OBJ * obj = _DRV_I2C_INSTANCE_GET ( iDriver );
920:                 
921:                         if (obj->inUse == true)
000000B0  00000000   NOP
922:                         {
923:                             return;
924:                         }
925:                 	}
926:                     i2cNumInited--;
000000DC  00000000   NOP
927:                 
928:                     return;
929:                 
930:                 } /* DRV_I2C_Deinitialize */
000000BC  00000000   NOP
000000E4  00000000   NOP
931:                 
932:                 
933:                 //******************************************************************************
934:                 /* Function:
935:                     SYS_STATUS DRV_I2C_Status ( SYS_MODULE_OBJ object )
936:                 
937:                   Summary:
938:                     Provides the current status of the hardware instance of the I2C module
939:                 
940:                   Description:
941:                     This routine Provides the current status of the hardware instance of the
942:                     I2C module.
943:                 
944:                   Parameters:
945:                     object          - Identifies the Driver Object returned by the Initialize
946:                                       interface
947:                 
948:                   Returns:
949:                     SYS_STATUS_READY    Indicates that any previous module operation for the
950:                                         specified module has completed
951:                 
952:                     SYS_STATUS_BUSY     Indicates that a previous module operation for the
953:                                         specified module has not yet completed
954:                 
955:                     SYS_STATUS_ERROR    Indicates that the specified module is in an error state
956:                 */
957:                 
958:                 SYS_STATUS DRV_I2C_Status ( SYS_MODULE_OBJ object )
959:                 {
960:                     if ( object == SYS_MODULE_OBJ_INVALID )
00000000  00000000   NOP
961:                     {
962:                         //SYS_ASSERT( " Handle is invalid " );
963:                         return SYS_MODULE_OBJ_INVALID;
964:                     }
965:                     DRV_I2C_OBJ *dObj = (DRV_I2C_OBJ*) object;
966:                 
967:                     /* Return the status associated with the driver handle */
968:                     return ( dObj->status );
0000000C  00000000   NOP
969:                 } /* DRV_I2C_Status */
00000014  00000000   NOP
970:                 
971:                 
972:                 //******************************************************************************
973:                 /* Function:
974:                     void DRV_I2C_Tasks ( SYS_MODULE_OBJ object )
975:                 
976:                   Summary:
977:                     Used to maintain the driver's state machine and implement its ISR
978:                 
979:                   Description:
980:                     This routine is used to maintain the driver's internal state machine and
981:                     implement its ISR for interrupt-driven implementations.
982:                 
983:                   Parameters:
984:                     object          - Identifies the Driver Object returned by the Initialize
985:                                       interface
986:                 
987:                   Returns:
988:                     None.
989:                 */
990:                 
991:                 void DRV_I2C_Tasks ( SYS_MODULE_OBJ object )
992:                 {
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFB20018   SW S2, 24(SP)
9D00000C  AFB10014   SW S1, 20(SP)
9D000010  AFB00010   SW S0, 16(SP)
9D000014  00808021   ADDU S0, A0, ZERO
993:                 
994:                     DRV_I2C_OBJ             *dObj           = (DRV_I2C_OBJ*)object;
995:                     DRV_I2C_BUFFER_OBJECT   *lBufferObj     = dObj->taskLObj;
9D000018  8C91005C   LW S1, 92(A0)
996:                     I2C_MODULE_ID           i2cId           = dObj->i2cId;
997:                 
998:                     if ( object == SYS_MODULE_OBJ_INVALID )
9D00001C  2402FFFF   ADDIU V0, ZERO, -1
9D000020  10820263   BEQ A0, V0, 0x9D0009B0
9D000024  8C920004   LW S2, 4(A0)
999:                     {
1000:                        //SYS_ASSERT( " Handle is invalid " );
1001:                        return;
1002:                    }
1003:                    
1004:                        switch ( dObj->task )
9D000028  8C820044   LW V0, 68(A0)
9D00002C  2C42000A   SLTIU V0, V0, 10
9D000030  104001FA   BEQ V0, ZERO, 0x9D00081C
9D000034  3C029D00   LUI V0, -25344
9D000038  8C830044   LW V1, 68(A0)
9D00003C  00031880   SLL V1, V1, 2
9D000040  24420054   ADDIU V0, V0, 84
9D000044  00431021   ADDU V0, V0, V1
9D000048  8C420000   LW V0, 0(V0)
9D00004C  00400008   JR V0
9D000050  00000000   NOP
1005:                        {
1006:                            case DRV_I2C_TASK_SEND_DEVICE_ADDRESS:
1007:                
1008:                                /* Pop the first element from the queue */
1009:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D00007C  8C820020   LW V0, 32(A0)
9D000080  14400021   BNE V0, ZERO, 0x9D000108
9D000084  24030001   ADDIU V1, ZERO, 1
1010:                                {
1011:                                      if ( ( dObj->queueHead != NULL ) )
9D000088  8C820048   LW V0, 72(A0)
9D00008C  504001E4   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000090  8E020038   LW V0, 56(S0)
1012:                                      {
1013:                                        /* This should be a global variable since the control could
1014:                                        go out of this function */
1015:                                        dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D000094  0F400B8D   JAL _DRV_I2C_QueuePop
9D000098  00000000   NOP
9D00009C  00408821   ADDU S1, V0, ZERO
9D0000A0  AE02005C   SW V0, 92(S0)
1016:                
1017:                                        /* Take it to a local variable to avoid multiple referencing and to speed up */
1018:                                        lBufferObj   = dObj->taskLObj;
1019:                                                            
1020:                                        
1021:                                        if ( lBufferObj->operation == DRV_I2C_OP_READ )
9D0000A4  8C43000C   LW V1, 12(V0)
9D0000A8  24020001   ADDIU V0, ZERO, 1
9D0000AC  1462000A   BNE V1, V0, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteSend
9D0000B0  92220008   LBU V0, 8(S1)
1022:                                        {
1023:                                                                        
1024:                                            PLIB_I2C_TransmitterByteSend( i2cId,(DRV_I2C_OP_READ | lBufferObj->slaveaddresshighbyte) );
9D0000B4  34420001   ORI V0, V0, 1
1025:                                            
1026:                                            /* if it is a 10-bit address, then only MSB of the
1027:                                             * address needs to be send unlike a write; Thus for
1028:                                             * reads 7-bit and 10-bit follows the same logic
1029:                                             */
1030:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_REQUESTED;
9D0000C0  24020005   ADDIU V0, ZERO, 5
9D0000C4  AE22002C   SW V0, 44(S1)
1031:                                            
1032:                                            dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D0000C8  24030002   ADDIU V1, ZERO, 2
9D0000CC  AE030040   SW V1, 64(S0)
9D0000D0  0B400207   J 0x9D00081C
9D0000D4  AE020044   SW V0, 68(S0)
1033:                                            dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
1034:                                        }
1035:                                        else
1036:                                        {
1037:                                               
1038:                                            PLIB_I2C_TransmitterByteSend ( i2cId, lBufferObj->slaveaddresshighbyte ) ;
1039:                                            
1040:                                            /* if it is a 10-bit address, then subsequent state 
1041:                                             * will send the next byte of the address.
1042:                                             * Otherwise state is set to write data
1043:                                             */
1044:                                            
1045:                                            if (lBufferObj->slaveaddresslowbyte)
9D0000DC  92220009   LBU V0, 9(S1)
9D0000E0  10400004   BEQ V0, ZERO, 0x9D0000F4
9D0000E4  24020006   ADDIU V0, ZERO, 6
1046:                                            {
1047:                                                dObj->task = DRV_I2C_SEND_DEVICE_ADDRESS_BYTE_2;
9D0000E8  24020001   ADDIU V0, ZERO, 1
9D0000EC  0B400207   J 0x9D00081C
9D0000F0  AE020044   SW V0, 68(S0)
1048:                                            }
1049:                                            else
1050:                                            {
1051:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED;  
9D0000F4  AE22002C   SW V0, 44(S1)
1052:                                                  
1053:                                                dObj->task = lBufferObj->operation + DRV_I2C_TASK_PROCESS_WRITE_ONLY;
9D0000F8  8E22000C   LW V0, 12(S1)
9D0000FC  24420002   ADDIU V0, V0, 2
9D000100  0B400207   J 0x9D00081C
9D000104  AE020044   SW V0, 68(S0)
1054:                                            }
1055:                                        }
1056:                                    }
1057:                                }
1058:                                else if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_SLAVE)
9D000108  544301C5   BNEL V0, V1, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D00010C  8E020038   LW V0, 56(S0)
1059:                                {
1060:                                    /* master writing data to slave when R/W = 0 and Address is detected */
1061:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D000110  AC800044   SW ZERO, 68(A0)
1062:                
1063:                                    /* Slave is accepting data from Master */
1064:                                    if ( (!PLIB_I2C_SlaveReadIsRequested(i2cId)) && (PLIB_I2C_SlaveAddressIsDetected(i2cId)) )
9D00011C  14400017   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D000120  00000000   NOP
9D00012C  14400013   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D000130  24020003   ADDIU V0, ZERO, 3
1065:                                    {
1066:                                        /* slave is set to accept data from master */
1067:                                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_RX_FROM_MASTER;
1068:                
1069:                                        if (lBufferObj)
9D000134  12200002   BEQ S1, ZERO, 0x9D000140
9D000138  AC820040   SW V0, 64(A0)
1070:                                        {
1071:                                            lBufferObj->inUse = false;
9D00013C  A2200000   SB ZERO, 0(S1)
1072:                                        }
1073:                
1074:                                        if (dObj->operationStarting)
9D000140  8E020064   LW V0, 100(S0)
9D000144  10400003   BEQ V0, ZERO, 0x9D000154
9D000148  24040005   ADDIU A0, ZERO, 5
1075:                                        {
1076:                                            dObj->operationStarting(DRV_I2C_BUFFER_SLAVE_READ_REQUESTED, 0);
9D00014C  0040F809   JALR V0
9D000150  00002821   ADDU A1, ZERO, ZERO
1077:                                        }
1078:                
1079:                                        /* This should be a global variable since the control could
1080:                                            go out of this function */
1081:                                        dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D000154  0F400B8D   JAL _DRV_I2C_QueuePop
9D000158  02002021   ADDU A0, S0, ZERO
9D00015C  00408821   ADDU S1, V0, ZERO
9D000160  AE02005C   SW V0, 92(S0)
1082:                
1083:                                        /* Take it to a local variable to avoid multiple referencing and to speed up */
1084:                                        lBufferObj   = dObj->taskLObj;
1085:                
1086:                                        lBufferObj->actualtransfersize = 0;
9D000164  AC400020   SW ZERO, 32(V0)
1087:                
1088:                                        /* do a dummy read so that I2CxRCV is cleared and not clobbered with data */
1089:                                        PLIB_I2C_ReceivedByteGet (i2cId);
1090:                                        PLIB_I2C_SlaveClockRelease (i2cId);
1091:                                    }
1092:                                    /*  Slave is sending data back to the Master    */
1093:                                    else if ( (PLIB_I2C_SlaveReadIsRequested(i2cId)) && (PLIB_I2C_SlaveAddressIsDetected(i2cId)) )
9D000184  10400022   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D000188  00000000   NOP
9D000194  1440001E   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D000198  00000000   NOP
1094:                                    {
1095:                
1096:                                        PLIB_I2C_ReceivedByteGet ( i2cId );
1097:                
1098:                                        PLIB_I2C_SlaveClockHold (i2cId);
1099:                
1100:                                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_TX_TO_MASTER;
9D0001A8  24020004   ADDIU V0, ZERO, 4
1101:                
1102:                                        if (lBufferObj)
9D0001AC  12200002   BEQ S1, ZERO, 0x9D0001B8
9D0001B0  AE020040   SW V0, 64(S0)
1103:                                        {
1104:                                            lBufferObj->inUse = false;
9D0001B4  A2200000   SB ZERO, 0(S1)
1105:                                        }
1106:                
1107:                                        if (dObj->operationStarting)
9D0001B8  8E020064   LW V0, 100(S0)
9D0001BC  10400003   BEQ V0, ZERO, 0x9D0001CC
9D0001C0  24040006   ADDIU A0, ZERO, 6
1108:                                        {
1109:                                            dObj->operationStarting(DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED, 0);
9D0001C4  0040F809   JALR V0
9D0001C8  00002821   ADDU A1, ZERO, ZERO
1110:                                        }
1111:                                        lBufferObj = dObj->taskLObj = _DRV_I2C_QueuePop(dObj);
9D0001CC  0F400B8D   JAL _DRV_I2C_QueuePop
9D0001D0  02002021   ADDU A0, S0, ZERO
9D0001D4  00408821   ADDU S1, V0, ZERO
9D0001D8  AE02005C   SW V0, 92(S0)
1112:                
1113:                                        lBufferObj->actualtransfersize = 0;
9D0001DC  AC400020   SW ZERO, 32(V0)
1114:                
1115:                                        // transmit first byte
1116:                                        PLIB_I2C_TransmitterByteSend(_DRV_I2C_PERIPHERAL_ID_GET(i2cId), *lBufferObj->txBuffer++);
9D0001E0  8C420010   LW V0, 16(V0)
9D0001E4  24430001   ADDIU V1, V0, 1
9D0001E8  AE230010   SW V1, 16(S1)
1117:                                        lBufferObj->actualtransfersize++;
9D0001F4  8E220020   LW V0, 32(S1)
9D0001F8  24420001   ADDIU V0, V0, 1
9D0001FC  AE220020   SW V0, 32(S1)
1118:                                        PLIB_I2C_SlaveClockRelease ( i2cId );
1119:                                    }
1120:                                    else if ( (!PLIB_I2C_SlaveReadIsRequested(i2cId)) && PLIB_I2C_SlaveDataIsDetected( i2cId ))
9D000218  1440003B   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D00021C  00000000   NOP
9D000228  10400037   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_SlaveReadIsRequested
9D00022C  24020003   ADDIU V0, ZERO, 3
1121:                                    {
1122:                                        /*        Master sends data to the slave        */
1123:                                        if (dObj->modulemainstate == DRV_I2C_SLAVE_READY_TO_RX_FROM_MASTER)
9D000230  8E030040   LW V1, 64(S0)
9D000234  5462017A   BNEL V1, V0, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000238  8E020038   LW V0, 56(S0)
1124:                                        {
1125:                                            PLIB_I2C_SlaveClockRelease ( i2cId );
1126:                
1127:                                            if (lBufferObj->actualtransfersize < lBufferObj->transferSize)
9D000244  8E230020   LW V1, 32(S1)
9D000248  8E220018   LW V0, 24(S1)
9D00024C  0062102B   SLTU V0, V1, V0
9D000250  1040001B   BEQ V0, ZERO, 0x9D0002C0
9D000254  24020002   ADDIU V0, ZERO, 2
1128:                                            {
1129:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet ( i2cId );
9D000258  8E220014   LW V0, 20(S1)
9D00025C  24430001   ADDIU V1, V0, 1
9D000260  AE230014   SW V1, 20(S1)
1130:                                                lBufferObj->actualtransfersize++;
9D00026C  8E220020   LW V0, 32(S1)
9D000270  24420001   ADDIU V0, V0, 1
9D000274  AE220020   SW V0, 32(S1)
1131:                
1132:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_BYTE;
9D000278  24020007   ADDIU V0, ZERO, 7
9D00027C  AE22002C   SW V0, 44(S1)
1133:                
1134:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D000280  8E220004   LW V0, 4(S1)
9D000284  8C420020   LW V0, 32(V0)
9D000288  10400164   BEQ V0, ZERO, 0x9D00081C
9D00028C  24040007   ADDIU A0, ZERO, 7
1135:                                                {
1136:                                                    /*  Call the event handler. Increment the interrupt nesting
1137:                                                        count which lets the driver functions that are called
1138:                                                        from the event handler know that an interrupt context
1139:                                                        is active.
1140:                                                    */
1141:                                                    
1142:                                                    dObj->interruptNestingCount++;
9D000290  8E020068   LW V0, 104(S0)
9D000294  24420001   ADDIU V0, V0, 1
9D000298  AE020068   SW V0, 104(S0)
1143:                                                    
1144:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D00029C  8E220004   LW V0, 4(S1)
1145:                                                                callback)( DRV_I2C_BUFFER_SLAVE_READ_BYTE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D0002A0  8C420020   LW V0, 32(V0)
9D0002A4  02202821   ADDU A1, S1, ZERO
9D0002A8  0040F809   JALR V0
9D0002AC  00003021   ADDU A2, ZERO, ZERO
1146:                                                    
1147:                                                    dObj->interruptNestingCount--;
9D0002B0  8E020068   LW V0, 104(S0)
9D0002B4  2442FFFF   ADDIU V0, V0, -1
9D0002B8  0B400207   J 0x9D00081C
9D0002BC  AE020068   SW V0, 104(S0)
1148:                                                }
1149:                                            }
1150:                                            else
1151:                                            {
1152:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D0002C0  AE22002C   SW V0, 44(S1)
1153:                
1154:                                                PLIB_I2C_ReceivedByteGet ( i2cId );
1155:                
1156:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D0002C8  8E220004   LW V0, 4(S1)
9D0002CC  8C420020   LW V0, 32(V0)
9D0002D0  10400152   BEQ V0, ZERO, 0x9D00081C
9D0002D4  24040002   ADDIU A0, ZERO, 2
1157:                                                {
1158:                                                    /*  Call the event handler. Increment the interrupt nesting
1159:                                                        count which lets the driver functions that are called
1160:                                                        from the event handler know that an interrupt context
1161:                                                        is active.
1162:                                                    */
1163:                                                    
1164:                                                    dObj->interruptNestingCount++;
9D0002D8  8E020068   LW V0, 104(S0)
9D0002DC  24420001   ADDIU V0, V0, 1
9D0002E0  AE020068   SW V0, 104(S0)
1165:                                                    
1166:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D0002E4  8E220004   LW V0, 4(S1)
1167:                                                                callback)( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D0002E8  8C420020   LW V0, 32(V0)
9D0002EC  02202821   ADDU A1, S1, ZERO
9D0002F0  0040F809   JALR V0
9D0002F4  00003021   ADDU A2, ZERO, ZERO
1168:                                                    
1169:                                                    dObj->interruptNestingCount--;
9D0002F8  8E020068   LW V0, 104(S0)
9D0002FC  2442FFFF   ADDIU V0, V0, -1
9D000300  0B400207   J 0x9D00081C
9D000304  AE020068   SW V0, 104(S0)
1170:                                                }
1171:                                            }
1172:                                        }
1173:                                    }
1174:                                    else if (PLIB_I2C_SlaveReadIsRequested(i2cId) && PLIB_I2C_SlaveDataIsDetected( i2cId ))
9D000310  50400143   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000314  8E020038   LW V0, 56(S0)
9D000320  5040013F   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000324  8E020038   LW V0, 56(S0)
1175:                                    {
1176:                                        PLIB_I2C_SlaveClockHold (i2cId);
1177:                
1178:                                        if ( PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D000338  14400036   BNE V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteWasAcknowledged
9D00033C  00000000   NOP
1179:                                        {
1180:                                            if ( lBufferObj->actualtransfersize < lBufferObj->transferSize )
9D000340  8E230020   LW V1, 32(S1)
9D000344  8E220018   LW V0, 24(S1)
9D000348  0062102B   SLTU V0, V1, V0
9D00034C  1040001E   BEQ V0, ZERO, 0x9D0003C8
9D000350  24020002   ADDIU V0, ZERO, 2
1181:                                            {
1182:                                                PLIB_I2C_SlaveClockRelease(i2cId);
1183:                                                PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D00035C  8E220010   LW V0, 16(S1)
9D000360  24430001   ADDIU V1, V0, 1
9D000364  AE230010   SW V1, 16(S1)
1184:                                                lBufferObj->actualtransfersize++;
9D000370  8E220020   LW V0, 32(S1)
9D000374  24420001   ADDIU V0, V0, 1
9D000378  AE220020   SW V0, 32(S1)
1185:                                                lBufferObj->inUse = false;
9D00037C  A2200000   SB ZERO, 0(S1)
1186:                
1187:                                                _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_BYTE;
9D000380  2402000A   ADDIU V0, ZERO, 10
9D000384  AE22002C   SW V0, 44(S1)
1188:                
1189:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D000388  8E220004   LW V0, 4(S1)
9D00038C  8C420020   LW V0, 32(V0)
9D000390  10400122   BEQ V0, ZERO, 0x9D00081C
9D000394  2404000A   ADDIU A0, ZERO, 10
1190:                                                {
1191:                                                    /*  Call the event handler. Increment the interrupt nesting
1192:                                                        count which lets the driver functions that are called
1193:                                                        from the event handler know that an interrupt context
1194:                                                        is active.
1195:                                                    */
1196:                                                    
1197:                                                    dObj->interruptNestingCount++;
9D000398  8E020068   LW V0, 104(S0)
9D00039C  24420001   ADDIU V0, V0, 1
9D0003A0  AE020068   SW V0, 104(S0)
1198:                                                    
1199:                                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle),
9D0003A4  8E220004   LW V0, 4(S1)
1200:                                                                callback)( DRV_I2C_BUFFER_SLAVE_WRITE_BYTE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D0003A8  8C420020   LW V0, 32(V0)
9D0003AC  02202821   ADDU A1, S1, ZERO
9D0003B0  0040F809   JALR V0
9D0003B4  00003021   ADDU A2, ZERO, ZERO
1201:                                                                                                                            
1202:                                                    dObj->interruptNestingCount--;
9D0003B8  8E020068   LW V0, 104(S0)
9D0003BC  2442FFFF   ADDIU V0, V0, -1
9D0003C0  0B400207   J 0x9D00081C
9D0003C4  AE020068   SW V0, 104(S0)
1203:                                                }
1204:                                            }
1205:                                            else
1206:                                            {
1207:                                               _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D0003C8  AE22002C   SW V0, 44(S1)
1208:                
1209:                                                /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1210:                                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D0003CC  8E220004   LW V0, 4(S1)
9D0003D0  8C420020   LW V0, 32(V0)
9D0003D4  1040000C   BEQ V0, ZERO, DRV_I2C_Tasks::PLIB_I2C_TransmitterByteSend
9D0003D8  24040002   ADDIU A0, ZERO, 2
1211:                                                {
1212:                                                    /*  Call the event handler. Increment the interrupt nesting
1213:                                                        count which lets the driver functions that are called
1214:                                                        from the event handler know that an interrupt context
1215:                                                        is active.
1216:                                                    */
1217:                                                    
1218:                                                    dObj->interruptNestingCount++;
9D0003DC  8E020068   LW V0, 104(S0)
9D0003E0  24420001   ADDIU V0, V0, 1
9D0003E4  AE020068   SW V0, 104(S0)
1219:                                                    
1220:                                                    /* Give an indication to the higher layer upon successful transmission */
1221:                                                   _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D0003E8  8E220004   LW V0, 4(S1)
1222:                                                            ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D0003EC  8C420020   LW V0, 32(V0)
9D0003F0  02202821   ADDU A1, S1, ZERO
9D0003F4  0040F809   JALR V0
9D0003F8  00003021   ADDU A2, ZERO, ZERO
1223:                                                   
1224:                                                    dObj->interruptNestingCount--;
9D0003FC  8E020068   LW V0, 104(S0)
9D000400  2442FFFF   ADDIU V0, V0, -1
9D000404  AE020068   SW V0, 104(S0)
1225:                                                }
1226:                                                /* dummy write - pad with zeros - cases where master requests more data than what is in buffer */
1227:                                                PLIB_I2C_TransmitterByteSend(_DRV_I2C_PERIPHERAL_ID_GET(i2cId), 0);
1228:                                            }
1229:                                        }
1230:                                        else if ( !PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D00041C  50400100   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000420  8E020038   LW V0, 56(S0)
1231:                                        {
1232:                
1233:                                           _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_COMPLETE;
9D000424  24020001   ADDIU V0, ZERO, 1
9D000428  AE22002C   SW V0, 44(S1)
1234:                
1235:                                             /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1236:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D00042C  8E220004   LW V0, 4(S1)
9D000430  8C420020   LW V0, 32(V0)
9D000434  104000F9   BEQ V0, ZERO, 0x9D00081C
9D000438  24040001   ADDIU A0, ZERO, 1
1237:                                            {
1238:                                                /*  Call the event handler. Increment the interrupt nesting
1239:                                                    count which lets the driver functions that are called
1240:                                                    from the event handler know that an interrupt context
1241:                                                    is active.
1242:                                                */
1243:                                                    
1244:                                                dObj->interruptNestingCount++;
9D00043C  8E020068   LW V0, 104(S0)
9D000440  24420001   ADDIU V0, V0, 1
9D000444  AE020068   SW V0, 104(S0)
1245:                                                
1246:                                                /* Give an indication to the higher layer upon successful transmission */
1247:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D000448  8E220004   LW V0, 4(S1)
1248:                                                      ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D00044C  8C420020   LW V0, 32(V0)
9D000450  02202821   ADDU A1, S1, ZERO
9D000454  0040F809   JALR V0
9D000458  00003021   ADDU A2, ZERO, ZERO
1249:                                                
1250:                                                dObj->interruptNestingCount--;
9D00045C  8E020068   LW V0, 104(S0)
9D000460  2442FFFF   ADDIU V0, V0, -1
9D000464  0B400207   J 0x9D00081C
9D000468  AE020068   SW V0, 104(S0)
1251:                                            }
1252:                                        }
1253:                                    }
1254:                                }
1255:                                break;
1256:                            case DRV_I2C_SEND_DEVICE_ADDRESS_BYTE_2:
1257:                
1258:                                if ( lBufferObj->operation == DRV_I2C_OP_READ )
9D00046C  8E23000C   LW V1, 12(S1)
9D000470  24020001   ADDIU V0, ZERO, 1
9D000474  1462000A   BNE V1, V0, 0x9D0004A0
9D000478  24020006   ADDIU V0, ZERO, 6
1259:                                {                    
1260:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_READ_REQUESTED;
9D00047C  24020005   ADDIU V0, ZERO, 5
9D000480  AE22002C   SW V0, 44(S1)
1261:                                         
1262:                                    dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D000484  24030002   ADDIU V1, ZERO, 2
9D000488  AC830040   SW V1, 64(A0)
1263:                                    PLIB_I2C_TransmitterByteSend( i2cId,lBufferObj->slaveaddresslowbyte>>1) ;
9D00048C  92230009   LBU V1, 9(S1)
1264:                                    dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
1265:                                }
1266:                                else
1267:                                {
1268:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_SLAVE_WRITE_REQUESTED;
9D0004A0  AE22002C   SW V0, 44(S1)
1269:                                                                
1270:                                    PLIB_I2C_TransmitterByteSend (i2cId, lBufferObj->slaveaddresslowbyte>>1) ;
9D0004A4  92220009   LBU V0, 9(S1)
1271:                                    dObj->task = lBufferObj->operation + DRV_I2C_TASK_PROCESS_WRITE_ONLY;
9D0004B0  8E22000C   LW V0, 12(S1)
9D0004B4  24420002   ADDIU V0, V0, 2
9D0004B8  0B400207   J 0x9D00081C
9D0004BC  AC820044   SW V0, 68(A0)
1272:                                }
1273:                                
1274:                                break;
1275:                            case DRV_I2C_SEND_RANDOM_READ_DEVICE_ADDRESS:
1276:                                    dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D0004C0  24020002   ADDIU V0, ZERO, 2
9D0004C4  AC820040   SW V0, 64(A0)
1277:                                    PLIB_I2C_TransmitterByteSend( i2cId,(DRV_I2C_OP_READ | lBufferObj->slaveaddresshighbyte) );
9D0004C8  92220008   LBU V0, 8(S1)
9D0004CC  34420001   ORI V0, V0, 1
1278:                                    dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
9D0004D8  24020005   ADDIU V0, ZERO, 5
1279:                                break;             
9D0004DC  0B400207   J 0x9D00081C
9D0004E0  AC820044   SW V0, 68(A0)
1280:                            case DRV_I2C_TASK_PROCESS_READ_ONLY:
1281:                                /* Read I2CxRCV register for received data */
1282:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D0004E4  8C820020   LW V0, 32(A0)
9D0004E8  544000CD   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0004EC  8E020038   LW V0, 56(S0)
1283:                                {
1284:                                    if (lBufferObj->transferSize)
9D0004F0  8E220018   LW V0, 24(S1)
9D0004F4  504000CA   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0004F8  8E020038   LW V0, 56(S0)
1285:                                    {
1286:                                        dObj->modulemainstate = DRV_I2C_MASTER_RX_FROM_SLAVE;
9D0004FC  24020002   ADDIU V0, ZERO, 2
9D000500  AC820040   SW V0, 64(A0)
1287:                
1288:                                        if ( PLIB_I2C_ReceivedByteIsAvailable (i2cId) )
9D00050C  504000C4   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000510  8E020038   LW V0, 56(S0)
1289:                                        {
1290:                                            /* If all but one reception is complete */
1291:                                            if ( lBufferObj->transferSize > 1 )
9D000514  8E220018   LW V0, 24(S1)
9D000518  2C430002   SLTIU V1, V0, 2
9D00051C  1460001A   BNE V1, ZERO, 0x9D000588
9D000520  2442FFFF   ADDIU V0, V0, -1
1292:                                            {
1293:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet (i2cId);
9D000524  8E220014   LW V0, 20(S1)
9D000528  24430001   ADDIU V1, V0, 1
9D00052C  AE230014   SW V1, 20(S1)
1294:                                                lBufferObj->transferSize--;
9D000538  8E220018   LW V0, 24(S1)
9D00053C  2442FFFF   ADDIU V0, V0, -1
9D000540  AE220018   SW V0, 24(S1)
1295:                                                lBufferObj->actualtransfersize++;
9D000544  8E220020   LW V0, 32(S1)
9D000548  24420001   ADDIU V0, V0, 1
9D00054C  AE220020   SW V0, 32(S1)
1296:                                                dObj->task = DRV_I2C_TASK_SET_RCEN_ONLY;
9D000550  24020005   ADDIU V0, ZERO, 5
9D000554  AC820044   SW V0, 68(A0)
1297:                                                
1298:                                                if (PLIB_I2C_MasterReceiverReadyToAcknowledge(i2cId))
9D000560  544000AF   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000564  8E020038   LW V0, 56(S0)
1299:                                                {
1300:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_MASTER_ACK_SEND;
9D000568  24020008   ADDIU V0, ZERO, 8
9D00056C  AE22002C   SW V0, 44(S1)
1301:                                                                                                    
1302:                                                    PLIB_I2C_ReceivedByteAcknowledge ( i2cId, true );
1303:                                                }
1304:                                            }
1305:                                            else
1306:                                            {
1307:                                                lBufferObj->transferSize--;
9D000588  AE220018   SW V0, 24(S1)
1308:                                                lBufferObj->actualtransfersize++;
9D00058C  8E220020   LW V0, 32(S1)
9D000590  24420001   ADDIU V0, V0, 1
9D000594  AE220020   SW V0, 32(S1)
1309:                
1310:                                                *lBufferObj->rxBuffer++ = PLIB_I2C_ReceivedByteGet ( i2cId );
9D000598  8E220014   LW V0, 20(S1)
9D00059C  24430001   ADDIU V1, V0, 1
9D0005A0  AE230014   SW V1, 20(S1)
1311:                                                if (PLIB_I2C_MasterReceiverReadyToAcknowledge(i2cId))
9D0005B4  14400006   BNE V0, ZERO, 0x9D0005D0
9D0005B8  24020007   ADDIU V0, ZERO, 7
1312:                                                {                                    
1313:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_MASTER_NACK_SEND;
9D0005BC  24020009   ADDIU V0, ZERO, 9
9D0005C0  AE22002C   SW V0, 44(S1)
1314:                                                                                                    
1315:                                                    PLIB_I2C_ReceivedByteAcknowledge ( i2cId, false  );
1316:                                                }
1317:                
1318:                                                dObj->task = DRV_I2C_BUS_SILENT;
9D0005CC  24020007   ADDIU V0, ZERO, 7
9D0005D0  0B400207   J 0x9D00081C
9D0005D4  AE020044   SW V0, 68(S0)
1319:                                            }
1320:                                        }
1321:                                        else
1322:                                        {
1323:                                            // Do not block in any case
1324:                                            break;
1325:                                        }
1326:                                    }
1327:                                }
1328:                                break;
1329:                            case DRV_I2C_TASK_PROCESS_WRITE_ONLY:
1330:                            case DRV_I2C_TASK_PROCESS_WRITE_READ:
1331:                
1332:                                if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D0005D8  8C820020   LW V0, 32(A0)
9D0005DC  54400090   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0005E0  8E020038   LW V0, 56(S0)
1333:                                {
1334:                                    /* Loop till the transmit size, do not block though */
1335:                                    if( lBufferObj->transferSize )
9D0005E4  8E220018   LW V0, 24(S1)
9D0005E8  5040002C   BEQL V0, ZERO, 0x9D00069C
9D0005EC  24020008   ADDIU V0, ZERO, 8
1336:                                    {
1337:                                        if ( PLIB_I2C_TransmitterByteHasCompleted (_DRV_I2C_PERIPHERAL_ID_GET (i2cId)) )
9D0005F8  54600089   BNEL V1, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0005FC  8E020038   LW V0, 56(S0)
1338:                                        {
1339:                                            if ( PLIB_I2C_TransmitterByteWasAcknowledged (_DRV_I2C_PERIPHERAL_ID_GET (i2cId)) ||
9D000608  10600005   BEQ V1, ZERO, 0x9D000620
9D00060C  2C430002   SLTIU V1, V0, 2
9D000610  92230024   LBU V1, 36(S1)
9D000614  5060001C   BEQL V1, ZERO, 0x9D000688
9D000618  24020008   ADDIU V0, ZERO, 8
1340:                                                   (lBufferObj->transmitForced)  )
1341:                                            {
1342:                                                /* Handle the overflow */
1343:                                                if ( lBufferObj->transferSize > 1 )
9D00061C  2C430002   SLTIU V1, V0, 2
9D000620  1460000D   BNE V1, ZERO, 0x9D000658
9D000624  2442FFFF   ADDIU V0, V0, -1
1344:                                                {
1345:                                                    lBufferObj->actualtransfersize++;
9D000628  8E220020   LW V0, 32(S1)
9D00062C  24420001   ADDIU V0, V0, 1
9D000630  AE220020   SW V0, 32(S1)
1346:                                                    PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D000634  8E220010   LW V0, 16(S1)
9D000638  24430001   ADDIU V1, V0, 1
9D00063C  AE230010   SW V1, 16(S1)
1347:                                                    lBufferObj->transferSize--;
9D000648  8E220018   LW V0, 24(S1)
9D00064C  2442FFFF   ADDIU V0, V0, -1
9D000650  0B400207   J 0x9D00081C
9D000654  AE220018   SW V0, 24(S1)
1348:                                                }
1349:                                                else
1350:                                                {
1351:                                                    lBufferObj->transferSize--;
9D000658  AE220018   SW V0, 24(S1)
1352:                                                    lBufferObj->actualtransfersize++;
9D00065C  8E220020   LW V0, 32(S1)
9D000660  24420001   ADDIU V0, V0, 1
9D000664  AE220020   SW V0, 32(S1)
1353:                                                    
1354:                                                    PLIB_I2C_TransmitterByteSend ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ), *lBufferObj->txBuffer++ );
9D000668  8E220010   LW V0, 16(S1)
9D00066C  24430001   ADDIU V1, V0, 1
9D000670  AE230010   SW V1, 16(S1)
1355:                
1356:                                                    dObj->task = DRV_I2C_BUS_SILENT;
9D00067C  24020007   ADDIU V0, ZERO, 7
9D000680  0B400207   J 0x9D00081C
9D000684  AE020044   SW V0, 68(S0)
1357:                
1358:                                                }
1359:                                            }
1360:                                            else
1361:                                            {
1362:                                                #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1363:                                                /*   Errata for PIC32MZ which requires reset of I2C module */
1364:                                                         
1365:                                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1366:                                                    
1367:                                                    /* alternate method to do STOP (previous errata note) */  
1368:                                                                                        
1369:                                                    #ifdef MZ_EC_ERRATA_25_BB_STOP                
1370:                                                        /* Bit bang procedure for STOP */
1371:                
1372:                                                        starttime = ReadCoreTimer();
1373:                                                        while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1374:                
1375:                                                        /* Disable I2C */
1376:                                                        PLIB_I2C_Disable(i2cId);
1377:                
1378:                                                        /* Wait 2 BRG */
1379:                                                        starttime = ReadCoreTimer();
1380:                                                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1381:                
1382:                                                        /* Set SDA as I/P */
1383:                                                        PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1384:                
1385:                                                        /* Wait 3 BRG */
1386:                                                        starttime = ReadCoreTimer();
1387:                                                        while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1388:                
1389:                                                        PLIB_I2C_Enable(i2cId);
1390:                                                        PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1391:                                                        PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1392:                                                        PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1393:                                                        PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1394:                
1395:                                                        /* End-of-Bit-Bang procedure for STOP */
1396:                                                    #else                                                    
1397:                                                      PLIB_I2C_Disable(i2cId);
1398:                                                      PLIB_I2C_Enable(i2cId);
1399:                                                    #endif                                                   
1400:                                                    
1401:                                                    if (lBufferObj)
1402:                                                    {
1403:                                                        lBufferObj->inUse = false;
1404:                                                    }                                                                    
1405:                
1406:                                                    /*clear any previous status flags */
1407:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1408:                                                    
1409:                                                    /* set status to buffer event complete */
1410:                                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1411:                                                        DRV_I2C_BUFFER_EVENT_ERROR;
1412:                
1413:                                                    /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1414:                                                    if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1415:                                                    {
1416:                                                        dObj->interruptNestingCount++;
1417:                                                        
1418:                                                        /* Give an indication to the higher layer upon successful transmission */
1419:                                                        _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1420:                                                                ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1421:                                                        
1422:                                                        dObj->interruptNestingCount--;
1423:                                                    }
1424:                                                #else
1425:                                                    dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D000688  AC820044   SW V0, 68(A0)
1426:                                                    PLIB_I2C_MasterStop (i2cId);
1427:                                                #endif
1428:                                            }
1429:                                        }
1430:                                        else
1431:                                        {
1432:                                            /* Do not block in any case */
1433:                                            break;
1434:                                        }
1435:                                    }
1436:                                    else
1437:                                    {
1438:                                        #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1439:                                        /*   Errata for PIC32MZ which requires reset of I2C module */
1440:                
1441:                                            dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1442:                
1443:                                            /* alternate method to do STOP (previous errata note) */  
1444:                
1445:                                            #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
1446:                                                /* Bit bang procedure for STOP */
1447:                
1448:                                                starttime = ReadCoreTimer();
1449:                                                while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1450:                
1451:                                                /* Disable I2C */
1452:                                                PLIB_I2C_Disable(i2cId);
1453:                
1454:                                                /* Wait 2 BRG */
1455:                                                starttime = ReadCoreTimer();
1456:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1457:                
1458:                                                /* Set SDA as I/P */
1459:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1460:                
1461:                                                /* Wait 3 BRG */
1462:                                                starttime = ReadCoreTimer();
1463:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1464:                
1465:                                                PLIB_I2C_Enable(i2cId);
1466:                                                PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1467:                                                PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1468:                                                PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1469:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1470:                
1471:                                                /* End-of-Bit-Bang procedure for STOP */
1472:                                            #else                                                    
1473:                                              PLIB_I2C_Disable(i2cId);
1474:                                              PLIB_I2C_Enable(i2cId);
1475:                                            #endif                                                   
1476:                
1477:                                            if (lBufferObj)
1478:                                            {
1479:                                                lBufferObj->inUse = false;
1480:                                            }                                                                    
1481:                
1482:                                            /*clear any previous status flags */
1483:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1484:                
1485:                                            /* set status to buffer event complete */
1486:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1487:                                                DRV_I2C_BUFFER_EVENT_ERROR;
1488:                
1489:                                            /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1490:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1491:                                            {
1492:                                                dObj->interruptNestingCount++;
1493:                                                
1494:                                                /* Give an indication to the higher layer upon successful transmission */
1495:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1496:                                                        ( DRV_I2C_BUFFER_EVENT_ERROR, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1497:                                                
1498:                                                dObj->interruptNestingCount--;
1499:                                            }
1500:                                        #else
1501:                                            dObj->task = DRV_I2C_TASK_PROCESS_STOP;
9D00069C  AC820044   SW V0, 68(A0)
1502:                                            PLIB_I2C_MasterStop (i2cId);
1503:                                        #endif
1504:                                    }
1505:                                }
1506:                                break;
1507:                            case DRV_I2C_BUS_SILENT:
1508:                
1509:                                /*  The Bus is Silent/Idle when the last byte is either ACK'ed  OR
1510:                                    in the event of slave unexpectedly aborting operation, check
1511:                                    if transmission is complete and NACK is received   */
1512:                
1513:                                if ( PLIB_I2C_TransmitterByteWasAcknowledged ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) ) ||
9D0006B8  5040000A   BEQL V0, ZERO, 0x9D0006E4
9D0006BC  8E23000C   LW V1, 12(S1)
9D0006C8  54400055   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006CC  8E020038   LW V0, 56(S0)
1514:                                      ( PLIB_I2C_TransmitterByteHasCompleted ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) )  &&
9D0006D8  50400051   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006DC  8E020038   LW V0, 56(S0)
1515:                                            (!PLIB_I2C_TransmitterByteWasAcknowledged ( _DRV_I2C_PERIPHERAL_ID_GET ( i2cId ) )) ) )
1516:                                {
1517:                                    if ( lBufferObj->operation == DRV_I2C_OP_WRITE_READ )
9D0006E0  8E23000C   LW V1, 12(S1)
9D0006E4  24020002   ADDIU V0, ZERO, 2
9D0006E8  54620016   BNEL V1, V0, 0x9D000744
9D0006EC  24020008   ADDIU V0, ZERO, 8
1518:                                    {
1519:                
1520:                                        SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
9D0006F0  8E030030   LW V1, 48(S0)
1521:                
1522:                                        dObj->task  = DRV_I2C_SEND_RANDOM_READ_DEVICE_ADDRESS;
9D000714  24030009   ADDIU V1, ZERO, 9
9D000718  AE030044   SW V1, 68(S0)
1523:                                        
1524:                                        lBufferObj->operation = DRV_I2C_OP_READ;
9D00071C  AE22000C   SW V0, 12(S1)
1525:                
1526:                                        lBufferObj->transferSize = lBufferObj->readtransferSize;    //Assign # of bytes to be read into transfer size
9D000720  8E22001C   LW V0, 28(S1)
9D000724  AE220018   SW V0, 24(S1)
1527:                
1528:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_SEND_RESTART_EVENT;
9D000728  24020004   ADDIU V0, ZERO, 4
9D00072C  AE22002C   SW V0, 44(S1)
1529:                                                                        
1530:                                        PLIB_I2C_MasterStartRepeat (dObj->i2cId);
1531:                
1532:                                    }
1533:                                    else
1534:                                    {
1535:                
1536:                                    #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1537:                                    /*   Errata for PIC32MZ which requires reset of I2C module */
1538:                
1539:                                        #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV        
1540:                
1541:                                            /* Bit bang procedure for STOP */
1542:                                            starttime = ReadCoreTimer();
1543:                                            while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1544:                
1545:                                            /* Disable I2C */
1546:                                            PLIB_I2C_Disable(i2cId);
1547:                
1548:                                            /* Wait 2 BRG */
1549:                                            starttime = ReadCoreTimer();
1550:                                            while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1551:                
1552:                                            /* Set SDA as I/P */
1553:                                            PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1554:                
1555:                                            /* Wait 3 BRG */
1556:                                            starttime = ReadCoreTimer();
1557:                                            while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1558:                
1559:                                            PLIB_I2C_Enable(i2cId);
1560:                                            PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1561:                                            PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1562:                                            PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1563:                                            PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1564:                                        #else
1565:                                            /* alternate method to do STOP (previous errata note) */  
1566:                                            PLIB_I2C_Disable(i2cId);
1567:                                            PLIB_I2C_Enable(i2cId);
1568:                                        #endif
1569:                
1570:                                        /* End-of-Bit-Bang procedure for STOP */
1571:                
1572:                                        if (lBufferObj)
1573:                                        {
1574:                                            lBufferObj->inUse = false;
1575:                                        }    
1576:                
1577:                                        /* set buffer event complete status and callback here instead of STOP condition 
1578:                                        because STOP condition is PIC32MZ-EC is bit-banged and would not generate an interrupt  */
1579:                                        dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1580:                
1581:                                        /*clear any previous status flags */
1582:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1583:                
1584:                                        /* set status to buffer event complete */
1585:                                        _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1586:                                                DRV_I2C_BUFFER_EVENT_COMPLETE;
1587:                
1588:                                        if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1589:                                        {
1590:                                            dObj->interruptNestingCount++;
1591:                                            
1592:                                            /* Give an indication to the higher layer upon successful transmission */
1593:                                            _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1594:                                            ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1595:                                            
1596:                                            dObj->interruptNestingCount--;
1597:                                        }
1598:                                    #else
1599:                                        dObj->task = DRV_I2C_TASK_PROCESS_STOP; 
9D000744  AE020044   SW V0, 68(S0)
1600:                                        PLIB_I2C_MasterStop (i2cId);
1601:                                    #endif
1602:                
1603:                                    }
1604:                                }
1605:                                break;
1606:                            case DRV_I2C_TASK_SET_RCEN_ONLY:
1607:                                if ( PLIB_I2C_TransmitterByteHasCompleted (i2cId) ) 
9D000760  5440002F   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000764  8E020038   LW V0, 56(S0)
1608:                                {
1609:                                    if ( PLIB_I2C_TransmitterByteWasAcknowledged(i2cId) )
9D000770  1440000A   BNE V0, ZERO, 0x9D00079C
9D000774  24020008   ADDIU V0, ZERO, 8
1610:                                    {
1611:                                        if (PLIB_I2C_ReceiverByteAcknowledgeHasCompleted(i2cId))
9D000780  54400027   BNEL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000784  8E020038   LW V0, 56(S0)
1612:                                        {
1613:                                            PLIB_I2C_MasterReceiverClock1Byte (i2cId);
1614:                                            dObj->task = DRV_I2C_TASK_PROCESS_READ_ONLY;
9D000790  24020003   ADDIU V0, ZERO, 3
9D000794  0B400207   J 0x9D00081C
9D000798  AC820044   SW V0, 68(A0)
1615:                                        }
1616:                                    }   
1617:                                    else
1618:                                    {
1619:                                        
1620:                                        #if defined  __PIC32MZ &&  (__PIC32_FEATURE_SET0 == 'E') && (__PIC32_FEATURE_SET1 == 'C')
1621:                                        /*   Errata for PIC32MZ which requires reset of I2C module */
1622:                
1623:                                            dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
1624:                
1625:                                            /* alternate method to do STOP (previous errata note) */  
1626:                
1627:                                            #ifdef MZ_EC_ERRATA_25_BB_STOP               //GJV
1628:                                                /* Bit bang procedure for STOP */
1629:                
1630:                                                starttime = ReadCoreTimer();
1631:                                                while(ReadCoreTimer()-starttime < BRG_1_TIME_0);
1632:                
1633:                                                /* Disable I2C */
1634:                                                PLIB_I2C_Disable(i2cId);
1635:                
1636:                                                /* Wait 2 BRG */
1637:                                                starttime = ReadCoreTimer();
1638:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1639:                
1640:                                                /* Set SDA as I/P */
1641:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1642:                
1643:                                                /* Wait 3 BRG */
1644:                                                starttime = ReadCoreTimer();
1645:                                                while(ReadCoreTimer()- starttime < BRG_1_TIME_0);
1646:                
1647:                                                PLIB_I2C_Enable(i2cId);
1648:                                                PLIB_PORTS_PinClear(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1649:                                                PLIB_PORTS_PinSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1650:                                                PLIB_PORTS_PinDirectionOutputSet(PORTS_ID_0, dObj->portSDA, dObj->pinSDA);
1651:                                                PLIB_PORTS_PinDirectionInputSet(PORTS_ID_0, dObj->portSCL, dObj->pinSCL);
1652:                
1653:                                                /* End-of-Bit-Bang procedure for STOP */
1654:                                            #else                                                   //GJV
1655:                                              PLIB_I2C_Disable(i2cId);
1656:                                              PLIB_I2C_Enable(i2cId);
1657:                                            #endif                                                  //GJV
1658:                
1659:                                            if (lBufferObj)
1660:                                            {
1661:                                                lBufferObj->inUse = false;
1662:                                            }                                                                    
1663:                
1664:                                            /*clear any previous status flags */
1665:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = 0;
1666:                
1667:                                            /* set status to buffer event complete */
1668:                                            _DRV_I2C_CLIENT_OBJ(lBufferObj, status) |=
1669:                                                DRV_I2C_BUFFER_EVENT_COMPLETE;
1670:                
1671:                                            /* Have a check here because DRV_I2C_ClientSetup function call is optional */                       //Issue Callback for STOP event
1672:                                            if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
1673:                                            {
1674:                                                dObj->interruptNestingCount++;
1675:                                                
1676:                                                /* Give an indication to the higher layer upon successful transmission */
1677:                                                _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
1678:                                                        ( DRV_I2C_BUFFER_EVENT_COMPLETE, (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
1679:                                                
1680:                                                dObj->interruptNestingCount--;
1681:                                            }
1682:                                        #else
1683:                                            dObj->task = DRV_I2C_TASK_PROCESS_STOP;                            
9D00079C  AC820044   SW V0, 68(A0)
1684:                                            PLIB_I2C_MasterStop (i2cId);
1685:                                        #endif
1686:                
1687:                                    }
1688:                                }
1689:                                break;
1690:                            case DRV_I2C_TASK_PROCESS_STOP:
1691:                
1692:                //#if defined (DRV_I2C_INTERRUPT_MODE) && (DRV_I2C_INTERRUPT_MODE == true)
1693:                //                 _DRV_I2C_InterruptSourceDisable (_DRV_I2C_INT_SRC_GET(dObj->mstrInterruptSource));
1694:                //#endif
1695:                                 
1696:                                dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D0007B0  AC800044   SW ZERO, 68(A0)
1697:                                
1698:                                if( lBufferObj->transferSize )
9D0007B4  8E220018   LW V0, 24(S1)
9D0007B8  10400004   BEQ V0, ZERO, 0x9D0007CC
9D0007BC  24020001   ADDIU V0, ZERO, 1
1699:                                {
1700:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_ERROR;
9D0007C0  24020002   ADDIU V0, ZERO, 2
9D0007C4  0B4001F4   J 0x9D0007D0
9D0007C8  AE22002C   SW V0, 44(S1)
1701:                                        
1702:                                }
1703:                                else
1704:                                {
1705:                                    _DRV_I2C_CLIENT_OBJ(lBufferObj, status) = DRV_I2C_BUFFER_EVENT_COMPLETE;
9D0007CC  AE22002C   SW V0, 44(S1)
1706:                                        
1707:                                }                
1708:                
1709:                               /* Have a check here because DRV_I2C_ClientSetup function call is optional */
1710:                                if ( _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback) != NULL )
9D0007D0  8E220004   LW V0, 4(S1)
9D0007D4  8C420020   LW V0, 32(V0)
9D0007D8  1040000C   BEQ V0, ZERO, 0x9D00080C
9D0007DC  02202821   ADDU A1, S1, ZERO
1711:                                {
1712:                                    dObj->interruptNestingCount++;
9D0007E0  8E020068   LW V0, 104(S0)
9D0007E4  24420001   ADDIU V0, V0, 1
9D0007E8  AE020068   SW V0, 104(S0)
1713:                                    
1714:                                    /* Give an indication to the higher layer upon successful transmission */
1715:                                    _DRV_I2C_CLIENT_OBJ(((DRV_I2C_CLIENT_OBJ *)lBufferObj->clientHandle), callback)
9D0007EC  8E220004   LW V0, 4(S1)
1716:                                    ( _DRV_I2C_CLIENT_OBJ(lBufferObj, status), (DRV_I2C_BUFFER_HANDLE)lBufferObj, 0x00 );
9D0007F0  8C420020   LW V0, 32(V0)
9D0007F4  8E24002C   LW A0, 44(S1)
9D0007F8  0040F809   JALR V0
9D0007FC  00003021   ADDU A2, ZERO, ZERO
1717:                                    
1718:                                    dObj->interruptNestingCount--;
9D000800  8E020068   LW V0, 104(S0)
9D000804  2442FFFF   ADDIU V0, V0, -1
9D000808  AE020068   SW V0, 104(S0)
1719:                                }
1720:                        
1721:                                
1722:                                                 
1723:                                if (lBufferObj)
9D00080C  52200004   BEQL S1, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000810  8E020038   LW V0, 56(S0)
1724:                                {
1725:                                    lBufferObj->inUse = false;
9D000814  A2200000   SB ZERO, 0(S1)
1726:                                    Nop();
9D000818  00000040   SSNOP
1727:                                }
1728:                
1729:                                break;
1730:                            default:
1731:                                break;
1732:                
1733:                        }
1734:                
1735:                        /* This state is encountered when an error interrupt has occurred.
1736:                           or an error has occurred during read */
1737:                
1738:                        if ( true == _DRV_I2C_InterruptSourceStatusGet ( dObj->errInterruptSource ) )
9D000174  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000178  8E020038   LW V0, 56(S0)
9D000208  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D00020C  8E020038   LW V0, 56(S0)
9D00040C  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000410  8E020038   LW V0, 56(S0)
9D000580  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000584  8E020038   LW V0, 56(S0)
9D000694  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000698  8E020038   LW V0, 56(S0)
9D0006A8  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0006AC  8E020038   LW V0, 56(S0)
9D00073C  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000740  8E020038   LW V0, 56(S0)
9D000750  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000754  8E020038   LW V0, 56(S0)
9D0007A8  0B400208   J DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0007AC  8E020038   LW V0, 56(S0)
9D00081C  8E020038   LW V0, 56(S0)
9D000840  50400011   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D000844  8E020030   LW V0, 48(S0)
1739:                        {
1740:                            /* Check for the overflow error */
1741:                            if ( PLIB_I2C_ReceiverOverflowHasOccurred ( i2cId ) )
9D000850  50400004   BEQL V0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagClear
9D000854  8E020038   LW V0, 56(S0)
1742:                            {
1743:                                if ( PLIB_I2C_ExistsReceiverOverflow ( i2cId ) )
1744:                                {
1745:                                    PLIB_I2C_ReceiverOverflowClear ( i2cId );
1746:                                }
1747:                            }
1748:                
1749:                            _DRV_I2C_InterruptSourceClear ( dObj->errInterruptSource );
9D000860  8E020038   LW V0, 56(S0)
1750:                        }
1751:                
1752:                        if (SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))
9D000884  8E020030   LW V0, 48(S0)
9D0008AC  50800005   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0008B0  8E020034   LW V0, 52(S0)
1753:                        {
1754:                            SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
1755:                        }
1756:                        if (SYS_INT_SourceStatusGet(dObj->slaveInterruptSource))
9D0008C0  8E020034   LW V0, 52(S0)
9D0008E8  50800007   BEQL A0, ZERO, DRV_I2C_Tasks::PLIB_INT_SourceFlagGet
9D0008EC  8E020038   LW V0, 56(S0)
1757:                        {
1758:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
1759:                            PLIB_I2C_SlaveClockRelease ( i2cId );
1760:                        }
1761:                        if (SYS_INT_SourceStatusGet(dObj->errInterruptSource))
9D000904  8E020038   LW V0, 56(S0)
9D00092C  50800005   BEQL A0, ZERO, 0x9D000944
9D000930  8E020020   LW V0, 32(S0)
1762:                        {
1763:                            SYS_INT_SourceStatusClear(dObj->errInterruptSource);
1764:                        }
1765:                        
1766:                        if ( (dObj->i2cMode) == DRV_I2C_MODE_MASTER)
9D000940  8E020020   LW V0, 32(S0)
9D000944  1440001B   BNE V0, ZERO, 0x9D0009B4
9D000948  8FBF001C   LW RA, 28(SP)
1767:                        {
1768:                            if ( (lBufferObj != NULL) &&  ((_DRV_I2C_CLIENT_OBJ(lBufferObj, status) == DRV_I2C_BUFFER_EVENT_COMPLETE) || (_DRV_I2C_CLIENT_OBJ(lBufferObj, status) == DRV_I2C_BUFFER_EVENT_ERROR) ))
9D00094C  1220001A   BEQ S1, ZERO, 0x9D0009B8
9D000950  8FB20018   LW S2, 24(SP)
9D000954  8E22002C   LW V0, 44(S1)
9D000958  2442FFFF   ADDIU V0, V0, -1
9D00095C  2C420002   SLTIU V0, V0, 2
9D000960  50400016   BEQL V0, ZERO, 0x9D0009BC
9D000964  8FB10014   LW S1, 20(SP)
1769:                            {                
1770:                                _DRV_I2C_Advance_Queue(dObj);
9D000968  0F400DDA   JAL _DRV_I2C_Advance_Queue
9D00096C  02002021   ADDU A0, S0, ZERO
1771:                                if ((_DRV_I2C_IsQueueEmpty(dObj) == false))
9D000970  0F400DB0   JAL _DRV_I2C_IsQueueEmpty
9D000974  02002021   ADDU A0, S0, ZERO
9D000978  1440000E   BNE V0, ZERO, 0x9D0009B4
9D00097C  8FBF001C   LW RA, 28(SP)
1772:                                {
1773:                                    if (PLIB_I2C_BusIsIdle(dObj->i2cId))
1774:                                    {                
1775:                                        PLIB_I2C_MasterStart(dObj->i2cId);
1776:                                        Nop();
9D0009AC  00000040   SSNOP
1777:                                    }
1778:                                }
1779:                            }
1780:                        }
1781:                
1782:                
1783:                }   /* DRV_I2C_TASKS */
9D0009B0  8FBF001C   LW RA, 28(SP)
9D0009B4  8FB20018   LW S2, 24(SP)
9D0009B8  8FB10014   LW S1, 20(SP)
9D0009BC  8FB00010   LW S0, 16(SP)
9D0009C0  03E00008   JR RA
9D0009C4  27BD0020   ADDIU SP, SP, 32
1784:                
1785:                
1786:                //******************************************************************************
1787:                /* Function:
1788:                    DRV_HANDLE DRV_I2C_Open ( const SYS_MODULE_INDEX    index,
1789:                                             const DRV_IO_INTENT       intent )
1790:                
1791:                  Summary:
1792:                    Opens the specific module instance and returns a handle
1793:                
1794:                  Description:
1795:                    This routine opens a driver for use by any client module and provides a
1796:                    handle that must be provided to any of the other driver operations to
1797:                    identify the caller and the instance of the driver/hardware module.
1798:                
1799:                  Parameters:
1800:                    index           - Identifier for the instance to be initialized
1801:                    ioIntent        - Possible values from the enumeration DRV_IO_INTENT
1802:                
1803:                  Returns:
1804:                    If successful, the routine returns a valid open-instance handle (a number
1805:                    identifying both the caller and the module instance)
1806:                    If an error occurs, the return value is DRV_HANDLE_INVALID
1807:                */
1808:                
1809:                DRV_HANDLE DRV_I2C_Open ( const SYS_MODULE_INDEX   drvIndex,
1810:                                         const DRV_IO_INTENT      ioIntent )
1811:                {
9D0027F0  3084FFFF   ANDI A0, A0, -1
1812:                    /* Multi client variables are removed from single client builds. */
1813:                   
1814:                    DRV_I2C_OBJ         *dObj;
1815:                    size_t              iClient;
1816:                    
1817:                    /* Validate the driver index */
1818:                    if( drvIndex >= DRV_I2C_INSTANCES_NUMBER )
9D0027F4  1480002F   BNE A0, ZERO, 0x9D0028B4
9D0027F8  2402FFFF   ADDIU V0, ZERO, -1
1819:                    {
1820:                        return DRV_HANDLE_INVALID;
1821:                    }
1822:                    dObj = _DRV_I2C_INSTANCE_GET(drvIndex);
1823:                
1824:                    /* Check for exclusive access */
1825:                    _DRV_I2C_LockMutex(dObj);
1826:                    
1827:                    /* Check if max number of clients open */
1828:                    if ( ( dObj->isExclusive == true ) ||
9D002800  3C02A001   LUI V0, -24575
9D002804  90428727   LBU V0, -30937(V0)
9D002808  1440000A   BNE V0, ZERO, 0x9D002834
9D00280C  24030001   ADDIU V1, ZERO, 1
9D002814  90428726   LBU V0, -30938(V0)
9D002818  10400007   BEQ V0, ZERO, 0x9D002838
9D00281C  3C02A001   LUI V0, -24575
1829:                         ( dObj->inUse != true ) ||
9D002810  3C02A001   LUI V0, -24575
9D002824  90428728   LBU V0, -30936(V0)
9D002828  50400006   BEQL V0, ZERO, DRV_I2C_Open::_DRV_I2C_UnlockMutex
9D00282C  3C02A001   LUI V0, -24575
1830:                         (( dObj->numClients > 0 ) &&
9D002820  3C02A001   LUI V0, -24575
1831:                            DRV_IO_ISEXCLUSIVE( ioIntent )) ||
1832:                         (dObj->numClients >= DRV_I2C_CLIENTS_NUMBER))
1833:                    {
1834:                        /* Set that the hardware instance is opened in exclusive mode */
1835:                        _DRV_I2C_UnlockMutex(dObj);
1836:                         return DRV_HANDLE_INVALID;
9D00283C  03E00008   JR RA
9D002840  2402FFFF   ADDIU V0, ZERO, -1
1837:                    }
1838:                    _DRV_I2C_UnlockMutex(dObj);
1839:                
1840:                    
1841:                    if(OSAL_MUTEX_Lock(&(gDrvI2CCommonDataObj.mutexClientObjects), OSAL_WAIT_FOREVER) == OSAL_RESULT_TRUE)
1842:                    {
1843:                        /* Setup client operations */
1844:                        /* Find available slot in array of client objects */
1845:                        for ( iClient = 0; iClient < DRV_I2C_CLIENTS_NUMBER ; iClient++ )
1846:                        {
1847:                            DRV_I2C_CLIENT_OBJ  *clientObj      =
1848:                                            ( DRV_I2C_CLIENT_OBJ* ) _DRV_I2C_CLIENT_OBJ_GET(iClient);
1849:                            if ( !clientObj->inUse )
9D002858  3C02A001   LUI V0, -24575
9D00285C  904286EC   LBU V0, -30996(V0)
9D002860  14400012   BNE V0, ZERO, DRV_I2C_Open::OSAL_MUTEX_Unlock
9D002864  24020001   ADDIU V0, ZERO, 1
1850:                            {
1851:                                /* Increment the client in case of Multi client support, otherwise remove
1852:                                the below statement */
1853:                
1854:                                dObj->numClients++;
9D002868  3C02A001   LUI V0, -24575
9D00286C  A0438728   SB V1, -30936(V0)
1855:                
1856:                                /* Update that, the client is opened in exclusive access mode */
1857:                                if( DRV_IO_ISEXCLUSIVE( ioIntent ) )
9D002870  30A20008   ANDI V0, A1, 8
9D002874  50400004   BEQL V0, ZERO, 0x9D002888
9D002878  3C03A001   LUI V1, -24575
1858:                                {
1859:                                    dObj->isExclusive = true;
9D00287C  3C02A001   LUI V0, -24575
9D002880  A0438727   SB V1, -30937(V0)
1860:                                }
1861:                                clientObj->inUse  = true;
9D002884  3C03A001   LUI V1, -24575
9D002888  246286E8   ADDIU V0, V1, -31000
9D00288C  24040001   ADDIU A0, ZERO, 1
9D002890  A0440004   SB A0, 4(V0)
1862:                                
1863:                                /* We have found a client object. Release the mutex */
1864:                
1865:                                OSAL_MUTEX_Unlock(&(gDrvI2CCommonDataObj.mutexClientObjects));
1866:                
1867:                    //            _DRV_I2C_UnlockMutex(dObj);
1868:                                clientObj->driverObject = dObj;
9D002898  3C04A001   LUI A0, -24575
9D00289C  2484870C   ADDIU A0, A0, -30964
9D0028A0  AC6486E8   SW A0, -31000(V1)
1869:                                clientObj->intent = ioIntent;
1870:                
1871:                                /* Return the client object */
1872:                                return ( DRV_HANDLE ) clientObj;
9D0028A4  03E00008   JR RA
9D0028A8  AC450008   SW A1, 8(V0)
1873:                            }
1874:                        }
1875:                        
1876:                        /* Could not find a client object. Release the mutex and
1877:                           return with an invalid handle. */
1878:                        OSAL_MUTEX_Unlock(&(gDrvI2CCommonDataObj.mutexClientObjects));
1879:                    }
1880:                //    _DRV_I2C_UnlockMutex(dObj);
1881:                
1882:                    return  DRV_HANDLE_INVALID ;
9D0028B0  2402FFFF   ADDIU V0, ZERO, -1
1883:                } /* DRV_I2C_Open */
9D0028B4  03E00008   JR RA
9D0028B8  00000000   NOP
1884:                
1885:                
1886:                //******************************************************************************
1887:                /* Function:
1888:                    void DRV_I2C_Close ( DRV_HANDLE handle )
1889:                
1890:                  Summary:
1891:                    Closes an opened-instance of a driver
1892:                
1893:                  Description:
1894:                    This routine closes an opened-instance of a driver, invalidating the given
1895:                    handle.
1896:                
1897:                  Parameters:
1898:                    handle       - A valid open-instance handle, returned from the driver's
1899:                                   open routine
1900:                
1901:                  Returns:
1902:                    None
1903:                */
1904:                
1905:                void DRV_I2C_Close ( DRV_HANDLE handle )
1906:                {
1907:                    /* Multi client variables are removed from single client builds. */
1908:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*)handle;
1909:                
1910:                    if (clientObj->inUse == false)
00000000  00000000   NOP
1911:                    {
1912:                        //_DRV_I2C_UnlockMutex(clientObj->driverObject);
1913:                        return;
1914:                    }
1915:                
1916:                    /* Free the Client Instance */
1917:                	if (clientObj->driverObject != NULL)
0000000C  00000000   NOP
1918:                	{
1919:                		clientObj->driverObject->numClients --;
00000018  00000000   NOP
1920:                		clientObj->driverObject->isExclusive = false;
00000024  00000000   NOP
1921:                	}
1922:                    clientObj->inUse = false ;
0000002C  00000000   NOP
1923:                
1924:                } /* DRV_I2C_Close */
1925:                
1926:                
1927:                // *****************************************************************************
1928:                /* Function:
1929:                    void DRV_I2C_ClientSetup ( DRV_HANDLE handle,
1930:                                                 const DRV_I2C_CLIENT_SETUP * const config )
1931:                
1932:                  Summary:
1933:                    Sets up the device communication parameters
1934:                
1935:                  Description:
1936:                    This function sets up the device communication parameters
1937:                
1938:                  Parameters:
1939:                    handle       - A valid open-instance handle, returned from the driver's
1940:                                   open routine
1941:                
1942:                    config       - Port parameters tied to IRQ line
1943:                
1944:                  Returns:
1945:                    None
1946:                */
1947:                
1948:                void DRV_I2C_ClientSetup ( DRV_HANDLE handle,
1949:                                                 const DRV_I2C_CLIENT_SETUP * const config )
1950:                {
00000000  00000000   NOP
1951:                //    bool temp;
1952:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*) handle;
1953:                
1954:                
1955:                    _DRV_I2C_SAVE_LAST_CLIENT();
1956:                //    temp = config->irqSetupLogicLevel;
1957:                
1958:                    clientObj->irqSelectLogicLevel  = config->irqSetupLogicLevel;
00000010  00000000   NOP
1959:                    clientObj->irqSelectPort        = config->irqSetupPort;
00000018  00000000   NOP
1960:                    clientObj->irqSelectBitPos      = config->irqSetupBitPos;
00000020  00000000   NOP
1961:                
1962:                    SYS_PORTS_PinDirectionSelect( PORTS_ID_0, SYS_PORTS_DIRECTION_OUTPUT,
00000028  00000000   NOP
1963:                            clientObj->irqSelectPort, clientObj->irqSelectBitPos);
1964:                    if (clientObj->irqSelectLogicLevel == true)
00000034  00000000   NOP
1965:                        SYS_PORTS_PinSet (PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos );
00000040  00000000   NOP
1966:                    else
1967:                        SYS_PORTS_PinClear (PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos );
00000054  00000000   NOP
1968:                
1969:                }  /* DRV_I2C_ClientSetup */
00000060  00000000   NOP
1970:                
1971:                //******************************************************************************
1972:                /* Function:
1973:                    void DRV_I2C_BufferEventHandlerSet ( const DRV_HANDLE handle,
1974:                                    const DRV_I2C_BUFFER_EVENT_HANDLER eventHandler,
1975:                                    const uintptr_t context )
1976:                
1977:                  Summary:
1978:                	Adds a callback function for a client.
1979:                
1980:                  Description:
1981:                    This routine adds a callback function for a client.
1982:                
1983:                  Parameters:
1984:                        handle       	- A valid open-instance handle, returned from the driver's
1985:                						open routine.
1986:                
1987:                	eventHandler    - Call back function.
1988:                
1989:                	context		 	-  context.
1990:                
1991:                  Returns:
1992:                    None.
1993:                */
1994:                
1995:                void DRV_I2C_BufferEventHandlerSet (const DRV_HANDLE handle,
1996:                                    const DRV_I2C_BUFFER_EVENT_HANDLER eventHandler,
1997:                                    const uintptr_t context )
1998:                {
1999:                	( (DRV_I2C_CLIENT_OBJ *) handle)->callback = eventHandler;
00000000  00000000   NOP
2000:                
2001:                	( (DRV_I2C_CLIENT_OBJ *) handle)->context = context;
00000004  00000000   NOP
2002:                }   /* DRV_I2C_BufferEventHandlerSet */
2003:                
2004:                
2005:                //******************************************************************************
2006:                /* Function:
2007:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_Receive  (    DRV_HANDLE handle,
2008:                                                                uint8_t* address,
2009:                                                                void *rxBuffer,
2010:                                                                size_t size,
2011:                                                                void * context);
2012:                
2013:                  Summary:
2014:                    Adds a buffer to queue with a read request. Driver will process this
2015:                    request in the task routine.
2016:                
2017:                  Description:
2018:                    This routine adds a buffer to queue with a read request. Driver will process
2019:                    this request in the task routine.
2020:                
2021:                  Parameters:
2022:                    handle      - A valid open-instance handle, returned from the driver's open
2023:                                  routine
2024:                    address     - Device address of slave. If this API is used in Slave mode,
2025:                                  then a dummy value can be used
2026:                    buffer      - This buffer holds data is received
2027:                    size        - The number of bytes that the Master expects to read from Slave.
2028:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2029:                                  This is because the Master controls when the READ operation
2030:                                  is terminated.
2031:                    callbackContext     - Not implemented, future expansion
2032:                
2033:                  Returns:
2034:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2035:                    the buffer.
2036:                */
2037:                
2038:                
2039:                DRV_I2C_BUFFER_HANDLE DRV_I2C_Receive   (   DRV_HANDLE handle, 
2040:                                                            uint16_t address,
2041:                                                            void *buffer,
2042:                                                            size_t size,
2043:                                                            void * callbackContext )
2044:                {
00000000  00000000   NOP
2045:                    DRV_I2C_BUFFER_OBJECT   *i2cDataObj;
2046:                    DRV_I2C_OBJ             *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000030  00000000   NOP
2047:                
2048:                    /* Get a slot in the queue */
2049:                   i2cDataObj = _DRV_I2C_QueueSlotGet ( dObj );
00000034  00000000   NOP
2050:                
2051:                
2052:                    if ( i2cDataObj != NULL )
0000003C  00000000   NOP
2053:                    {
2054:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2055:                        i2cDataObj->clientHandle    = handle;
00000044  00000000   NOP
2056:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
00000048  00000000   NOP
2057:                        {
2058:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
00000054  00000000   NOP
2059:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2060:                        }
2061:                        else
2062:                        {
2063:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2064:                            i2cDataObj->slaveaddresslowbyte  = 0;
00000064  00000000   NOP
2065:                        }
2066:                        i2cDataObj->operation       = DRV_I2C_OP_READ;
00000068  00000000   NOP
2067:                        i2cDataObj->txBuffer        = NULL;
00000070  00000000   NOP
2068:                        i2cDataObj->rxBuffer        = buffer;
00000074  00000000   NOP
2069:                        i2cDataObj->transferSize    = size;
00000078  00000000   NOP
2070:                        i2cDataObj->actualtransfersize = 0;
0000007C  00000000   NOP
2071:                        i2cDataObj->status          = DRV_I2C_BUFFER_EVENT_PENDING;
00000080  00000000   NOP
2072:                        i2cDataObj->context         = callbackContext;
00000084  00000000   NOP
2073:                        i2cDataObj->transmitForced  = false;
0000008C  00000000   NOP
2074:                
2075:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
00000090  00000000   NOP
2076:                
2077:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
0000009C  00000000   NOP
2078:                        {
2079:                            
2080:                            /*  if either START and STOP were not detected which is true the 
2081:                                first time OR if STOP was detected, then it assumed the 
2082:                                transaction on the bus is complete */
2083:                            
2084:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
000000B4  00000000   NOP
000000C4  00000000   NOP
000000D4  00000000   NOP
2085:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2086:                            {
2087:                                
2088:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2089:                                
2090:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
000001B8  00000000   NOP
2091:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2092:                                {
2093:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2094:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2095:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
00000118  00000000   NOP
2096:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
00000130  00000000   NOP
2097:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2098:                                }
2099:                            }
2100:                        }
2101:                        else
2102:                        {
2103:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2104:                            _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
00000164  00000000   NOP
2105:                        }
2106:                        return (DRV_I2C_BUFFER_HANDLE)i2cDataObj;
000000FC  00000000   NOP
0000013C  00000000   NOP
00000184  00000000   NOP
2107:                    }
2108:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
0000018C  00000000   NOP
2109:                }   /* DRV_I2C_Receive */
000001C4  00000000   NOP
2110:                
2111:                
2112:                //******************************************************************************
2113:                /* Function:
2114:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddRead (   DRV_HANDLE handle,
2115:                                                                    uint8_t* address,
2116:                                                                    void *rxBuffer,
2117:                                                                    size_t size,
2118:                                                                    void * context);
2119:                
2120:                  Summary:
2121:                    Adds a buffer to queue with a read request. Driver will process this
2122:                    request in the task routine.
2123:                
2124:                  Description:
2125:                    This routine adds a buffer to queue with a read request. Driver will process
2126:                    this request in the task routine.
2127:                
2128:                  Parameters:
2129:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2130:                                  routine
2131:                    address     - Device address of slave. If this API is used in Slave mode,
2132:                                  then a dummy value can be used
2133:                    rxBuffer    - This buffer holds data is received
2134:                    size        - The number of bytes that the Master expects to read from Slave.
2135:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2136:                                  This is because the Master controls when the READ operation
2137:                                  is terminated.
2138:                    context     - Not implemented, future expansion
2139:                
2140:                  Returns:
2141:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2142:                    the buffer.
2143:                */
2144:                
2145:                
2146:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddRead (   DRV_HANDLE handle, 
2147:                                                                uint8_t* address,
2148:                                                                void *rxBuffer,
2149:                                                                size_t size,
2150:                                                                void * context )
2151:                {
00000000  00000000   NOP
2152:                    DRV_I2C_BUFFER_OBJECT   *i2cDataObj;
2153:                    DRV_I2C_OBJ             *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000030  00000000   NOP
2154:                
2155:                    /* Get a slot in the queue */
2156:                   i2cDataObj = _DRV_I2C_QueueSlotGet ( dObj );
00000034  00000000   NOP
2157:                
2158:                
2159:                    if ( i2cDataObj != NULL )
0000003C  00000000   NOP
2160:                    {
2161:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2162:                        i2cDataObj->clientHandle            = handle;
00000044  00000000   NOP
2163:                        i2cDataObj->slaveaddresshighbyte    = *(address);
00000048  00000000   NOP
2164:                        i2cDataObj->slaveaddresslowbyte     = 0x00;
00000050  00000000   NOP
2165:                        i2cDataObj->operation               = DRV_I2C_OP_READ;
00000054  00000000   NOP
2166:                        i2cDataObj->txBuffer                = NULL;
0000005C  00000000   NOP
2167:                        i2cDataObj->rxBuffer                = rxBuffer;
00000060  00000000   NOP
2168:                        i2cDataObj->transferSize            = size;
00000064  00000000   NOP
2169:                        i2cDataObj->actualtransfersize      = 0;
00000068  00000000   NOP
2170:                        i2cDataObj->status                  = DRV_I2C_BUFFER_EVENT_PENDING;
0000006C  00000000   NOP
2171:                        i2cDataObj->context                 = context;
00000070  00000000   NOP
2172:                        i2cDataObj->transmitForced          = false;
00000078  00000000   NOP
2173:                
2174:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
0000007C  00000000   NOP
2175:                
2176:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
00000088  00000000   NOP
2177:                        {
2178:                            /*  if either START and STOP were not detected which is true the 
2179:                                first time OR if STOP was detected, then it assumed the 
2180:                                transaction on the bus is complete */
2181:                            
2182:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
000000A0  00000000   NOP
000000B0  00000000   NOP
000000C0  00000000   NOP
2183:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2184:                            {
2185:                            
2186:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2187:                                
2188:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
000001A4  00000000   NOP
2189:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2190:                                {
2191:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2192:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2193:                                    
2194:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
00000104  00000000   NOP
2195:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
0000011C  00000000   NOP
2196:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2197:                                }
2198:                            }
2199:                        }
2200:                        else
2201:                        {
2202:                            SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2203:                            _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
00000150  00000000   NOP
2204:                        }
2205:                        return (DRV_I2C_BUFFER_HANDLE)i2cDataObj;
000000E8  00000000   NOP
00000128  00000000   NOP
00000170  00000000   NOP
2206:                    }
2207:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
00000178  00000000   NOP
2208:                }   /* DRV_I2C_BufferAddRead */
000001B0  00000000   NOP
2209:                
2210:                
2211:                //******************************************************************************
2212:                /* Function:
2213:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_Transmit  (   DRV_HANDLE handle,
2214:                                                                uint16_t address,
2215:                                                                void *txBuffer,
2216:                                                                size_t size,
2217:                                                                void * context);
2218:                  Summary:
2219:                    Adds a buffer to queue with a write request. Driver will process this
2220:                    request in the task routine.
2221:                
2222:                  Description:
2223:                    This routine adds a buffer to queue with a read request. Driver will process
2224:                    this request in the task routine.
2225:                
2226:                  Parameters:
2227:                    handle      - A valid open-instance handle, returned from the driver's open
2228:                                  routine
2229:                    address     - Device address of slave. If this API is used in Slave mode,
2230:                                  then a dummy value can be used
2231:                    buffer      - Contains data to be transferred
2232:                    size        - The number of bytes that the Master expects to write to Slave.
2233:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2234:                                  This is because the Master controls when the WRITE operation
2235:                                  is terminated.
2236:                    callbackContext     - Not implemented, future expansion
2237:                
2238:                  Returns:
2239:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2240:                    the buffer.
2241:                */
2242:                
2243:                DRV_I2C_BUFFER_HANDLE DRV_I2C_Transmit (    DRV_HANDLE handle, 
2244:                                                            uint16_t address,
2245:                                                            void *writeBuffer,
2246:                                                            size_t size,
2247:                                                            void * callbackContext)
2248:                {
9D001164  27BDFFD0   ADDIU SP, SP, -48
9D001168  AFBF002C   SW RA, 44(SP)
9D00116C  AFB50028   SW S5, 40(SP)
9D001170  AFB40024   SW S4, 36(SP)
9D001174  AFB30020   SW S3, 32(SP)
9D001178  AFB2001C   SW S2, 28(SP)
9D00117C  AFB10018   SW S1, 24(SP)
9D001180  AFB00014   SW S0, 20(SP)
9D001184  00809821   ADDU S3, A0, ZERO
9D001188  00C0A821   ADDU S5, A2, ZERO
9D00118C  00E0A021   ADDU S4, A3, ZERO
9D001190  30B2FFFF   ANDI S2, A1, -1
2249:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2250:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
9D001194  8C910000   LW S1, 0(A0)
2251:                
2252:                    /* Get a slot in the queue */
2253:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
9D001198  0F4004D2   JAL _DRV_I2C_QueueSlotGet
9D00119C  02202021   ADDU A0, S1, ZERO
2254:                
2255:                    if ( i2cDataObj != NULL )
9D0011A0  10400052   BEQ V0, ZERO, 0x9D0012EC
9D0011A4  00408021   ADDU S0, V0, ZERO
2256:                    {
2257:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2258:                        i2cDataObj->clientHandle    = handle;
9D0011A8  AC530004   SW S3, 4(V0)
2259:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
9D0011AC  2E420100   SLTIU V0, S2, 256
9D0011B0  54400005   BNEL V0, ZERO, 0x9D0011C8
9D0011B4  A2120008   SB S2, 8(S0)
2260:                        {
2261:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
9D0011B8  00121202   SRL V0, S2, 8
9D0011BC  A2020008   SB V0, 8(S0)
9D0011C0  0B400473   J 0x9D0011CC
9D0011C4  A2120009   SB S2, 9(S0)
2262:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2263:                        }
2264:                        else
2265:                        {
2266:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2267:                            i2cDataObj->slaveaddresslowbyte  = 0;
9D0011C8  A2000009   SB ZERO, 9(S0)
2268:                        }
2269:                        i2cDataObj->operation       = DRV_I2C_OP_WRITE;
9D0011CC  AE00000C   SW ZERO, 12(S0)
2270:                        i2cDataObj->txBuffer        = writeBuffer;
9D0011D0  AE150010   SW S5, 16(S0)
2271:                        i2cDataObj->rxBuffer        = NULL;
9D0011D4  AE000014   SW ZERO, 20(S0)
2272:                        i2cDataObj->transferSize    = size;
9D0011D8  AE140018   SW S4, 24(S0)
2273:                        i2cDataObj->actualtransfersize = 0;
9D0011DC  AE000020   SW ZERO, 32(S0)
2274:                        i2cDataObj->status          = DRV_I2C_BUFFER_EVENT_PENDING;
9D0011E0  AE00002C   SW ZERO, 44(S0)
2275:                        i2cDataObj->context         = callbackContext;
9D0011E4  8FA20040   LW V0, 64(SP)
9D0011E8  AE020034   SW V0, 52(S0)
2276:                        i2cDataObj->transmitForced  = false;
9D0011EC  A2000024   SB ZERO, 36(S0)
2277:                
2278:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
9D0011F0  02202021   ADDU A0, S1, ZERO
9D0011F4  0F400A5F   JAL _DRV_I2C_QueuePush
9D0011F8  02002821   ADDU A1, S0, ZERO
2279:                
2280:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
9D0011FC  8E220020   LW V0, 32(S1)
9D001200  54400028   BNEL V0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceFlagClear
9D001204  8E220034   LW V0, 52(S1)
2281:                        {
2282:                            /*  if either START and STOP were not detected which is true the 
2283:                                first time OR if STOP was detected, then it assumed the 
2284:                                transaction on the bus is complete */
2285:                            
2286:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
9D001214  14600005   BNE V1, ZERO, DRV_I2C_Transmit::PLIB_I2C_StopWasDetected
9D001218  00000000   NOP
9D001224  10600005   BEQ V1, ZERO, DRV_I2C_Transmit::PLIB_I2C_BusIsIdle
9D001228  00000000   NOP
9D001234  5060003B   BEQL V1, ZERO, 0x9D001324
9D001238  02001021   ADDU V0, S0, ZERO
2287:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2288:                            {
2289:                                            
2290:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2291:                                
2292:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
9D001318  1080FFD2   BEQ A0, ZERO, DRV_I2C_Transmit::PLIB_INT_SourceEnable
9D00131C  3C04BF88   LUI A0, -16504
9D001320  02001021   ADDU V0, S0, ZERO
2293:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2294:                                {
2295:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2296:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2297:                                    
2298:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
9D001278  8E230038   LW V1, 56(S1)
2299:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
9D001290  AE200044   SW ZERO, 68(S1)
2300:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2301:                                }
2302:                            }
2303:                        }
2304:                        else
2305:                        {
2306:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2307:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
9D0012C4  8E220034   LW V0, 52(S1)
2308:                
2309:                        }
2310:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
9D00125C  0B4004C9   J 0x9D001324
9D001260  02001021   ADDU V0, S0, ZERO
9D00129C  0B4004C9   J 0x9D001324
9D0012A0  02001021   ADDU V0, S0, ZERO
9D0012E4  0B4004C9   J 0x9D001324
9D0012E8  02001021   ADDU V0, S0, ZERO
2311:                    }
2312:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
9D0012EC  0B4004C9   J 0x9D001324
9D0012F0  00001021   ADDU V0, ZERO, ZERO
2313:                } /* DRV_I2C_Transmit */
9D001324  8FBF002C   LW RA, 44(SP)
9D001328  8FB50028   LW S5, 40(SP)
9D00132C  8FB40024   LW S4, 36(SP)
9D001330  8FB30020   LW S3, 32(SP)
9D001334  8FB2001C   LW S2, 28(SP)
9D001338  8FB10018   LW S1, 24(SP)
9D00133C  8FB00014   LW S0, 20(SP)
9D001340  03E00008   JR RA
9D001344  27BD0030   ADDIU SP, SP, 48
2314:                
2315:                
2316:                //******************************************************************************
2317:                /* Function:
2318:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWrite (  DRV_HANDLE handle,
2319:                                                                    uint8_t* address,
2320:                                                                    void *txBuffer,
2321:                                                                    size_t size,
2322:                                                                    void * context);
2323:                  Summary:
2324:                    Adds a buffer to queue with a write request. Driver will process this
2325:                    request in the task routine.
2326:                
2327:                  Description:
2328:                    This routine adds a buffer to queue with a read request. Driver will process
2329:                    this request in the task routine.
2330:                
2331:                  Parameters:
2332:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2333:                                  routine
2334:                    slaveaddress- Device address of slave. If this API is used in Slave mode,
2335:                                  then a dummy value can be used
2336:                    txBuffer    - Contains data to be transffered
2337:                    size        - The number of bytes that the Master expects to write to Slave.
2338:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2339:                                  This is because the Master controls when the WRITE operation
2340:                                  is terminated.
2341:                    context     - Not implemented, future expansion
2342:                
2343:                  Returns:
2344:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2345:                    the buffer.
2346:                */
2347:                
2348:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWrite (  DRV_HANDLE handle, 
2349:                                                                uint8_t* address,
2350:                                                                void *txBuffer,
2351:                                                                size_t size,
2352:                                                                void * context)
2353:                {
00000000  00000000   NOP
2354:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2355:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000030  00000000   NOP
2356:                
2357:                    /* Get a slot in the queue */
2358:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
00000034  00000000   NOP
2359:                
2360:                    if ( i2cDataObj != NULL )
0000003C  00000000   NOP
2361:                    {
2362:                        /* Fill the data directly to the queue. Set the inUse flag only at the end */
2363:                        i2cDataObj->clientHandle                = handle;
00000044  00000000   NOP
2364:                        i2cDataObj->slaveaddresshighbyte        = *(address);
00000048  00000000   NOP
2365:                        i2cDataObj->slaveaddresslowbyte         = 0x00;
00000050  00000000   NOP
2366:                        i2cDataObj->operation                   = DRV_I2C_OP_WRITE;
00000054  00000000   NOP
2367:                        i2cDataObj->txBuffer                    = txBuffer;
00000058  00000000   NOP
2368:                        i2cDataObj->rxBuffer                    = NULL;
0000005C  00000000   NOP
2369:                        i2cDataObj->transferSize                = size;
00000060  00000000   NOP
2370:                        i2cDataObj->actualtransfersize          = 0;
00000064  00000000   NOP
2371:                        i2cDataObj->status                      = DRV_I2C_BUFFER_EVENT_PENDING;
00000068  00000000   NOP
2372:                        i2cDataObj->context                     = context;
0000006C  00000000   NOP
2373:                        i2cDataObj->transmitForced              = false;
00000074  00000000   NOP
2374:                
2375:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
00000078  00000000   NOP
2376:                
2377:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
00000084  00000000   NOP
2378:                        {
2379:                            
2380:                            /*  if either START and STOP were not detected which is true the 
2381:                                first time OR if STOP was detected, then it assumed the 
2382:                                transaction on the bus is complete */
2383:                            
2384:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
0000009C  00000000   NOP
000000AC  00000000   NOP
000000BC  00000000   NOP
2385:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2386:                            {
2387:                                        
2388:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2389:                                
2390:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
000001A0  00000000   NOP
2391:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2392:                                {
2393:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2394:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2395:                                    
2396:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
00000100  00000000   NOP
2397:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
00000118  00000000   NOP
2398:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2399:                                }
2400:                            }
2401:                        }
2402:                        else
2403:                        {
2404:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2405:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
0000014C  00000000   NOP
2406:                
2407:                        }
2408:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
000000E4  00000000   NOP
00000124  00000000   NOP
0000016C  00000000   NOP
2409:                    }
2410:                    return (DRV_I2C_BUFFER_HANDLE)NULL;
00000174  00000000   NOP
2411:                } /* DRV_I2C_BufferAddWrite */
000001AC  00000000   NOP
2412:                
2413:                //******************************************************************************
2414:                /* Function:
2415:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_TransmitReceive ( DRV_HANDLE handle,
2416:                                                                    uint8_t* address,
2417:                                                                    void *txBuffer,
2418:                                                                    size_t wsize,
2419:                                                                    void *rxBuffer,
2420:                                                                    size_t rsize,
2421:                                                                    void * context);
2422:                
2423:                  Summary:
2424:                    This function writes data to Slave, inserts restart and requests read from
2425:                    slave.
2426:                
2427:                  Description:
2428:                    Master calls this function to send a register address value to the slave and
2429:                    then queries the slave with a read request to read the contents indexed by
2430:                    the register location. The Master sends a restart condition after the
2431:                    initial write before sending the device address with R/W = 1. The restart
2432:                    condition prevents the Master from relinquishing the control of the bus. The
2433:                    slave should not use this function. Driver will process this request
2434:                    in the task routine.
2435:                
2436:                  Parameters:
2437:                    handle      - A valid open-instance handle, returned from the driver's open
2438:                                  routine
2439:                    address     - Device address of slave. If this API is used in Slave mode,
2440:                                  then a dummy value can be used
2441:                    writeBuffer - Contains data to be transferred
2442:                    writeSize   - The number of bytes that the Master expects to write to Slave.
2443:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2444:                                  This is because the Master controls when the WRITE operation
2445:                                  is terminated.
2446:                    readBuffer  - This buffer holds data that is send back from slave after
2447:                                  read operation.
2448:                    readSize    - The number of bytes the Master expects to be read from the
2449:                                  slave
2450:                    callbackContext     - Not implemented, future expansion
2451:                
2452:                  Returns:
2453:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2454:                    the buffer.
2455:                */
2456:                
2457:                DRV_I2C_BUFFER_HANDLE DRV_I2C_TransmitThenReceive   (   DRV_HANDLE handle, 
2458:                                                                        uint16_t address,
2459:                                                                        void *writeBuffer,
2460:                                                                        size_t writeSize,
2461:                                                                        void *readBuffer,
2462:                                                                        size_t readSize,
2463:                                                                        void * callbackContext)
2464:                {
00000000  00000000   NOP
2465:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2466:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000030  00000000   NOP
2467:                
2468:                     /* Get a slot in the queue */
2469:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
00000034  00000000   NOP
2470:                
2471:                    if ( i2cDataObj != NULL )
0000003C  00000000   NOP
2472:                    {
2473:                      /* Fill the data directly to the queue. Set the inUse flag only at the end */
2474:                        i2cDataObj->clientHandle        = handle;
00000044  00000000   NOP
2475:                        if (address > ADDRESS_7BIT_UPPER_LIMIT )
00000048  00000000   NOP
2476:                        {
2477:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)((address & 0xFF00)>>8);
00000054  00000000   NOP
2478:                            i2cDataObj->slaveaddresslowbyte  = (uint8_t)(address & 0x00FF);
2479:                        }
2480:                        else
2481:                        {
2482:                            i2cDataObj->slaveaddresshighbyte = (uint8_t)(address & 0x00FF);
2483:                            i2cDataObj->slaveaddresslowbyte  = 0;
00000064  00000000   NOP
2484:                        }
2485:                        i2cDataObj->operation           = DRV_I2C_OP_WRITE_READ;
00000068  00000000   NOP
2486:                        i2cDataObj->txBuffer            = writeBuffer;
00000070  00000000   NOP
2487:                        i2cDataObj->transferSize        = writeSize;
00000074  00000000   NOP
2488:                        i2cDataObj->rxBuffer            = readBuffer;
00000078  00000000   NOP
2489:                        i2cDataObj->readtransferSize    = readSize;
00000080  00000000   NOP
2490:                        i2cDataObj->actualtransfersize  = 0;
00000088  00000000   NOP
2491:                        i2cDataObj->status              = DRV_I2C_BUFFER_EVENT_PENDING;
0000008C  00000000   NOP
2492:                        i2cDataObj->context             = callbackContext;
00000090  00000000   NOP
2493:                        i2cDataObj->transmitForced      = false;
00000098  00000000   NOP
2494:                
2495:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
0000009C  00000000   NOP
2496:                
2497:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
000000A8  00000000   NOP
2498:                        {
2499:                           
2500:                            /*  if either START and STOP were not detected which is true the 
2501:                                first time OR if STOP was detected, then it assumed the 
2502:                                transaction on the bus is complete */
2503:                            
2504:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
000000C0  00000000   NOP
000000D0  00000000   NOP
000000E0  00000000   NOP
2505:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2506:                            {
2507:                            
2508:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2509:                                
2510:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
000001C4  00000000   NOP
2511:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2512:                                {
2513:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2514:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2515:                                    
2516:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
00000124  00000000   NOP
2517:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
0000013C  00000000   NOP
2518:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2519:                                }
2520:                            }
2521:                        }
2522:                        else
2523:                        {
2524:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2525:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
00000170  00000000   NOP
2526:                
2527:                        }
2528:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
00000108  00000000   NOP
00000148  00000000   NOP
00000190  00000000   NOP
2529:                    }
2530:                     return (DRV_I2C_BUFFER_HANDLE)NULL;
00000198  00000000   NOP
2531:                } /* DRV_I2C_TransmitThenReceive */
000001D0  00000000   NOP
2532:                
2533:                //******************************************************************************
2534:                /* Function:
2535:                    DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWriteRead (  DRV_HANDLE handle,
2536:                                                                        uint8_t* address,
2537:                                                                        void *txBuffer,
2538:                                                                        size_t wsize,
2539:                                                                        void *rxBuffer,
2540:                                                                        size_t rsize,
2541:                                                                        void * context);
2542:                
2543:                  Summary:
2544:                    This function writes data to Slave, inserts restart and requests read from
2545:                    slave.
2546:                
2547:                  Description:
2548:                    Master calls this function to send a register address value to the slave and
2549:                    then queries the slave with a read request to read the contents indexed by
2550:                    the register location. The Master sends a restart condition after the
2551:                    initial write before sending the device address with R/W = 1. The restart
2552:                    condition prevents the Master from relinquishing the control of the bus. The
2553:                    slave should not use this function. Driver will process this request
2554:                    in the task routine.
2555:                
2556:                  Parameters:
2557:                    drvHandle   - A valid open-instance handle, returned from the driver's open
2558:                                  routine
2559:                    address     - Device address of slave. If this API is used in Slave mode,
2560:                                  then a dummy value can be used
2561:                    txBuffer    - Contains data to be transffered
2562:                    wsize       - The number of bytes that the Master expects to write to Slave.
2563:                                  This value can be kept as the MAX BUFFER SIZE for slave.
2564:                                  This is because the Master controls when the WRITE operation
2565:                                  is terminated.
2566:                    rxBuffer    - This buffer holds data that is send back from slave after
2567:                                  read operation.
2568:                    rsize       - The number of bytes the Master expects to be read from the
2569:                                  slave
2570:                    context     - Not implemented, future expansion
2571:                
2572:                  Returns:
2573:                    DRV_I2C_BUFFER_HANDLE using which application can track the current status of
2574:                    the buffer.
2575:                */
2576:                
2577:                DRV_I2C_BUFFER_HANDLE DRV_I2C_BufferAddWriteRead (  DRV_HANDLE handle, 
2578:                                                                    uint8_t* address,
2579:                                                                    void *txBuffer,
2580:                                                                    size_t wsize,
2581:                                                                    void *rxBuffer,
2582:                                                                    size_t rsize,
2583:                                                                    void * context)
2584:                {
00000000  00000000   NOP
2585:                    DRV_I2C_BUFFER_OBJECT *i2cDataObj;
2586:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000030  00000000   NOP
2587:                
2588:                     /* Get a slot in the queue */
2589:                    i2cDataObj = _DRV_I2C_QueueSlotGet (dObj);
00000034  00000000   NOP
2590:                    
2591:                    if ( i2cDataObj != NULL )
0000003C  00000000   NOP
2592:                    {
2593:                      /* Fill the data directly to the queue. Set the inUse flag only at the end */
2594:                        i2cDataObj->clientHandle                = handle;
00000044  00000000   NOP
2595:                        i2cDataObj->slaveaddresshighbyte        = *(address);
00000048  00000000   NOP
2596:                        i2cDataObj->slaveaddresslowbyte         = 0x00;
00000050  00000000   NOP
2597:                        i2cDataObj->operation                   = DRV_I2C_OP_WRITE_READ;
00000054  00000000   NOP
2598:                        i2cDataObj->txBuffer                    = txBuffer;
0000005C  00000000   NOP
2599:                        i2cDataObj->transferSize                = wsize;
00000060  00000000   NOP
2600:                        i2cDataObj->rxBuffer                    = rxBuffer;
00000064  00000000   NOP
2601:                        i2cDataObj->readtransferSize            = rsize;
0000006C  00000000   NOP
2602:                        i2cDataObj->actualtransfersize          = 0;
00000074  00000000   NOP
2603:                        i2cDataObj->status                      = DRV_I2C_BUFFER_EVENT_PENDING;
00000078  00000000   NOP
2604:                        i2cDataObj->context                     = context;
0000007C  00000000   NOP
2605:                        i2cDataObj->transmitForced              = false;
00000084  00000000   NOP
2606:                
2607:                        _DRV_I2C_QueuePush( dObj, i2cDataObj);
00000088  00000000   NOP
2608:                
2609:                        if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
00000094  00000000   NOP
2610:                        {
2611:                            
2612:                            /*  if either START and STOP were not detected which is true the 
2613:                                first time OR if STOP was detected, then it assumed the 
2614:                                transaction on the bus is complete */
2615:                            
2616:                            if ( ((!(PLIB_I2C_StartWasDetected(dObj->i2cId))) && (!(PLIB_I2C_StopWasDetected(dObj->i2cId)))) ||
000000AC  00000000   NOP
000000BC  00000000   NOP
000000CC  00000000   NOP
2617:                                    (PLIB_I2C_StopWasDetected(dObj->i2cId)) )
2618:                            {
2619:                            
2620:                                /* if Bus IDLE and I2CxMIF = 0, then I2C is not running*/
2621:                                
2622:                                if ( (PLIB_I2C_BusIsIdle(dObj->i2cId)) &&
000001B0  00000000   NOP
2623:                                       (!(SYS_INT_SourceStatusGet(dObj->mstrInterruptSource))) )
2624:                                {
2625:                //                    SYS_INT_SourceStatusClear(dObj->mstrInterruptSource);
2626:                                    _DRV_I2C_InterruptSourceEnable( dObj->mstrInterruptSource ) ;
2627:                                    
2628:                                    _DRV_I2C_InterruptSourceEnable( dObj->errInterruptSource );
00000110  00000000   NOP
2629:                                    dObj->task = DRV_I2C_TASK_SEND_DEVICE_ADDRESS;
00000128  00000000   NOP
2630:                                    PLIB_I2C_MasterStart(dObj->i2cId);
2631:                                }
2632:                            }
2633:                        }
2634:                        else
2635:                        {
2636:                           SYS_INT_SourceStatusClear(dObj->slaveInterruptSource);
2637:                           _DRV_I2C_InterruptSourceEnable( dObj->slaveInterruptSource ) ;
0000015C  00000000   NOP
2638:                
2639:                        }
2640:                        return (DRV_I2C_BUFFER_HANDLE) i2cDataObj;
000000F4  00000000   NOP
00000134  00000000   NOP
0000017C  00000000   NOP
2641:                    }
2642:                     return (DRV_I2C_BUFFER_HANDLE)NULL;
00000184  00000000   NOP
2643:                } /* DRV_I2C_BufferAddWrite */
000001BC  00000000   NOP
2644:                
2645:                // *****************************************************************************
2646:                /* Function:
2647:                    DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2648:                
2649:                  Summary:
2650:                    Returns the transmitter and receiver transfer status
2651:                
2652:                  Description:
2653:                    This returns the transmitter and receiver transfer status.
2654:                
2655:                  Parameters:
2656:                   
2657:                    handle          - A valid open-instance handle, returned from the driver's 
2658:                                      open routine 
2659:                    bufferHandle    - A valid open-instance handle, returned when calling the 
2660:                                      BufferAddRead/BufferAddWrite/BufferAddReadWrite function
2661:                
2662:                  Returns:
2663:                    A DRV_I2C_TRANSFER_STATUS value describing the current status of the
2664:                    transfer.
2665:                */
2666:                
2667:                DRV_I2C_BUFFER_EVENT DRV_I2C_TransferStatusGet  ( DRV_HANDLE handle,
2668:                                                                  DRV_I2C_BUFFER_HANDLE bufferHandle )
2669:                {
2670:                    /* return the transfer status. This doesn't have any protection */
2671:                
2672:                    return _DRV_I2C_DATA_OBJ(bufferHandle, status);
2673:                
2674:                } /* DRV_I2C_TransferStatus */
9D00392C  03E00008   JR RA
9D003930  8CA2002C   LW V0, 44(A1)
2675:                
2676:                // *****************************************************************************
2677:                /* Function:
2678:                    DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2679:                
2680:                  Summary:
2681:                    Returns the transmitter and receiver transfer status
2682:                
2683:                  Description:
2684:                    This returns the transmitter and receiver transfer status.
2685:                
2686:                  Parameters:
2687:                    handle       - A valid open-instance handle, returned from the driver's
2688:                                   open routine
2689:                
2690:                  Returns:
2691:                    A DRV_I2C_TRANSFER_STATUS value describing the current status of the
2692:                    transfer.
2693:                */
2694:                
2695:                DRV_I2C_BUFFER_EVENT DRV_I2C_BufferStatus ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2696:                {
2697:                    /* return the transfer status. This doesn't have any protection */
2698:                
2699:                    return _DRV_I2C_DATA_OBJ(bufferHandle, status);
2700:                
2701:                } /* DRV_I2C_TransferStatus */
2702:                
2703:                
2704:                // *****************************************************************************
2705:                /* Function:
2706:                    uint32_t DRV_I2C_BytesTransferred ( DRV_I2C_BUFFER_HANDLE bufferHandle )
2707:                
2708:                  Summary:
2709:                    Returns the number of bytes transmitted or received in a particular I2C 
2710:                    transaction. The transaction is identified by the handle.
2711:                
2712:                  Description:
2713:                    This returns the transmitter and receiver transfer status.
2714:                
2715:                  Parameters:
2716:                   
2717:                    handle      - A valid open-instance handle, returned from the driver's open
2718:                                  routine 
2719:                    bufferHandle  -  A valid open-instance handle, returned when calling the 
2720:                                     BufferAddRead/BufferAddWrite/BufferAddReadWrite function
2721:                
2722:                  Returns:
2723:                    The number of bytes transferred in a particular I2C transaction. 
2724:                */
2725:                
2726:                uint32_t DRV_I2C_BytesTransferred ( DRV_HANDLE handle,
2727:                                                    DRV_I2C_BUFFER_HANDLE bufferHandle )
2728:                {
2729:                    /* returns the number of bytes in an I2C transaction */
2730:                
2731:                    return _DRV_I2C_DATA_OBJ(bufferHandle, actualtransfersize);
2732:                
2733:                } /* DRV_I2C_BytesTransferred */
2734:                
2735:                
2736:                
2737:                //******************************************************************************
2738:                /* Function:
2739:                    unsigned int DRV_I2C_VersionGet( const SYS_MODULE_INDEX drvIndex )
2740:                
2741:                  Summary:
2742:                    Gets I2C driver version in numerical format.
2743:                
2744:                  Description:
2745:                    This routine gets the I2C driver version. The version is encoded as
2746:                    major * 10000 + minor * 100 + patch. The stringized version can be obtained
2747:                    using DRV_I2C_VersionStrGet()
2748:                
2749:                  Parameters:
2750:                    None.
2751:                
2752:                  Returns:
2753:                    Current driver version in numerical format.
2754:                */
2755:                
2756:                unsigned int DRV_I2C_VersionGet( const SYS_MODULE_INDEX drvIndex )
2757:                {
2758:                    return( ( _DRV_I2C_VERSION_MAJOR * 10000 ) +
2759:                            ( _DRV_I2C_VERSION_MINOR * 100 ) +
2760:                            ( _DRV_I2C_VERSION_PATCH ) );
2761:                
2762:                } /* DRV_I2C_VersionGet */
2763:                
2764:                
2765:                // *****************************************************************************
2766:                /* Function:
2767:                    char * DRV_I2C_VersionStrGet ( const SYS_MODULE_INDEX drvIndex )
2768:                
2769:                  Summary:
2770:                    Gets I2C driver version in string format.
2771:                
2772:                  Description:
2773:                    This routine gets the I2C driver version. The version is returned as
2774:                    major.minor.path[type], where type is optional. The numerical version can
2775:                    be obtained using DRV_I2C_VersionGet()
2776:                
2777:                  Parameters:
2778:                    None.
2779:                
2780:                  Returns:
2781:                    Current I2C driver version in the string format.
2782:                
2783:                  Remarks:
2784:                    None.
2785:                */
2786:                
2787:                char * DRV_I2C_VersionStrGet( const SYS_MODULE_INDEX drvIndex )
2788:                {
2789:                    return _DRV_I2C_VERSION_STR;
2790:                
2791:                } /* DRV_I2C_VersionStrGet */
2792:                
2793:                // *****************************************************************************
2794:                /*
2795:                  Remarks:
2796:                    The functions DRV_I2C_StopEventSend, DRV_I2C_RestartEventSend and 
2797:                    and DRV_I2C_IRQEventSend are deprecated but maintained for backward 
2798:                    compatibility
2799:                */
2800:                
2801:                void DRV_I2C_StopEventSend(DRV_HANDLE handle)
2802:                {
2803:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000000  00000000   NOP
2804:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
00000004  00000000   NOP
2805:                    {
2806:                        PLIB_I2C_MasterStop (dObj->i2cId);
2807:                    }
2808:                }
2809:                
2810:                void DRV_I2C_RestartEventSend(DRV_HANDLE handle)
2811:                {
2812:                    DRV_I2C_OBJ *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000000  00000000   NOP
2813:                
2814:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_MASTER)
00000004  00000000   NOP
2815:                    {
2816:                        PLIB_I2C_MasterStartRepeat (dObj->i2cId);
2817:                    }
2818:                }
2819:                
2820:                void DRV_I2C_IRQEventSend(DRV_HANDLE handle)
2821:                {
2822:                    DRV_I2C_CLIENT_OBJ *clientObj = (DRV_I2C_CLIENT_OBJ*) handle;
2823:                
2824:                    DRV_I2C_OBJ  *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000000  00000000   NOP
2825:                
2826:                    if ( (_DRV_I2C_OPERATION_MODE_GET(dObj->i2cMode)) == DRV_I2C_MODE_SLAVE)
00000004  00000000   NOP
2827:                    {
2828:                        PLIB_PORTS_PinClear(PORTS_ID_0, clientObj->irqSelectPort, clientObj->irqSelectBitPos);
2829:                        dObj->modulemainstate = DRV_I2C_SLAVE_READY_TO_TX_TO_MASTER;
00000040  00000000   NOP
2830:                    }
2831:                }
2832:                
2833:                void DRV_I2C_QueueFlush ( DRV_HANDLE handle )
2834:                {
2835:                    uint16_t index;
2836:                    
2837:                    DRV_I2C_OBJ  *dObj = ((DRV_I2C_CLIENT_OBJ *) handle)->driverObject;
00000000  00000000   NOP
2838:                    
2839:                    SYS_MODULE_INDEX drvIndex = dObj->drvIndex;
00000004  00000000   NOP
2840:                        
2841:                    DRV_I2C_BUFFER_OBJECT *lQueueObj;
2842:                    
2843:                    dObj->queueHead = NULL;
00000008  00000000   NOP
2844:                    
2845:                    dObj->queueIn = 0;
0000000C  00000000   NOP
2846:                    
2847:                    dObj->queueOut = 0;
00000010  00000000   NOP
2848:                
2849:                    for ( index=0; index<DRV_I2C_NUM_OF_BUFFER_OBJECTS; index++ )
00000050  00000000   NOP
2850:                    {
2851:                        lQueueObj = &gDrvI2CBufferObj [ drvIndex ][ index ];
2852:                
2853:                        lQueueObj->inUse    = false;
00000014  00000000   NOP
00000040  00000000   NOP
2854:                        
2855:                        lQueueObj->next     = NULL;
00000044  00000000   NOP
2856:                        
2857:                        lQueueObj->status   = DRV_I2C_BUFFER_EVENT_COMPLETE;
0000003C  00000000   NOP
00000048  00000000   NOP
2858:                    }
2859:                    
2860:                    /* When an I2C transaction is attempted without any pull-ups on the bus
2861:                       I2C Master ISR is triggered for START condition, but also Bus Exception
2862:                       ISR is also triggered, to clear BCL bit, I2C has to reset */
2863:                    
2864:                    SYS_INT_SourceStatusClear(dObj->errInterruptSource);
00000058  00000000   NOP
2865:                    PLIB_I2C_Disable (dObj->i2cId);
2866:                    PLIB_I2C_Enable (dObj->i2cId);
2867:                }
2868:                
2869:                
2870:                /*******************************************************************************
2871:                End of File
2872:                */
2873:                
2874:                
2875:                
---  /build/bamboo/xml-data/build-dir/XC32-CYXC32-JOB1/xc32-XC32-release-1_42/src48x/gcc/libgcc/floatunsisf.c
00000000  00000000   NOP
00000008  00000000   NOP
00000024  00000000   NOP
00000010  00000000   NOP
00000018  00000000   NOP
00000040  00000000   NOP
